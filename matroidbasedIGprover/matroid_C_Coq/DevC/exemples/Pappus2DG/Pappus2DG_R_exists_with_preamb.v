Require Export List.
Require Export Lia.
Require Export Morphisms.

Parameter Point : Set.
Parameter eq_dec : forall A B : Point, {A = B} + {~ A = B}.

Definition equivlist (l l':list Point) := forall x, List.In x l <-> List.In x l'.

Ltac simplgen H := simpl in H;generalize H.

Ltac my_inS :=
  intuition;unfold incl in *;unfold equivlist in *;
  repeat match goal with
  |[H : _ |- _] => progress intros
  |[H : _ |- _] => progress intro
  |[H : _ |- _] => progress intuition
  |[H : _ |- _] => split;intuition
  |[H : In _ (?P ::  _ ) |- _] => inversion H;clear H
  |[H : _ = _ |- _] => rewrite <-H
  |[H : In _ nil |- _] => inversion H
  end.

Parameter rk : list Point -> nat.
Parameter rk_compat : forall x x', equivlist x x' -> rk x = rk x'.

Global Instance rk_morph : Proper (equivlist ==> (@Logic.eq nat)) rk.
Proof.
intros;repeat red.
apply rk_compat.
Qed.

(*** Definition Inb ***)
Fixpoint Inb (a:Point) (l:list Point) {struct l} : bool :=
    match l with
      | nil => false
      | b :: m => if (eq_dec b a) then true else Inb a m
    end.

Lemma Inb_aux1 :
forall a l, Inb a l = true -> In a l.
Proof.
my_inS;induction l;my_inS.
- inversion H.
- simplgen H;case_eq(eq_dec a0 a);my_inS.
Qed.

Lemma Inb_aux2 :
forall a l, Inb a l = false -> ~In a l.
Proof.
my_inS;induction l;my_inS.
- rewrite H1 in *;simplgen H;case_eq(eq_dec a a);my_inS.
- simplgen H;case_eq(eq_dec a0 a);my_inS.
Qed.

(*** Definition list_inter ***)
Definition list_inter l1 l2 := filter (fun x : Point => Inb x l2) l1.

Lemma list_inter_split :
forall a l m, In a (list_inter l m) -> In a l /\ In a m.
Proof.
intros.
my_inS;induction l;my_inS.
- simplgen H;unfold list_inter;simpl;case_eq(Inb a0 m);my_inS.
- inversion H.
- simplgen H;unfold list_inter;simpl;case_eq(Inb a0 m);my_inS;apply Inb_aux1;my_inS.
Qed.

Lemma list_inter_closure :
forall a l m, In a m -> In a l -> In a (list_inter l m).
Proof.
my_inS;induction l;my_inS.
- simpl;case_eq(Inb a0 m);my_inS;assert(HH := Inb_aux2 a0 m H0);subst;my_inS.
- simpl;case_eq(Inb a0 m);my_inS.
Qed.

Ltac inv_unif :=
  unfold incl in *; try split; intros;
  repeat match goal with 
         | [H : In _ (?P ::  _ ) |- _] => inversion H;clear H
         | [H: _ = _ |- _] => rewrite <- H in *;try solve [contradiction|apply eq_sym in H;contradiction];clear H
         | [H : In _ nil |- _] => inversion H
         | [H : In _ (?L++?M) |- _] => apply in_app_iff in H; destruct H
         | [H :_ |- In _ (?L++?M) ] => apply in_app_iff
         | [H : In _ (list_inter _ _) |- _] => apply list_inter_split in H; destruct H
         | [H : _ |- In _ (list_inter _ _)] => apply list_inter_closure
         end.

Ltac solve_equivlist := first [apply in_eq | apply in_cons ; solve_equivlist].

Ltac my_inO := solve[inv_unif ; first[solve_equivlist | left;solve_equivlist | right;solve_equivlist]].

Parameter matroid1_a  : forall X, rk X >= 0.
Parameter matroid1_b : forall X, rk X <= length X.
Parameter matroid2 : forall X Y, incl X Y -> rk X <= rk Y.
Parameter matroid3 : forall X Y, rk(X ++ Y) + rk(list_inter X Y) <= rk X + rk Y.

(*** Lemmes matroides utiles ***)
Lemma matroid1_b_useful : forall (l : list Point) (m : nat), length l <= m -> rk l <= m.
Proof.
intros.
assert(HH := matroid1_b l).
lia.
Qed.

Lemma matroid3_useful : forall e e' ei : list Point,
 incl ei (list_inter e e') ->
 rk(e ++ e') + rk(ei) <= rk(e) + rk(e').
Proof.
intros.
assert (rk (e ++ e') + rk (list_inter e e') <= rk e + rk e').
apply matroid3.
assert (rk (ei) <= rk (list_inter e e')).
apply matroid2;auto.
lia.
Qed.

Lemma couple_equal : forall A B, rk(A :: B :: nil) = rk(B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_1 : forall A B C, rk(A :: B :: C :: nil) = rk(A :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_2 : forall A B C, rk(A :: B :: C :: nil) = rk(B :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_3 : forall A B C, rk(A :: B :: C :: nil) = rk(B :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_4 : forall A B C, rk(A :: B :: C :: nil) = rk(C :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_5 : forall A B C, rk(A :: B :: C :: nil) = rk(C :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma rk_triple_max_3 : forall X Y Z : Point, rk(X :: Y :: Z :: nil) <= 3.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_quadruple_max_4 : forall W X Y Z : Point,rk(W :: X :: Y :: Z :: nil) <= 4.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma quadruple_equal_1 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: B :: D :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_2 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: C :: B :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_3 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: C :: D :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_4 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: D :: B :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_5 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: D :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_6 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: A :: C :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_7 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: A :: D :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_8 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: C :: A :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_9 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: C :: D :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_10 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: D :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_11 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: D :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_12 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: A :: B :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_13 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: A :: D :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_14 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: B :: A :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_15 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: B :: D :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_16 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: D :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_17 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: D :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_18 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: A :: B :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_19 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: A :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_20 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: B :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_21 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: B :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_22 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: C :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_23 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: C :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Ltac clear_all_rk :=
repeat match goal with
| H : rk _ = _ |- _ => clear H
| H : rk _ >= _ |- _ => clear H
| H : rk _ <= _ |- _ => clear H
end.

Parameter rk_singleton_ge : forall A, rk (A :: nil)  >= 1.
Parameter rk_couple_ge : forall A B, ~ A = B -> rk(A :: B :: nil) >= 2.
Parameter rk_three_points_on_lines : forall A B, exists C, rk (A :: B :: C :: nil) = 2 /\ rk (B :: C :: nil) = 2 /\ rk (A :: C :: nil) = 2.
Parameter rk_inter : forall A B C D, rk(A :: B :: C :: D :: nil) <= 3 -> exists J : Point, rk(A :: B :: J :: nil) = 2 /\ rk (C :: D :: J :: nil) = 2.
Parameter rk_lower_dim : exists A0 A1 A2 A3, rk( A0 :: A1 :: A2 :: A3 :: nil) = 4.
Parameter rk_upper_dim : forall e, rk(e) <= 4.

Lemma rk_singleton_1 : forall A, rk(A :: nil) <= 1.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_singleton : forall A, rk(A :: nil) = 1.
Proof.
intros.
assert(H := rk_singleton_ge A).
assert(HH := rk_singleton_1 A).
lia.
Qed.

Lemma matroid1_b_useful2 : forall (l : list Point) (a : Point), length (a :: l) >= 1 -> rk (a :: l) >= 1.
Proof.
intros.
assert(HH := rk_singleton a).
assert(HH0 := matroid2 (a :: nil) (a :: l)).
assert(HH1 : incl (a :: nil) (a :: l));[my_inO|].
assert(HH2 := HH0 HH1).
lia.
Qed.

Lemma rk_couple_2 : forall A B, rk(A :: B :: nil) <= 2.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_couple : forall A B : Point,~ A = B -> rk(A :: B :: nil) = 2.
Proof.
intros.
assert(HH := rk_couple_2 A B).
assert(HH0 := rk_couple_ge A B H).
lia.
Qed.

Lemma rk_triple_3 : forall A B C : Point, rk (A :: B :: C :: nil) <= 3.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma couple_rk1 : forall A B, rk(A :: B :: nil) = 2 -> ~ A = B.
Proof.
intros.
intro.
rewrite H0 in H.
assert(HH : equivlist (B :: B :: nil) (B :: nil));[my_inO|].
rewrite HH in H.
assert(HH0 := rk_singleton_1 B).
lia.
Qed.

Lemma couple_rk2 : forall A B, rk(A :: B :: nil) = 1 -> A = B.
Proof.
intros.
case_eq(eq_dec A B).
intros.
assumption.
intros.
assert(HH := rk_couple A B n).
lia.
Qed.

Lemma rule_1 : forall A B AiB, forall MA MB mAiB, 
rk(A) <= MA -> rk(B) <= MB -> rk(AiB) >= mAiB -> incl AiB (list_inter A B) ->
rk(A ++ B) <= MA + MB - mAiB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_2 : forall A B AiB, forall mAuB mAiB MB, 
rk(A ++ B) >= mAuB -> rk(AiB) >= mAiB -> rk(B) <= MB -> incl AiB (list_inter A B) ->
rk(A) >= mAuB + mAiB - MB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_3 : forall A B AiB, forall MA MB mAuB, 
rk(A) <= MA -> rk(B) <= MB -> rk(A ++ B) >= mAuB -> incl AiB (list_inter A B) ->
rk(AiB) <= MA + MB - mAuB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_4 : forall A B AiB, forall mAuB mAiB MA, 
rk(A ++ B) >= mAuB -> rk(AiB) >= mAiB -> rk(A) <= MA -> incl AiB (list_inter A B) ->
rk(B) >= mAuB + mAiB - MA.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_5 : forall A B, forall mA mB, 
rk(A) >= mA -> mA >= mB -> incl A B ->
rk(B) >= mA.
Proof.
intros.
assert(HH := matroid2 A B H1).
lia.
Qed.

Lemma rule_6 : forall A B, forall MA MB, 
rk(B) <= MB -> MB <= MA -> incl A B ->
rk(A) <= MB.
Proof.
intros.
assert(HH := matroid2 A B H1).
lia.
Qed.

Lemma rule_7 : forall A B, forall mA mB, 
rk(B) >= mB -> mB >= mA -> incl B A ->
rk(A) >= mB.
Proof.
intros.
assert(HH := matroid2 B A H1).
lia.
Qed.

Lemma rule_8 : forall A B, forall MA MB, 
rk(A) <= MA -> MA <= MB -> incl B A ->
rk(B) <= MA.
Proof.
intros.
assert(HH := matroid2 B A H1).
lia.
Qed.

Parameter rk_pappus : forall A B C D E F G H I,
rk(A :: B :: nil) = 2 -> rk(A :: C :: nil) = 2 -> rk(A :: D :: nil) = 2 -> 
rk(A :: E :: nil) = 2 -> rk(A :: F :: nil) = 2 ->
rk(B :: C :: nil) = 2 -> rk(B :: D :: nil) = 2 -> rk(B :: E :: nil) = 2 ->
rk(B :: F :: nil) = 2 ->
rk(C :: D :: nil) = 2 -> rk(C :: E :: nil) = 2 -> rk(C :: F :: nil) = 2 ->
rk(D :: E :: nil) = 2 -> rk(D :: F :: nil) = 2 ->
rk(E :: F :: nil) = 2 ->
rk(A :: B :: C :: nil) = 2 -> rk(D :: E :: F :: nil) = 2 -> 
rk(A :: E :: G :: nil) = 2 -> rk(B :: D :: G :: nil) = 2 ->
rk(A :: F :: H :: nil) = 2 -> rk(C :: D :: H :: nil) = 2 ->
rk(B :: F :: I :: nil) = 2 -> rk(C :: E :: I :: nil) = 2 -> rk(G :: H :: I :: nil) = 2.

Ltac rk_couple_triple :=
  match goal with

| H : rk(?A :: ?B :: nil) = 2 |- rk(?A :: ?B :: nil) = 2 => assumption
| H : rk(?B :: ?A :: nil) = 2 |- rk(?A :: ?B :: nil) = 2 => rewrite couple_equal in H;assumption

| H : rk(?A :: ?B :: ?C :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => assumption
| H : rk(?A :: ?C :: ?B :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_1 in H;assumption
| H : rk(?B :: ?A :: ?C :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_2 in H;assumption
| H : rk(?B :: ?C :: ?A :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_3 in H;assumption
| H : rk(?C :: ?A :: ?B :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_4 in H;assumption
| H : rk(?C :: ?B :: ?A :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_5 in H;assumption
end.


Ltac clear_ineg_rk :=
repeat match goal with
| H : rk _ >= _ |- _ => clear H
| H : rk _ <= _ |- _ => clear H
end.


Ltac equalize_pts :=
repeat match goal with
| H : rk (?X0 :: ?X1 :: nil) = 1 |- _ => 
          let HH := fresh in assert(HH := couple_rk2 X0 X1 H);clear H;rewrite HH
end.

Ltac eliminate_hyps :=
repeat match goal with
| H : rk ?X = _, H0 : rk ?X >= _ |- _ => clear H0
| H : rk ?X = _, H0 : rk ?X <= _ |- _ => clear H0
| H : rk ?X >= _, H0 : rk ?X >= _ |- _ => clear H
| H : rk ?X <= _, H0 : rk ?X <= _ |- _ => clear H
| H : rk ?X >= ?Y, H0 : rk ?X <= ?Y |- _ =>  let HH := fresh in assert(HH : rk X = Y) by (lia)
end.

Lemma le_S_sym : forall n m : nat,
n >= S m -> n >= m.
Proof.
intros.
intuition.
Qed.

Lemma eq_to_ge : forall n m : nat,
n = m -> n >= m.
Proof.
intros.
lia.
Qed.

Lemma eq_to_le : forall n m : nat,
n = m -> n <= m.
Proof.
intros.
lia.
Qed.

Lemma eq_le_incl : forall n m, n = m -> n <= m.
Proof.
  intros; lia.
Qed.

Ltac solve_hyps_max H H0 :=
solve[apply matroid1_b_useful;simpl;repeat constructor
|apply rk_upper_dim
|apply eq_le_incl;apply H
|apply eq_le_incl;apply eq_sym;apply H
|apply H0
|apply le_S;apply H0
|apply le_S;apply le_S;apply H0
|apply le_S;apply le_S;apply le_S;apply H0
|lia
].

Ltac solve_hyps_min H H0:=
solve[apply matroid1_b_useful2;simpl;repeat constructor
|apply matroid1_a
|apply eq_le_incl;apply H
|apply eq_le_incl;apply eq_sym;apply H
|apply H0
|apply le_S_sym;apply H0
|apply le_S_sym;apply le_S_sym;apply H0
|apply le_S_sym;apply le_S_sym;apply le_S_sym;apply H0
|lia
].
 




(*------------------------------------

debut de la preuve
de l'existence de R

--------------------------------------*)


(* dans la couche 0 *)
Lemma LOo : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LA : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HAM : rk(A ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAeq HAM1).
assert(HAm : rk(A ::  nil) >= 1) by (solve_hyps_min HAeq HAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoA : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoAM : rk(Oo :: A ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoAeq HOoAM2).
assert(HOoAm : rk(Oo :: A ::  nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LB : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HBM : rk(B ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBeq HBM1).
assert(HBm : rk(B ::  nil) >= 1) by (solve_hyps_min HBeq HBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoB : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoBM : rk(Oo :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBeq HOoBM2).
assert(HOoBm : rk(Oo :: B ::  nil) >= 1) by (solve_hyps_min HOoBeq HOoBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAB : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HABM : rk(A :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABeq HABM2).
assert(HABm : rk(A :: B ::  nil) >= 1) by (solve_hyps_min HABeq HABm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAB *)
(* dans la couche 0 *)
Lemma LOoABC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoABCM : rk(Oo :: A :: B :: C ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCm : rk(Oo :: A :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoABCeq HOoABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAB : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABM2 : rk(Oo :: A :: B :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoABM : rk(Oo :: A :: B ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABeq HOoABM3).
assert(HOoABm : rk(Oo :: A :: B ::  nil) >= 1) by (solve_hyps_min HOoABeq HOoABm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HCM : rk(C ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCeq HCM1).
assert(HCm : rk(C ::  nil) >= 1) by (solve_hyps_min HCeq HCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoCM : rk(Oo :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCeq HOoCM2).
assert(HOoCm : rk(Oo :: C ::  nil) >= 1) by (solve_hyps_min HOoCeq HOoCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACm2 : rk(Oo :: A :: C :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACM2 : rk(Oo :: A :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoACM : rk(Oo :: A :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACeq HOoACM3).
assert(HOoACm : rk(Oo :: A :: C ::  nil) >= 1) by (solve_hyps_min HOoACeq HOoACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HBCM : rk(B :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCeq HBCM2).
assert(HBCm : rk(B :: C ::  nil) >= 1) by (solve_hyps_min HBCeq HBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCm2 : rk(Oo :: B :: C :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCM2 : rk(Oo :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoBCM : rk(Oo :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBCeq HOoBCM3).
assert(HOoBCm : rk(Oo :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoBCeq HOoBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABC : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCM2 : rk(A :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

assert(HABCM : rk(A :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCeq HABCM3).
assert(HABCm : rk(A :: B :: C ::  nil) >= 1) by (solve_hyps_min HABCeq HABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HApM : rk(Ap ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HApeq HApM1).
assert(HApm : rk(Ap ::  nil) >= 1) by (solve_hyps_min HApeq HApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoApM : rk(Oo :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoApeq HOoApM2).
assert(HOoApm : rk(Oo :: Ap ::  nil) >= 1) by (solve_hyps_min HOoApeq HOoApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAAp *)
(* dans la couche 0 *)
Lemma LOoAAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoAApM : rk(Oo :: A :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAApeq HOoAApM3).
assert(HOoAApm : rk(Oo :: A :: Ap ::  nil) >= 1) by (solve_hyps_min HOoAApeq HOoAApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)AAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HAApm2 : rk(A :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: nil) (Oo :: A :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: Ap :: nil) ((Oo :: A :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApmtmp;try rewrite HT2 in HOoAApmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HOoAApmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


assert(HAApM : rk(A :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAApeq HAApM2).
assert(HAApm : rk(A :: Ap ::  nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans constructLemma(), requis par LBApMQ *)
(* dans constructLemma(), requis par LOoBCApMQ *)
(* dans la couche 0 *)
Lemma LOoABCApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoABCApMQM : rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApMQm : rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMQ requis par la preuve de (?)OoBCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMQ requis par la preuve de (?)OoBCApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMQm3 : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: nil) 4 1 2 HOoABCApMQmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoBCApMQm4 : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: Oo :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: nil) 4 2 2 HOoABCApMQmtmp HOoBmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoBCApMQM : rk(Oo :: B :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApMQm : rk(Oo :: B :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoBCApMQeq HOoBCApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Ap :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApMQ requis par la preuve de (?)BApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMQ requis par la preuve de (?)BApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMQ requis par la preuve de (?)BCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMQ requis par la preuve de (?)BCApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCApMQm2 : rk(B :: C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: nil) ++ (B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: nil) (nil) 4 0 2 HOoABCApMQmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApMQm3 : rk(B :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: nil) (B :: nil) 4 1 2 HOoABCApMQmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApMQ requis par la preuve de (?)BApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApMQ requis par la preuve de (?)BApMQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApMQ requis par la preuve de (?)BApMQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBApMQM3 : rk(B :: Ap :: M :: Q :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: M :: Q :: nil) ((B :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: M :: Q :: nil) (nil) 1 2 0 HBMtmp HApMQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: M :: Q ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HBApMQm2 : rk(B :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBCApMQmtmp : rk(B :: C :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBCApMQeq HBCApMQm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Q :: nil) (C :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: B :: Ap :: M :: Q :: nil) ((C :: nil) ++ (B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMQmtmp;try rewrite HT2 in HBCApMQmtmp.
	assert(HT := rule_4 (C :: nil) (B :: Ap :: M :: Q :: nil) (nil) 3 0 1 HBCApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBApMQm3 : rk(B :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMQeq : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoBCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMQmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBCApMQeq HOoBCApMQm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: C :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: Ap :: M :: Q :: nil) ((Oo :: B :: C :: nil) ++ (B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQmtmp;try rewrite HT2 in HOoBCApMQmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: Ap :: M :: Q :: nil) (B :: nil) 4 1 2 HOoBCApMQmtmp HBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBApMQM : rk(B :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApMQm : rk(B :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HBApMQeq HBApMQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HApMQM : rk(Ap :: M :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMQeq HApMQM3).
assert(HApMQm : rk(Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HApMQeq HApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBApMQeq : rk(B :: Ap :: M :: Q :: nil) = 3) by (apply LBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMQmtmp : rk(B :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBApMQeq HBApMQm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Ap :: M :: Q :: nil) ((B :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQmtmp;try rewrite HT2 in HBApMQmtmp.
	assert(HT := rule_2 (B :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 3 1 2 HBApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBAp *)
(* dans la couche 0 *)
Lemma LOoBApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApMQ requis par la preuve de (?)OoBApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApMQ requis par la preuve de (?)OoBApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApMQ requis par la preuve de (?)OoBApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMQm2 : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: Q :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBApMQm3 : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoBCApMQeq : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoBCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMQmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBCApMQeq HOoBCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: nil) (C :: Oo :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Ap :: M :: Q :: nil) ((C :: nil) ++ (Oo :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQmtmp;try rewrite HT2 in HOoBCApMQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: B :: Ap :: M :: Q :: nil) (nil) 4 0 1 HOoBCApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBApMQm4 : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMQeq : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoBCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMQmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBCApMQeq HOoBCApMQm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: C :: Oo :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: B :: Ap :: M :: Q :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQmtmp;try rewrite HT2 in HOoBCApMQmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: B :: Ap :: M :: Q :: nil) (Oo :: B :: nil) 4 2 2 HOoBCApMQmtmp HOoBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HOoBApMQM : rk(Oo :: B :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMQm : rk(Oo :: B :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoBApMQeq HOoBApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApm2 : rk(Oo :: B :: Ap :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApm3 : rk(Oo :: B :: Ap :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HOoBApMQeq : rk(Oo :: B :: Ap :: M :: Q :: nil) = 4) by (apply LOoBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApMQmtmp : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBApMQeq HOoBApMQm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: B :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Q :: nil) (Oo :: B :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: Ap :: M :: Q :: nil) ((Oo :: B :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMQmtmp;try rewrite HT2 in HOoBApMQmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 4 1 2 HOoBApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HOoBApM : rk(Oo :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBApeq HOoBApM3).
assert(HOoBApm : rk(Oo :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBApeq HOoBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABAp *)
(* dans constructLemma(), requis par LABApMQ *)
(* dans la couche 0 *)
Lemma LABCApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApMQ requis par la preuve de (?)ABCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApMQ requis par la preuve de (?)ABCApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCApMQm3 : rk(A :: B :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: A :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Ap :: M :: Q :: nil) (A :: nil) 4 1 2 HOoABCApMQmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApMQm4 : rk(A :: B :: C :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: M :: Q :: nil) (A :: B :: nil) 4 2 2 HOoABCApMQmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCApMQM : rk(A :: B :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApMQm : rk(A :: B :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HABCApMQeq HABCApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApMQ requis par la preuve de (?)ABApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApMQ requis par la preuve de (?)ABApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApMQ requis par la preuve de (?)ABApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMQm2 : rk(A :: B :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABApMQm3 : rk(A :: B :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCApMQeq : rk(A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCApMQmtmp : rk(A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HABCApMQeq HABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: M :: Q :: nil) (C :: A :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Ap :: M :: Q :: nil) ((C :: nil) ++ (A :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApMQmtmp;try rewrite HT2 in HABCApMQmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Ap :: M :: Q :: nil) (nil) 4 0 1 HABCApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABApMQm4 : rk(A :: B :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCApMQeq : rk(A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCApMQmtmp : rk(A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HABCApMQeq HABCApMQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: M :: Q :: nil) (A :: B :: C :: A :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Ap :: M :: Q :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApMQmtmp;try rewrite HT2 in HABCApMQmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Ap :: M :: Q :: nil) (A :: B :: nil) 4 2 2 HABCApMQmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABApMQM : rk(A :: B :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMQm : rk(A :: B :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HABApMQeq HABApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApm3 : rk(A :: B :: Ap :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HABApMQeq : rk(A :: B :: Ap :: M :: Q :: nil) = 4) by (apply LABApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApMQmtmp : rk(A :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HABApMQeq HABApMQm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: B :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: Q :: nil) (A :: B :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Ap :: M :: Q :: nil) ((A :: B :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMQmtmp;try rewrite HT2 in HABApMQmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 4 1 2 HABApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HABApM : rk(A :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABApeq HABApM3).
assert(HABApm : rk(A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HABApeq HABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: nil) ((Oo :: A :: B :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Ap :: nil) (nil) 2 1 0 HOoABMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCAp *)
(* dans constructLemma(), requis par LCApMQ *)
(* dans la couche 0 *)
Lemma LOoACApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMQ requis par la preuve de (?)OoACApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMQ requis par la preuve de (?)OoACApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMQ requis par la preuve de (?)OoACApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMQm2 : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACApMQm3 : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (B :: Oo :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Ap :: M :: Q :: nil) ((B :: nil) ++ (Oo :: A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: nil) (nil) 4 0 1 HOoABCApMQmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACApMQm4 : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: Oo :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMQmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACApMQM : rk(Oo :: A :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMQm : rk(Oo :: A :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoACApMQeq HOoACApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApMQ requis par la preuve de (?)CApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMQ requis par la preuve de (?)CApMQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMQ requis par la preuve de (?)CApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HCApMQm2 : rk(C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (C :: Ap :: M :: Q :: nil) (nil) 4 0 2 HOoABCApMQmtmp Hmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCApMQM3 : rk(C :: Ap :: M :: Q :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: nil) (C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: Q :: nil) ((C :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: M :: Q :: nil) (nil) 1 2 0 HCMtmp HApMQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HCApMQm3 : rk(C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (C :: Ap :: M :: Q :: nil) (C :: nil) 4 1 2 HOoACApMQmtmp HCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HCApMQM : rk(C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMQm : rk(C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HCApMQeq HCApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)CAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApm2 : rk(C :: Ap :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HCApMQeq : rk(C :: Ap :: M :: Q :: nil) = 3) by (apply LCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApMQmtmp : rk(C :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HCApMQeq HCApMQm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: nil) (C :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Ap :: M :: Q :: nil) ((C :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMQmtmp;try rewrite HT2 in HCApMQmtmp.
	assert(HT := rule_2 (C :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 3 1 2 HCApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HCApM : rk(C :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCApeq HCApM2).
assert(HCApm : rk(C :: Ap ::  nil) >= 1) by (solve_hyps_min HCApeq HCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCAp *)
(* dans la couche 0 *)
Lemma LOoCApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMQ requis par la preuve de (?)OoCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMQ requis par la preuve de (?)OoCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMQ requis par la preuve de (?)OoCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMQ requis par la preuve de (?)OoBCApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMQm3 : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: nil) 4 1 2 HOoABCApMQmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMQ requis par la preuve de (?)OoCApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCApMQm2 : rk(Oo :: C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCApMQmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HOoBCApMQeq HOoBCApMQm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: Oo :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Ap :: M :: Q :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQmtmp;try rewrite HT2 in HOoBCApMQmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Q :: nil) (Oo :: nil) 3 1 2 HOoBCApMQmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCApMQm3 : rk(Oo :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: Oo :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Q :: nil) (Oo :: nil) 4 1 2 HOoABCApMQmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoCApMQm4 : rk(Oo :: C :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hincl : incl (Oo :: C :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Oo :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: C :: Ap :: M :: Q :: nil) (Oo :: C :: nil) 4 2 2 HOoACApMQmtmp HOoCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoCApMQM : rk(Oo :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMQm : rk(Oo :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoCApMQeq HOoCApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCAp requis par la preuve de (?)OoCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCAp requis par la preuve de (?)OoCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApm2 : rk(Oo :: C :: Ap :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApm3 : rk(Oo :: C :: Ap :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HOoCApMQeq : rk(Oo :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApMQmtmp : rk(Oo :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoCApMQeq HOoCApMQm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: C :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Q :: nil) (Oo :: C :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: Ap :: M :: Q :: nil) ((Oo :: C :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMQmtmp;try rewrite HT2 in HOoCApMQmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 4 1 2 HOoCApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HOoCApM : rk(Oo :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCApeq HOoCApM3).
assert(HOoCApm : rk(Oo :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoCApeq HOoCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACAp *)
(* dans la couche 0 *)
Lemma LACApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApMQ requis par la preuve de (?)ACApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApMQ requis par la preuve de (?)ACApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApMQ requis par la preuve de (?)ACApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACApMQm2 : rk(A :: C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Ap :: M :: Q :: nil) ((Oo :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: nil) (nil) 4 0 2 HOoABCApMQmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApMQm3 : rk(A :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: nil) (A :: nil) 4 1 2 HOoABCApMQmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACApMQm4 : rk(A :: C :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Ap :: M :: Q :: nil) (A :: C :: nil) 4 2 2 HOoACApMQmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACApMQM : rk(A :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApMQm : rk(A :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HACApMQeq HACApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Ap :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApm3 : rk(A :: C :: Ap :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HACApMQeq : rk(A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACApMQmtmp : rk(A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HACApMQeq HACApMQm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: C :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Q :: nil) (A :: C :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Ap :: M :: Q :: nil) ((A :: C :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMQmtmp;try rewrite HT2 in HACApMQmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 4 1 2 HACApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HACApM : rk(A :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACApeq HACApM3).
assert(HACApm : rk(A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HACApeq HACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: nil) ((Oo :: A :: C :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Ap :: nil) (nil) 2 1 0 HOoACMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCAp *)
(* dans la couche 0 *)
Lemma LBCApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: C :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMQ requis par la preuve de (?)BCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMQ requis par la preuve de (?)BCApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMQ requis par la preuve de (?)BCApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCApMQm2 : rk(B :: C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: nil) ++ (B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: nil) (nil) 4 0 2 HOoABCApMQmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApMQm3 : rk(B :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: nil) (B :: nil) 4 1 2 HOoABCApMQmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBCApMQm4 : rk(B :: C :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMQeq : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoBCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMQmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBCApMQeq HOoBCApMQm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (Oo :: B :: C :: nil) (B :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: C :: B :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: C :: Ap :: M :: Q :: nil) ((Oo :: B :: C :: nil) ++ (B :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQmtmp;try rewrite HT2 in HOoBCApMQmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: C :: Ap :: M :: Q :: nil) (B :: C :: nil) 4 2 2 HOoBCApMQmtmp HBCmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBCApMQM : rk(B :: C :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApMQm : rk(B :: C :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HBCApMQeq HBCApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApm2 : rk(B :: C :: Ap :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCApm3 : rk(B :: C :: Ap :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBCApMQeq : rk(B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LBCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCApMQmtmp : rk(B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HBCApMQeq HBCApMQm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Q :: nil) (B :: C :: Ap :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: Ap :: M :: Q :: nil) ((B :: C :: Ap :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMQmtmp;try rewrite HT2 in HBCApMQmtmp.
	assert(HT := rule_2 (B :: C :: Ap :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 4 1 2 HBCApMQmtmp HApmtmp HApMQMtmp Hincl);apply HT.
}


assert(HBCApM : rk(B :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCApeq HBCApM3).
assert(HBCApm : rk(B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HBCApeq HBCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCAp *)
(* dans la couche 0 *)
Lemma LOoABCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABCAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: nil) ((Oo :: A :: B :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Ap :: nil) (nil) 2 1 0 HOoABMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApm2 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABCApM3 : rk(Oo :: A :: B :: C :: Ap :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: C :: Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Ap :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: nil) (Oo :: A :: nil) 2 3 2 HOoACMtmp HOoABApMtmp HOoAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApm3 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApM : rk(Oo :: A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApm : rk(Oo :: A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABCApeq HOoABCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCAp requis par la preuve de (?)OoBCAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCAp requis par la preuve de (?)OoBCAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCAp requis par la preuve de (?)OoBCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApm2 : rk(Oo :: B :: C :: Ap :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBCApM3 : rk(Oo :: B :: C :: Ap :: nil) <= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: C :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: nil) (Oo :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: nil) ((Oo :: B :: C :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: nil) (Ap :: nil) (nil) 2 1 0 HOoBCMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  3 et 3 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApm3 : rk(Oo :: B :: C :: Ap :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 3) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoABCApeq HOoABCApm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoBCApM : rk(Oo :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApm : rk(Oo :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBCApeq HOoBCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Bp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HBpM : rk(Bp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBpeq HBpM1).
assert(HBpm : rk(Bp ::  nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoBpM : rk(Oo :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBpeq HOoBpM2).
assert(HOoBpm : rk(Oo :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBpeq HOoBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoAApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoAApBpCpM3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HAMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpCpM : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpm : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoApBpCpM : rk(Oo :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpCpm : rk(Oo :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoAApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpm2 : rk(Oo :: A :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpm3 : rk(Oo :: A :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoAApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABpM : rk(Oo :: A :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABpeq HOoABpM3).
assert(HOoABpm : rk(Oo :: A :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABpeq HOoABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBp *)
(* dans constructLemma(), requis par LOoBApBpCp *)
(* dans la couche 0 *)
Lemma LOoABApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABApBpCpM3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoABMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpCpM : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpCpm : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBApBpCpM3 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HBMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpCpm2 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpCpm3 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpCpmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoBApBpCpM : rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpCpm : rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)BBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpm2 : rk(B :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoBApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HBBpM : rk(B :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBBpeq HBBpM2).
assert(HBBpm : rk(B :: Bp ::  nil) >= 1) by (solve_hyps_min HBBpeq HBBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABBp *)
(* dans constructLemma(), requis par LABBpNP *)
(* dans constructLemma(), requis par LABCBpNP *)
(* dans la couche 0 *)
Lemma LOoABCBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoABCBpNPM : rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNPm : rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: C :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCBpNP requis par la preuve de (?)ABCBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpNP requis par la preuve de (?)ABCBpNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCBpNPm3 : rk(A :: B :: C :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: A :: A :: B :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Bp :: N :: P :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Bp :: N :: P :: nil) (A :: nil) 4 1 2 HOoABCBpNPmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCBpNPm4 : rk(A :: B :: C :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: A :: B :: A :: B :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Bp :: N :: P :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Bp :: N :: P :: nil) (A :: B :: nil) 4 2 2 HOoABCBpNPmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCBpNPM : rk(A :: B :: C :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpNPm : rk(A :: B :: C :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HABCBpNPeq HABCBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpNP requis par la preuve de (?)ABBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpNP requis par la preuve de (?)ABBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpNP requis par la preuve de (?)ABBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpNPm2 : rk(A :: B :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Bp :: N :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABBpNPm3 : rk(A :: B :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCBpNPeq : rk(A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCBpNPmtmp : rk(A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HABCBpNPeq HABCBpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: N :: P :: nil) (C :: A :: B :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Bp :: N :: P :: nil) ((C :: nil) ++ (A :: B :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpNPmtmp;try rewrite HT2 in HABCBpNPmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Bp :: N :: P :: nil) (nil) 4 0 1 HABCBpNPmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABBpNPm4 : rk(A :: B :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCBpNPeq : rk(A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCBpNPmtmp : rk(A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HABCBpNPeq HABCBpNPm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: N :: P :: nil) (A :: B :: C :: A :: B :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Bp :: N :: P :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpNPmtmp;try rewrite HT2 in HABCBpNPmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Bp :: N :: P :: nil) (A :: B :: nil) 4 2 2 HABCBpNPmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABBpNPM : rk(A :: B :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpNPm : rk(A :: B :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HABBpNPeq HABBpNPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABBp *)
(* dans la couche 0 *)
Lemma LBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Bp :: N :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HBpNPM : rk(Bp :: N :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpNPeq HBpNPM3).
assert(HBpNPm : rk(Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HBpNPeq HBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Bp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABBpm3 : rk(A :: B :: Bp :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HABBpNPeq : rk(A :: B :: Bp :: N :: P :: nil) = 4) by (apply LABBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABBpNPmtmp : rk(A :: B :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HABBpNPeq HABBpNPm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: B :: Bp :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: N :: P :: nil) (A :: B :: Bp :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: Bp :: N :: P :: nil) ((A :: B :: Bp :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpNPmtmp;try rewrite HT2 in HABBpNPmtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (Bp :: N :: P :: nil) (Bp :: nil) 4 1 2 HABBpNPmtmp HBpmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HABBpM : rk(A :: B :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABBpeq HABBpM3).
assert(HABBpm : rk(A :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HABBpeq HABBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: nil) ((Oo :: A :: B :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Bp :: nil) (nil) 2 1 0 HOoABMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpm3 : rk(Oo :: A :: B :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABBpM : rk(Oo :: A :: B :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpm : rk(Oo :: A :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABBpeq HOoABBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBp *)
(* dans constructLemma(), requis par LOoCApBpCp *)
(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACApBpCpM3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoACMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoCApBpCpM3 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HCMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpCpm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpCpmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


assert(HOoCApBpCpM : rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpm : rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBp requis par la preuve de (?)CBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpm2 : rk(C :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoCApBpCpeq : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApBpCpmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpmtmp;try rewrite HT2 in HOoCApBpCpmtmp.
	assert(HT := rule_2 (C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoCApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HCBpM : rk(C :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCBpeq HCBpM2).
assert(HCBpm : rk(C :: Bp ::  nil) >= 1) by (solve_hyps_min HCBpeq HCBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACBp *)
(* dans constructLemma(), requis par LACBpNP *)
(* dans la couche 0 *)
Lemma LOoACBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNP requis par la preuve de (?)OoACBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNP requis par la preuve de (?)OoACBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNP requis par la preuve de (?)OoACBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNPm2 : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACBpNPm3 : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (B :: Oo :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Bp :: N :: P :: nil) ((B :: nil) ++ (Oo :: A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Bp :: N :: P :: nil) (nil) 4 0 1 HOoABCBpNPmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACBpNPm4 : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: A :: B :: Oo :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Bp :: N :: P :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Bp :: N :: P :: nil) (Oo :: A :: nil) 4 2 2 HOoABCBpNPmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACBpNPM : rk(Oo :: A :: C :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpNPm : rk(Oo :: A :: C :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoACBpNPeq HOoACBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpNP requis par la preuve de (?)ACBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpNP requis par la preuve de (?)ACBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpNP requis par la preuve de (?)ACBpNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACBpNPm2 : rk(A :: C :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: B :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Bp :: N :: P :: nil) ((Oo :: B :: nil) ++ (A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Bp :: N :: P :: nil) (nil) 4 0 2 HOoABCBpNPmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACBpNPm3 : rk(A :: C :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: A :: B :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Bp :: N :: P :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: P :: nil) (A :: nil) 4 1 2 HOoABCBpNPmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACBpNPm4 : rk(A :: C :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPeq : rk(Oo :: A :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoACBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpNPmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoACBpNPeq HOoACBpNPm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: nil) (Oo :: A :: C :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Bp :: N :: P :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPmtmp;try rewrite HT2 in HOoACBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Bp :: N :: P :: nil) (A :: C :: nil) 4 2 2 HOoACBpNPmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACBpNPM : rk(A :: C :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpNPm : rk(A :: C :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HACBpNPeq HACBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACBpm3 : rk(A :: C :: Bp :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HACBpNPeq : rk(A :: C :: Bp :: N :: P :: nil) = 4) by (apply LACBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACBpNPmtmp : rk(A :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HACBpNPeq HACBpNPm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: C :: Bp :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: N :: P :: nil) (A :: C :: Bp :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: Bp :: N :: P :: nil) ((A :: C :: Bp :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpNPmtmp;try rewrite HT2 in HACBpNPmtmp.
	assert(HT := rule_2 (A :: C :: Bp :: nil) (Bp :: N :: P :: nil) (Bp :: nil) 4 1 2 HACBpNPmtmp HBpmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HACBpM : rk(A :: C :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACBpeq HACBpM3).
assert(HACBpm : rk(A :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HACBpeq HACBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpm2 : rk(Oo :: A :: C :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACBpM3 : rk(Oo :: A :: C :: Bp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: nil) (Oo :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: nil) ((Oo :: A :: C :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Bp :: nil) (nil) 2 1 0 HOoACMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACBpm3 : rk(Oo :: A :: C :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoACApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACBpM : rk(Oo :: A :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpm : rk(Oo :: A :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoACBpeq HOoACBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpm2 : rk(Oo :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpM2 : rk(Oo :: Ap :: Bp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpM : rk(Oo :: Ap :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApBpeq HOoApBpM3).
assert(HOoApBpm : rk(Oo :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoApBpeq HOoApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoCpM : rk(Oo :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCpeq HOoCpM2).
assert(HOoCpm : rk(Oo :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCpeq HOoCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpm2 : rk(Oo :: A :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpm3 : rk(Oo :: A :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoAApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}
try clear HOoCpM1. try clear HOoCpM2. try clear HOoCpM3. try clear HOoCpm4. try clear HOoCpm3. try clear HOoCpm2. try clear HOoCpm1. 

assert(HOoACpM : rk(Oo :: A :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACpeq HOoACpM3).
assert(HOoACpm : rk(Oo :: A :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACpeq HOoACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpm2 : rk(Oo :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpM2 : rk(Oo :: Ap :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpM : rk(Oo :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApCpeq HOoApCpM3).
assert(HOoApCpm : rk(Oo :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApCpeq HOoApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCp requis par la preuve de (?)OoBpCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpCp requis par la preuve de (?)OoBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpm2 : rk(Oo :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpM2 : rk(Oo :: Bp :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoBpCpM : rk(Oo :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpCpeq HOoBpCpM3).
assert(HOoBpCpm : rk(Oo :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBpCpeq HOoBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpCp requis par la preuve de (?)ApBpCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpCp requis par la preuve de (?)ApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpm2 : rk(Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpM2 : rk(Ap :: Bp :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HApBpCpM : rk(Ap :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpCpeq HApBpCpM3).
assert(HApBpCpm : rk(Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HApBpCpeq HApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(X ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HXM : rk(X ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HXeq HXM1).
assert(HXm : rk(X ::  nil) >= 1) by (solve_hyps_min HXeq HXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAX *)
(* dans constructLemma(), requis par LABApX *)
(* dans la couche 0 *)
Lemma LOoABApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApX requis par la preuve de (?)OoABApX pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BApX requis par la preuve de (?)OoABApX pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApX requis par la preuve de (?)OoABApX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApX requis par la preuve de (?)OoABApX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXm2 : rk(Oo :: A :: B :: Ap :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABApXM3 : rk(Oo :: A :: B :: Ap :: X :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: nil) (Oo :: A :: B :: B :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: Ap :: X :: nil) ((Oo :: A :: B :: nil) ++ (B :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: Ap :: X :: nil) (B :: nil) 2 2 1 HOoABMtmp HBApXMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXm3 : rk(Oo :: A :: B :: Ap :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApXM : rk(Oo :: A :: B :: Ap :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApXm : rk(Oo :: A :: B :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HOoABApXeq HOoABApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Ap :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABApX requis par la preuve de (?)ABApX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABApX requis par la preuve de (?)ABApX pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BApX requis par la preuve de (?)ABApX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApX requis par la preuve de (?)ABApX pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABApXM3 : rk(A :: B :: Ap :: X :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: X :: nil) (A :: B :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: X :: nil) ((A :: nil) ++ (B :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: Ap :: X :: nil) (nil) 1 2 0 HAMtmp HBApXMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApXm2 : rk(A :: B :: Ap :: X :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: X :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X ::  de rang :  3 et 3 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApXm3 : rk(A :: B :: Ap :: X :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApXeq : rk(Oo :: A :: B :: Ap :: X :: nil) = 3) by (apply LOoABApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApXmtmp : rk(Oo :: A :: B :: Ap :: X :: nil) >= 3) by (solve_hyps_min HOoABApXeq HOoABApXm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: X :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXmtmp;try rewrite HT2 in HOoABApXmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: X :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApXmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABApXM : rk(A :: B :: Ap :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApXm : rk(A :: B :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HABApXeq HABApXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAX *)
(* dans la couche 0 *)
Lemma LBApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Ap :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HBApXM : rk(B :: Ap :: X ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApXeq HBApXM3).
assert(HBApXm : rk(B :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HBApXeq HBApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AX requis par la preuve de (?)AX pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAXm2 : rk(A :: X :: nil) >= 2).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HABApXeq : rk(A :: B :: Ap :: X :: nil) = 3) by (apply LABApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApXmtmp : rk(A :: B :: Ap :: X :: nil) >= 3) by (solve_hyps_min HABApXeq HABApXm3).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXmtmp : rk(X :: nil) >= 1) by (solve_hyps_min HXeq HXm1).
	assert(Hincl : incl (X :: nil) (list_inter (A :: X :: nil) (B :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: X :: nil) (A :: X :: B :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: X :: B :: Ap :: X :: nil) ((A :: X :: nil) ++ (B :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApXmtmp;try rewrite HT2 in HABApXmtmp.
	assert(HT := rule_2 (A :: X :: nil) (B :: Ap :: X :: nil) (X :: nil) 3 1 2 HABApXmtmp HXmtmp HBApXMtmp Hincl);apply HT.
}


assert(HAXM : rk(A :: X ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAXeq HAXM2).
assert(HAXm : rk(A :: X ::  nil) >= 1) by (solve_hyps_min HAXeq HAXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAX *)
(* dans la couche 0 *)
Lemma LOoABpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABpX requis par la preuve de (?)OoABpX pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABpX requis par la preuve de (?)OoABpX pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ABpX requis par la preuve de (?)OoABpX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpX requis par la preuve de (?)OoABpX pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoABpXM3 : rk(Oo :: A :: Bp :: X :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: X :: nil) (Oo :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: X :: nil) ((Oo :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: Bp :: X :: nil) (nil) 1 2 0 HOoMtmp HABpXMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpXm2 : rk(Oo :: A :: Bp :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpXm3 : rk(Oo :: A :: Bp :: X :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: X :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpXM : rk(Oo :: A :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpXm : rk(Oo :: A :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HOoABpXeq HOoABpXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAX *)
(* dans la couche 0 *)
Lemma LABpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Bp :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HABpXM : rk(A :: Bp :: X ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABpXeq HABpXM3).
assert(HABpXm : rk(A :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HABpXeq HABpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAX requis par la preuve de (?)OoAX pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAX requis par la preuve de (?)OoAX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXm2 : rk(Oo :: A :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAXm3 : rk(Oo :: A :: X :: nil) >= 3).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HOoABpXeq : rk(Oo :: A :: Bp :: X :: nil) = 3) by (apply LOoABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpXmtmp : rk(Oo :: A :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoABpXeq HOoABpXm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: X :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: X :: nil) (Oo :: A :: X :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: X :: A :: Bp :: X :: nil) ((Oo :: A :: X :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpXmtmp;try rewrite HT2 in HOoABpXmtmp.
	assert(HT := rule_2 (Oo :: A :: X :: nil) (A :: Bp :: X :: nil) (A :: X :: nil) 3 2 2 HOoABpXmtmp HAXmtmp HABpXMtmp Hincl);apply HT.
}


assert(HOoAXM : rk(Oo :: A :: X ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAXeq HOoAXM3).
assert(HOoAXm : rk(Oo :: A :: X ::  nil) >= 1) by (solve_hyps_min HOoAXeq HOoAXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBX *)
(* dans constructLemma(), requis par LABBpX *)
(* dans la couche 0 *)
Lemma LOoABBpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBpX requis par la preuve de (?)OoABBpX pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpX requis par la preuve de (?)OoABBpX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpX requis par la preuve de (?)OoABBpX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXm2 : rk(Oo :: A :: B :: Bp :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABBpXM3 : rk(Oo :: A :: B :: Bp :: X :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: X :: nil) (Oo :: A :: B :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: Bp :: X :: nil) ((Oo :: A :: B :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (A :: Bp :: X :: nil) (A :: nil) 2 2 1 HOoABMtmp HABpXMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXm3 : rk(Oo :: A :: B :: Bp :: X :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: X :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpXM : rk(Oo :: A :: B :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpXm : rk(Oo :: A :: B :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HOoABBpXeq HOoABBpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBpX requis par la preuve de (?)ABBpX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBpX requis par la preuve de (?)ABBpX pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpX requis par la preuve de (?)ABBpX pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABBpXM3 : rk(A :: B :: Bp :: X :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: X :: nil) (B :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: Bp :: X :: nil) ((B :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: Bp :: X :: nil) (nil) 1 2 0 HBMtmp HABpXMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpXm2 : rk(A :: B :: Bp :: X :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Bp :: X :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: X ::  de rang :  3 et 3 	 AiB : A :: B :: Bp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABBpXm3 : rk(A :: B :: Bp :: X :: nil) >= 3).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	try assert(HOoABBpXeq : rk(Oo :: A :: B :: Bp :: X :: nil) = 3) by (apply LOoABBpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABBpXmtmp : rk(Oo :: A :: B :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoABBpXeq HOoABBpXm3).
	try assert(HABBpeq : rk(A :: B :: Bp :: nil) = 3) by (apply LABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: B :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: X :: nil) (Oo :: A :: B :: Bp :: A :: B :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: B :: Bp :: X :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: B :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpXmtmp;try rewrite HT2 in HOoABBpXmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: B :: Bp :: X :: nil) (A :: B :: Bp :: nil) 3 3 3 HOoABBpXmtmp HABBpmtmp HOoABBpMtmp Hincl); apply HT.
}


assert(HABBpXM : rk(A :: B :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpXm : rk(A :: B :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HABBpXeq HABBpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BX requis par la preuve de (?)BX pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBXm2 : rk(B :: X :: nil) >= 2).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HABBpXeq : rk(A :: B :: Bp :: X :: nil) = 3) by (apply LABBpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABBpXmtmp : rk(A :: B :: Bp :: X :: nil) >= 3) by (solve_hyps_min HABBpXeq HABBpXm3).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXmtmp : rk(X :: nil) >= 1) by (solve_hyps_min HXeq HXm1).
	assert(Hincl : incl (X :: nil) (list_inter (B :: X :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: X :: nil) (B :: X :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: X :: A :: Bp :: X :: nil) ((B :: X :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpXmtmp;try rewrite HT2 in HABBpXmtmp.
	assert(HT := rule_2 (B :: X :: nil) (A :: Bp :: X :: nil) (X :: nil) 3 1 2 HABBpXmtmp HXmtmp HABpXMtmp Hincl);apply HT.
}


assert(HBXM : rk(B :: X ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBXeq HBXM2).
assert(HBXm : rk(B :: X ::  nil) >= 1) by (solve_hyps_min HBXeq HBXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABX requis par la preuve de (?)OoABX pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABX requis par la preuve de (?)OoABX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABX requis par la preuve de (?)OoABX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXm2 : rk(Oo :: A :: B :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABXM3 : rk(Oo :: A :: B :: X :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXMtmp : rk(X :: nil) <= 1) by (solve_hyps_max HXeq HXM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: nil) (Oo :: A :: B :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: nil) ((Oo :: A :: B :: nil) ++ (X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (X :: nil) (nil) 2 1 0 HOoABMtmp HXMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABXm3 : rk(Oo :: A :: B :: X :: nil) >= 3).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HOoABApXeq : rk(Oo :: A :: B :: Ap :: X :: nil) = 3) by (apply LOoABApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApXmtmp : rk(Oo :: A :: B :: Ap :: X :: nil) >= 3) by (solve_hyps_min HOoABApXeq HOoABApXm3).
	try assert(HBXeq : rk(B :: X :: nil) = 2) by (apply LBX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBXmtmp : rk(B :: X :: nil) >= 2) by (solve_hyps_min HBXeq HBXm2).
	assert(Hincl : incl (B :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (B :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: nil) (Oo :: A :: B :: X :: B :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: B :: Ap :: X :: nil) ((Oo :: A :: B :: X :: nil) ++ (B :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXmtmp;try rewrite HT2 in HOoABApXmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: X :: nil) (B :: Ap :: X :: nil) (B :: X :: nil) 3 2 2 HOoABApXmtmp HBXmtmp HBApXMtmp Hincl);apply HT.
}


assert(HOoABXM : rk(Oo :: A :: B :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABXm : rk(Oo :: A :: B :: X ::  nil) >= 1) by (solve_hyps_min HOoABXeq HOoABXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApX *)
(* dans constructLemma(), requis par LAApBpX *)
(* dans la couche 0 *)
Lemma LOoAApBpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXm2 : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXm3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoAApBpXM3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Ap :: Bp :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Bp :: X :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: nil) (Bp :: nil) 2 2 1 HOoApBpMtmp HABpXMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoAApBpXM : rk(Oo :: A :: Ap :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpXm : rk(Oo :: A :: Ap :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Ap :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBpX requis par la preuve de (?)AApBpX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBpX requis par la preuve de (?)AApBpX pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpX requis par la preuve de (?)AApBpX pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApBpXM3 : rk(A :: Ap :: Bp :: X :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: X :: nil) (Ap :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: Bp :: X :: nil) ((Ap :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: Bp :: X :: nil) (nil) 1 2 0 HApMtmp HABpXMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpXm2 : rk(A :: Ap :: Bp :: X :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: X :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X ::  de rang :  3 et 3 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpXm3 : rk(A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpXeq : rk(Oo :: A :: Ap :: Bp :: X :: nil) = 3) by (apply LOoAApBpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpXmtmp : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: X :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXmtmp;try rewrite HT2 in HOoAApBpXmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: X :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpXmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HAApBpXM : rk(A :: Ap :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpXm : rk(A :: Ap :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HAApBpXeq HAApBpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApX requis par la preuve de (?)ApX pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApXm2 : rk(Ap :: X :: nil) >= 2).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HAApBpXeq : rk(A :: Ap :: Bp :: X :: nil) = 3) by (apply LAApBpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApBpXmtmp : rk(A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HAApBpXeq HAApBpXm3).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXmtmp : rk(X :: nil) >= 1) by (solve_hyps_min HXeq HXm1).
	assert(Hincl : incl (X :: nil) (list_inter (Ap :: X :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: X :: nil) (Ap :: X :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: X :: A :: Bp :: X :: nil) ((Ap :: X :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpXmtmp;try rewrite HT2 in HAApBpXmtmp.
	assert(HT := rule_2 (Ap :: X :: nil) (A :: Bp :: X :: nil) (X :: nil) 3 1 2 HAApBpXmtmp HXmtmp HABpXMtmp Hincl);apply HT.
}


assert(HApXM : rk(Ap :: X ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApXeq HApXM2).
assert(HApXm : rk(Ap :: X ::  nil) >= 1) by (solve_hyps_min HApXeq HApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApX requis par la preuve de (?)OoAApX pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApX requis par la preuve de (?)OoAApX pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApX requis par la preuve de (?)OoAApX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXm2 : rk(Oo :: A :: Ap :: X :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: X :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXm3 : rk(Oo :: A :: Ap :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXM3 : rk(Oo :: A :: Ap :: X :: nil) <= 3).
{
	try assert(HOoABApXeq : rk(Oo :: A :: B :: Ap :: X :: nil) = 3) by (apply LOoABApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApXMtmp : rk(Oo :: A :: B :: Ap :: X :: nil) <= 3) by (solve_hyps_max HOoABApXeq HOoABApXM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: X :: nil) (Oo :: A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: Ap :: X :: nil) (Oo :: A :: B :: Ap :: X :: nil) 3 3 HOoABApXMtmp Hcomp Hincl);apply HT.
}


assert(HOoAApXM : rk(Oo :: A :: Ap :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApXm : rk(Oo :: A :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HOoAApXeq HOoAApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Y ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HYM : rk(Y ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HYeq HYM1).
assert(HYm : rk(Y ::  nil) >= 1) by (solve_hyps_min HYeq HYm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAY *)
(* dans constructLemma(), requis par LACApY *)
(* dans la couche 0 *)
Lemma LOoACApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Ap :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApY requis par la preuve de (?)OoACApY pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CApY requis par la preuve de (?)OoACApY pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApY requis par la preuve de (?)OoACApY pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApY requis par la preuve de (?)OoACApY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYm2 : rk(Oo :: A :: C :: Ap :: Y :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoACApYM3 : rk(Oo :: A :: C :: Ap :: Y :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Ap :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: nil) (Oo :: A :: C :: C :: Ap :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Ap :: Y :: nil) ((Oo :: A :: C :: nil) ++ (C :: Ap :: Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (C :: Ap :: Y :: nil) (C :: nil) 2 2 1 HOoACMtmp HCApYMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYm3 : rk(Oo :: A :: C :: Ap :: Y :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApYM : rk(Oo :: A :: C :: Ap :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApYm : rk(Oo :: A :: C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HOoACApYeq HOoACApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Ap :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApY requis par la preuve de (?)ACApY pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApY requis par la preuve de (?)ACApY pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CApY requis par la preuve de (?)ACApY pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApY requis par la preuve de (?)ACApY pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HACApYM3 : rk(A :: C :: Ap :: Y :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (C :: Ap :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Y :: nil) (A :: C :: Ap :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Y :: nil) ((A :: nil) ++ (C :: Ap :: Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (C :: Ap :: Y :: nil) (nil) 1 2 0 HAMtmp HCApYMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApYm2 : rk(A :: C :: Ap :: Y :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Ap :: Y :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Y ::  de rang :  3 et 3 	 AiB : A :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HACApYm3 : rk(A :: C :: Ap :: Y :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoACApYeq : rk(Oo :: A :: C :: Ap :: Y :: nil) = 3) by (apply LOoACApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApYmtmp : rk(Oo :: A :: C :: Ap :: Y :: nil) >= 3) by (solve_hyps_min HOoACApYeq HOoACApYm3).
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (A :: C :: Ap :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: nil) (Oo :: A :: C :: Ap :: A :: C :: Ap :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: A :: C :: Ap :: Y :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (A :: C :: Ap :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApYmtmp;try rewrite HT2 in HOoACApYmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (A :: C :: Ap :: Y :: nil) (A :: C :: Ap :: nil) 3 3 3 HOoACApYmtmp HACApmtmp HOoACApMtmp Hincl); apply HT.
}


assert(HACApYM : rk(A :: C :: Ap :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApYm : rk(A :: C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HACApYeq HACApYm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAY *)
(* dans la couche 0 *)
Lemma LCApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HCApYM : rk(C :: Ap :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApYeq HCApYM3).
assert(HCApYm : rk(C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HCApYeq HCApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AY requis par la preuve de (?)AY pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAYm2 : rk(A :: Y :: nil) >= 2).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	try assert(HACApYeq : rk(A :: C :: Ap :: Y :: nil) = 3) by (apply LACApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACApYmtmp : rk(A :: C :: Ap :: Y :: nil) >= 3) by (solve_hyps_min HACApYeq HACApYm3).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (A :: Y :: nil) (C :: Ap :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Y :: nil) (A :: Y :: C :: Ap :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Y :: C :: Ap :: Y :: nil) ((A :: Y :: nil) ++ (C :: Ap :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApYmtmp;try rewrite HT2 in HACApYmtmp.
	assert(HT := rule_2 (A :: Y :: nil) (C :: Ap :: Y :: nil) (Y :: nil) 3 1 2 HACApYmtmp HYmtmp HCApYMtmp Hincl);apply HT.
}


assert(HAYM : rk(A :: Y ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAYeq HAYM2).
assert(HAYm : rk(A :: Y ::  nil) >= 1) by (solve_hyps_min HAYeq HAYm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCY *)
(* dans constructLemma(), requis par LOoACY *)
(* dans la couche 0 *)
Lemma LOoACCpY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Cp :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACCpY requis par la preuve de (?)OoACCpY pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ACpY requis par la preuve de (?)OoACCpY pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpY requis par la preuve de (?)OoACCpY pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpY requis par la preuve de (?)OoACCpY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpYm2 : rk(Oo :: A :: C :: Cp :: Y :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Y :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoACCpYM3 : rk(Oo :: A :: C :: Cp :: Y :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Y :: nil) (Oo :: A :: C :: A :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Cp :: Y :: nil) ((Oo :: A :: C :: nil) ++ (A :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (A :: Cp :: Y :: nil) (A :: nil) 2 2 1 HOoACMtmp HACpYMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpYm3 : rk(Oo :: A :: C :: Cp :: Y :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Y :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


assert(HOoACCpYM : rk(Oo :: A :: C :: Cp :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpYm : rk(Oo :: A :: C :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HOoACCpYeq HOoACCpYm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACY *)
(* dans la couche 0 *)
Lemma LACpY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Cp :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HACpYM : rk(A :: Cp :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpYeq HACpYM3).
assert(HACpYm : rk(A :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HACpYeq HACpYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACY requis par la preuve de (?)OoACY pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACY requis par la preuve de (?)OoACY pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACY requis par la preuve de (?)OoACY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACYm2 : rk(Oo :: A :: C :: Y :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Y :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACYM3 : rk(Oo :: A :: C :: Y :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HYMtmp : rk(Y :: nil) <= 1) by (solve_hyps_max HYeq HYM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Y :: nil) (Oo :: A :: C :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Y :: nil) ((Oo :: A :: C :: nil) ++ (Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Y :: nil) (nil) 2 1 0 HOoACMtmp HYMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACYm3 : rk(Oo :: A :: C :: Y :: nil) >= 3).
{
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	try assert(HOoACCpYeq : rk(Oo :: A :: C :: Cp :: Y :: nil) = 3) by (apply LOoACCpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACCpYmtmp : rk(Oo :: A :: C :: Cp :: Y :: nil) >= 3) by (solve_hyps_min HOoACCpYeq HOoACCpYm3).
	try assert(HAYeq : rk(A :: Y :: nil) = 2) by (apply LAY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAYmtmp : rk(A :: Y :: nil) >= 2) by (solve_hyps_min HAYeq HAYm2).
	assert(Hincl : incl (A :: Y :: nil) (list_inter (Oo :: A :: C :: Y :: nil) (A :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Y :: nil) (Oo :: A :: C :: Y :: A :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Y :: A :: Cp :: Y :: nil) ((Oo :: A :: C :: Y :: nil) ++ (A :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpYmtmp;try rewrite HT2 in HOoACCpYmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Y :: nil) (A :: Cp :: Y :: nil) (A :: Y :: nil) 3 2 2 HOoACCpYmtmp HAYmtmp HACpYMtmp Hincl);apply HT.
}
try clear HAYM1. try clear HAYM2. try clear HAYM3. try clear HAYm4. try clear HAYm3. try clear HAYm2. try clear HAYm1. 

assert(HOoACYM : rk(Oo :: A :: C :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACYm : rk(Oo :: A :: C :: Y ::  nil) >= 1) by (solve_hyps_min HOoACYeq HOoACYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CY requis par la preuve de (?)CY pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Y ::  de rang :  3 et 3 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HCYm2 : rk(C :: Y :: nil) >= 2).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACYeq : rk(Oo :: A :: C :: Y :: nil) = 3) by (apply LOoACY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACYmtmp : rk(Oo :: A :: C :: Y :: nil) >= 3) by (solve_hyps_min HOoACYeq HOoACYm3).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Y :: nil) (Oo :: A :: C :: C :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Y :: nil) ((Oo :: A :: C :: nil) ++ (C :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACYmtmp;try rewrite HT2 in HOoACYmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (C :: Y :: nil) (C :: nil) 3 1 2 HOoACYmtmp HCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HCYM : rk(C :: Y ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCYeq HCYM2).
assert(HCYm : rk(C :: Y ::  nil) >= 1) by (solve_hyps_min HCYeq HCYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApY requis par la preuve de (?)OoAApY pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApY requis par la preuve de (?)OoAApY pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApY requis par la preuve de (?)OoAApY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYm2 : rk(Oo :: A :: Ap :: Y :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Y :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYm3 : rk(Oo :: A :: Ap :: Y :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYM3 : rk(Oo :: A :: Ap :: Y :: nil) <= 3).
{
	try assert(HOoACApYeq : rk(Oo :: A :: C :: Ap :: Y :: nil) = 3) by (apply LOoACApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApYMtmp : rk(Oo :: A :: C :: Ap :: Y :: nil) <= 3) by (solve_hyps_max HOoACApYeq HOoACApYM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: Y :: nil) (Oo :: A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: Ap :: Y :: nil) (Oo :: A :: C :: Ap :: Y :: nil) 3 3 HOoACApYMtmp Hcomp Hincl);apply HT.
}


assert(HOoAApYM : rk(Oo :: A :: Ap :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApYm : rk(Oo :: A :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HOoAApYeq HOoAApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LZ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Z ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HZM : rk(Z ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HZeq HZM1).
assert(HZm : rk(Z ::  nil) >= 1) by (solve_hyps_min HZeq HZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Bp :: Z ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HCBpZM : rk(C :: Bp :: Z ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpZeq HCBpZM3).
assert(HCBpZm : rk(C :: Bp :: Z ::  nil) >= 1) by (solve_hyps_min HCBpZeq HCBpZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LXYZ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(X :: Y :: Z ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HXYZM : rk(X :: Y :: Z ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HXYZeq HXYZM3).
assert(HXYZm : rk(X :: Y :: Z ::  nil) >= 1) by (solve_hyps_min HXYZeq HXYZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(M ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HMM : rk(M ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HMeq HMM1).
assert(HMm : rk(M ::  nil) >= 1) by (solve_hyps_min HMeq HMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAM *)
(* dans la couche 0 *)
Lemma LAApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Ap :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApMQ requis par la preuve de (?)AApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApMQ requis par la preuve de (?)AApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApMQ requis par la preuve de (?)ACApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApMQ requis par la preuve de (?)ACApMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACApMQm2 : rk(A :: C :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: B :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Ap :: M :: Q :: nil) ((Oo :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: nil) (nil) 4 0 2 HOoABCApMQmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApMQm3 : rk(A :: C :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: nil) (A :: nil) 4 1 2 HOoABCApMQmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApMQ requis par la preuve de (?)AApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMQ requis par la preuve de (?)AApMQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApMQM3 : rk(A :: Ap :: M :: Q :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: nil) (A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: M :: Q :: nil) ((A :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: M :: Q :: nil) (nil) 1 2 0 HAMtmp HApMQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: M :: Q ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HAApMQm2 : rk(A :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACApMQmtmp : rk(A :: C :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HACApMQeq HACApMQm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Q :: nil) (C :: A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Ap :: M :: Q :: nil) ((C :: nil) ++ (A :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMQmtmp;try rewrite HT2 in HACApMQmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Ap :: M :: Q :: nil) (nil) 3 0 1 HACApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HAApMQm3 : rk(A :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (A :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Ap :: M :: Q :: nil) (A :: nil) 4 1 2 HOoACApMQmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HAApMQM : rk(A :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMQm : rk(A :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HAApMQeq HAApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AM requis par la preuve de (?)AM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAMm2 : rk(A :: M :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HAApMQeq : rk(A :: Ap :: M :: Q :: nil) = 3) by (apply LAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApMQmtmp : rk(A :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HAApMQeq HAApMQm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: nil) (A :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: Ap :: M :: Q :: nil) ((A :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMQmtmp;try rewrite HT2 in HAApMQmtmp.
	assert(HT := rule_2 (A :: M :: nil) (Ap :: M :: Q :: nil) (M :: nil) 3 1 2 HAApMQmtmp HMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HAMM : rk(A :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAMeq HAMM2).
assert(HAMm : rk(A :: M ::  nil) >= 1) by (solve_hyps_min HAMeq HAMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAM *)
(* dans constructLemma(), requis par LOoAMP *)
(* dans constructLemma(), requis par LOoAApCpMP *)
(* dans la couche 0 *)
Lemma LOoAApBpCpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoAApBpCpMPM : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpMPm : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Cp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpMP requis par la preuve de (?)OoAApCpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpMP requis par la preuve de (?)OoAApCpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpMP requis par la preuve de (?)OoAApCpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMPm2 : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMPm3 : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoAApCpMPm4 : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpMPmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Ap :: Cp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPmtmp;try rewrite HT2 in HOoAApBpCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: nil) (Oo :: Ap :: nil) 4 2 2 HOoAApBpCpMPmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoAApCpMPM : rk(Oo :: A :: Ap :: Cp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpMPm : rk(Oo :: A :: Ap :: Cp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoAApCpMPeq HOoAApCpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAMP requis par la preuve de (?)OoAMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAMP requis par la preuve de (?)OoAMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour AMP requis par la preuve de (?)OoAMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAMP requis par la preuve de (?)OoAMP pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoAMPM3 : rk(Oo :: A :: M :: P :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: M :: P :: nil) (Oo :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: M :: P :: nil) ((Oo :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: M :: P :: nil) (nil) 1 2 0 HOoMtmp HAMPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAMPm2 : rk(Oo :: A :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoAMPm3 : rk(Oo :: A :: M :: P :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) = 4) by (apply LOoAApCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApCpMPmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApCpMPeq HOoAApCpMPm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: nil) (Oo :: Ap :: Cp :: Oo :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: M :: P :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPmtmp;try rewrite HT2 in HOoAApCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: M :: P :: nil) (Oo :: nil) 4 1 2 HOoAApCpMPmtmp HOomtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoAMPM : rk(Oo :: A :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAMPm : rk(Oo :: A :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoAMPeq HOoAMPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAM *)
(* dans la couche 0 *)
Lemma LAMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: M :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HAMPM : rk(A :: M :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAMPeq HAMPM3).
assert(HAMPm : rk(A :: M :: P ::  nil) >= 1) by (solve_hyps_min HAMPeq HAMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAM requis par la preuve de (?)OoAM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAM requis par la preuve de (?)OoAM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAMm2 : rk(Oo :: A :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAMm3 : rk(Oo :: A :: M :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoAMPeq : rk(Oo :: A :: M :: P :: nil) = 3) by (apply LOoAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMPmtmp : rk(Oo :: A :: M :: P :: nil) >= 3) by (solve_hyps_min HOoAMPeq HOoAMPm3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: M :: P :: nil) (Oo :: A :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: M :: A :: M :: P :: nil) ((Oo :: A :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAMPmtmp;try rewrite HT2 in HOoAMPmtmp.
	assert(HT := rule_2 (Oo :: A :: M :: nil) (A :: M :: P :: nil) (A :: M :: nil) 3 2 2 HOoAMPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoAMM : rk(Oo :: A :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAMeq HOoAMM3).
assert(HOoAMm : rk(Oo :: A :: M ::  nil) >= 1) by (solve_hyps_min HOoAMeq HOoAMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BM requis par la preuve de (?)BM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBMm2 : rk(B :: M :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBApMQeq : rk(B :: Ap :: M :: Q :: nil) = 3) by (apply LBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMQmtmp : rk(B :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBApMQeq HBApMQm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (B :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: M :: Ap :: M :: Q :: nil) ((B :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQmtmp;try rewrite HT2 in HBApMQmtmp.
	assert(HT := rule_2 (B :: M :: nil) (Ap :: M :: Q :: nil) (M :: nil) 3 1 2 HBApMQmtmp HMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HBMM : rk(B :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBMeq HBMM2).
assert(HBMm : rk(B :: M ::  nil) >= 1) by (solve_hyps_min HBMeq HBMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABM requis par la preuve de (?)ABM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABM requis par la preuve de (?)ABM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABMm2 : rk(A :: B :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABMm3 : rk(A :: B :: M :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HABApMQeq : rk(A :: B :: Ap :: M :: Q :: nil) = 4) by (apply LABApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApMQmtmp : rk(A :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HABApMQeq HABApMQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: B :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: Q :: nil) (A :: B :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: M :: Ap :: M :: Q :: nil) ((A :: B :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMQmtmp;try rewrite HT2 in HABApMQmtmp.
	assert(HT := rule_2 (A :: B :: M :: nil) (Ap :: M :: Q :: nil) (M :: nil) 4 1 2 HABApMQmtmp HMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HABMM : rk(A :: B :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABMeq HABMM3).
assert(HABMm : rk(A :: B :: M ::  nil) >= 1) by (solve_hyps_min HABMeq HABMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABM *)
(* dans la couche 0 *)
Lemma LOoABMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMPm2 : rk(Oo :: A :: B :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABMPM3 : rk(Oo :: A :: B :: M :: P :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: P :: nil) (Oo :: A :: B :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: M :: P :: nil) ((Oo :: A :: B :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (A :: M :: P :: nil) (A :: nil) 2 2 1 HOoABMtmp HAMPMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMPm3 : rk(Oo :: A :: B :: M :: P :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: P :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABMPM : rk(Oo :: A :: B :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABMPm : rk(Oo :: A :: B :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABMPeq HOoABMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABM requis par la preuve de (?)OoABM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABM requis par la preuve de (?)OoABM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABM requis par la preuve de (?)OoABM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMm2 : rk(Oo :: A :: B :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABMM3 : rk(Oo :: A :: B :: M :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: nil) (Oo :: A :: B :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: nil) ((Oo :: A :: B :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (M :: nil) (nil) 2 1 0 HOoABMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABMm3 : rk(Oo :: A :: B :: M :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoABMPeq : rk(Oo :: A :: B :: M :: P :: nil) = 3) by (apply LOoABMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMPmtmp : rk(Oo :: A :: B :: M :: P :: nil) >= 3) by (solve_hyps_min HOoABMPeq HOoABMPm3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: P :: nil) (Oo :: A :: B :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: M :: P :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABMPmtmp;try rewrite HT2 in HOoABMPmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: M :: nil) (A :: M :: P :: nil) (A :: M :: nil) 3 2 2 HOoABMPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoABMM : rk(Oo :: A :: B :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABMm : rk(Oo :: A :: B :: M ::  nil) >= 1) by (solve_hyps_min HOoABMeq HOoABMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCM requis par la preuve de (?)OoCM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCM requis par la preuve de (?)OoCM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCMm2 : rk(Oo :: C :: M :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: M :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCMm3 : rk(Oo :: C :: M :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HOoCApMQeq : rk(Oo :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApMQmtmp : rk(Oo :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoCApMQeq HOoCApMQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: C :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Q :: nil) (Oo :: C :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: M :: Ap :: M :: Q :: nil) ((Oo :: C :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMQmtmp;try rewrite HT2 in HOoCApMQmtmp.
	assert(HT := rule_2 (Oo :: C :: M :: nil) (Ap :: M :: Q :: nil) (M :: nil) 4 1 2 HOoCApMQmtmp HMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HOoCMM : rk(Oo :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCMeq HOoCMM3).
assert(HOoCMm : rk(Oo :: C :: M ::  nil) >= 1) by (solve_hyps_min HOoCMeq HOoCMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACMm2 : rk(A :: C :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACMm3 : rk(A :: C :: M :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HACApMQeq : rk(A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACApMQmtmp : rk(A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HACApMQeq HACApMQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: C :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Q :: nil) (A :: C :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: M :: Ap :: M :: Q :: nil) ((A :: C :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMQmtmp;try rewrite HT2 in HACApMQmtmp.
	assert(HT := rule_2 (A :: C :: M :: nil) (Ap :: M :: Q :: nil) (M :: nil) 4 1 2 HACApMQmtmp HMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HACMM : rk(A :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACMeq HACMM3).
assert(HACMm : rk(A :: C :: M ::  nil) >= 1) by (solve_hyps_min HACMeq HACMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCM requis par la preuve de (?)BCM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCM requis par la preuve de (?)BCM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCMm2 : rk(B :: C :: M :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: M :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCMm3 : rk(B :: C :: M :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBCApMQeq : rk(B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LBCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCApMQmtmp : rk(B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HBCApMQeq HBCApMQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (B :: C :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Q :: nil) (B :: C :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: M :: Ap :: M :: Q :: nil) ((B :: C :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMQmtmp;try rewrite HT2 in HBCApMQmtmp.
	assert(HT := rule_2 (B :: C :: M :: nil) (Ap :: M :: Q :: nil) (M :: nil) 4 1 2 HBCApMQmtmp HMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HBCMM : rk(B :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCMeq HBCMM3).
assert(HBCMm : rk(B :: C :: M ::  nil) >= 1) by (solve_hyps_min HBCMeq HBCMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApM *)
(* dans la couche 0 *)
Lemma LAApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Ap :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApMP requis par la preuve de (?)AApMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApMP requis par la preuve de (?)AApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMP requis par la preuve de (?)AApMP pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApMPM3 : rk(A :: Ap :: M :: P :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: P :: nil) (Ap :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: M :: P :: nil) ((Ap :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: M :: P :: nil) (nil) 1 2 0 HApMtmp HAMPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMPm2 : rk(A :: Ap :: M :: P :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: M :: P :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApMPm3 : rk(A :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) = 4) by (apply LOoAApCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApCpMPmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApCpMPeq HOoAApCpMPm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: nil) (Oo :: Ap :: Cp :: A :: Ap :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: M :: P :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPmtmp;try rewrite HT2 in HOoAApCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: M :: P :: nil) (Ap :: nil) 4 1 2 HOoAApCpMPmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HAApMPM : rk(A :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMPm : rk(A :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HAApMPeq HAApMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApM requis par la preuve de (?)ApM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApMm2 : rk(Ap :: M :: nil) >= 2).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAApMPeq : rk(A :: Ap :: M :: P :: nil) = 3) by (apply LAApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApMPmtmp : rk(A :: Ap :: M :: P :: nil) >= 3) by (solve_hyps_min HAApMPeq HAApMPm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: P :: nil) (Ap :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: A :: M :: P :: nil) ((Ap :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMPmtmp;try rewrite HT2 in HAApMPmtmp.
	assert(HT := rule_2 (Ap :: M :: nil) (A :: M :: P :: nil) (M :: nil) 3 1 2 HAApMPmtmp HMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HApMM : rk(Ap :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApMeq HApMM2).
assert(HApMm : rk(Ap :: M ::  nil) >= 1) by (solve_hyps_min HApMeq HApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApM *)
(* dans la couche 0 *)
Lemma LOoAApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMP requis par la preuve de (?)OoAApMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMP requis par la preuve de (?)OoAApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMP requis par la preuve de (?)OoAApMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMPm2 : rk(Oo :: A :: Ap :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMPm3 : rk(Oo :: A :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoAApMPm4 : rk(Oo :: A :: Ap :: M :: P :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) = 4) by (apply LOoAApCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApCpMPmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApCpMPeq HOoAApCpMPm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: Ap :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: nil) (Oo :: Ap :: Cp :: Oo :: A :: Ap :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: Ap :: M :: P :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: Ap :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPmtmp;try rewrite HT2 in HOoAApCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: Ap :: M :: P :: nil) (Oo :: Ap :: nil) 4 2 2 HOoAApCpMPmtmp HOoApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoAApMPM : rk(Oo :: A :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMPm : rk(Oo :: A :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoAApMPeq HOoAApMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMm2 : rk(Oo :: A :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMm3 : rk(Oo :: A :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAApMm4 : rk(Oo :: A :: Ap :: M :: nil) >= 4).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoAApMPeq : rk(Oo :: A :: Ap :: M :: P :: nil) = 4) by (apply LOoAApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMPmtmp : rk(Oo :: A :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApMPeq HOoAApMPm4).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: P :: nil) (Oo :: A :: Ap :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: A :: M :: P :: nil) ((Oo :: A :: Ap :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMPmtmp;try rewrite HT2 in HOoAApMPmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: M :: nil) (A :: M :: P :: nil) (A :: M :: nil) 4 2 2 HOoAApMPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoAApMM : rk(Oo :: A :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMm : rk(Oo :: A :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoAApMeq HOoAApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApM *)
(* dans la couche 0 *)
Lemma LOoABApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMP requis par la preuve de (?)OoABApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMP requis par la preuve de (?)OoABApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMP requis par la preuve de (?)OoABApMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMPm2 : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMPm3 : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMPm4 : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMPM : rk(Oo :: A :: B :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMPm : rk(Oo :: A :: B :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABApMPeq HOoABApMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApM requis par la preuve de (?)BApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)BApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApM requis par la preuve de (?)BApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApMm2 : rk(B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABApMeq HOoABApMm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: nil) (B :: Ap :: nil) 3 2 3 HOoABApMmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApMm3 : rk(B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABMPeq : rk(Oo :: A :: B :: M :: P :: nil) = 3) by (apply LOoABMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMPMtmp : rk(Oo :: A :: B :: M :: P :: nil) <= 3) by (solve_hyps_max HOoABMPeq HOoABMPM3).
	try assert(HOoABApMPeq : rk(Oo :: A :: B :: Ap :: M :: P :: nil) = 4) by (apply LOoABApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMPmtmp : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABApMPeq HOoABApMPm4).
	try assert(HBMeq : rk(B :: M :: nil) = 2) by (apply LBM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMmtmp : rk(B :: M :: nil) >= 2) by (solve_hyps_min HBMeq HBMm2).
	assert(Hincl : incl (B :: M :: nil) (list_inter (B :: Ap :: M :: nil) (Oo :: A :: B :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: P :: nil) (B :: Ap :: M :: Oo :: A :: B :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: M :: Oo :: A :: B :: M :: P :: nil) ((B :: Ap :: M :: nil) ++ (Oo :: A :: B :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMPmtmp;try rewrite HT2 in HOoABApMPmtmp.
	assert(HT := rule_2 (B :: Ap :: M :: nil) (Oo :: A :: B :: M :: P :: nil) (B :: M :: nil) 4 2 3 HOoABApMPmtmp HBMmtmp HOoABMPMtmp Hincl);apply HT.
}


assert(HBApMM : rk(B :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApMeq HBApMM3).
assert(HBApMm : rk(B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HBApMeq HBApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApM requis par la preuve de (?)ABApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)ABApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApM requis par la preuve de (?)ABApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApM requis par la preuve de (?)ABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMm2 : rk(A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApMm3 : rk(A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABApMeq HOoABApMm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: M :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApMmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApMm4 : rk(A :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HOoABMPeq : rk(Oo :: A :: B :: M :: P :: nil) = 3) by (apply LOoABMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMPMtmp : rk(Oo :: A :: B :: M :: P :: nil) <= 3) by (solve_hyps_max HOoABMPeq HOoABMPM3).
	try assert(HOoABApMPeq : rk(Oo :: A :: B :: Ap :: M :: P :: nil) = 4) by (apply LOoABApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMPmtmp : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABApMPeq HOoABApMPm4).
	try assert(HABMeq : rk(A :: B :: M :: nil) = 3) by (apply LABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMmtmp : rk(A :: B :: M :: nil) >= 3) by (solve_hyps_min HABMeq HABMm3).
	assert(Hincl : incl (A :: B :: M :: nil) (list_inter (A :: B :: Ap :: M :: nil) (Oo :: A :: B :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: P :: nil) (A :: B :: Ap :: M :: Oo :: A :: B :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: M :: Oo :: A :: B :: M :: P :: nil) ((A :: B :: Ap :: M :: nil) ++ (Oo :: A :: B :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMPmtmp;try rewrite HT2 in HOoABApMPmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: M :: nil) (Oo :: A :: B :: M :: P :: nil) (A :: B :: M :: nil) 4 3 3 HOoABApMPmtmp HABMmtmp HOoABMPMtmp Hincl);apply HT.
}


assert(HABApMM : rk(A :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMm : rk(A :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HABApMeq HABApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABApMm4 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoABApMPeq : rk(Oo :: A :: B :: Ap :: M :: P :: nil) = 4) by (apply LOoABApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMPmtmp : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABApMPeq HOoABApMPm4).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: P :: nil) (Oo :: A :: B :: Ap :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: A :: M :: P :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMPmtmp;try rewrite HT2 in HOoABApMPmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: M :: nil) (A :: M :: P :: nil) (A :: M :: nil) 4 2 2 HOoABApMPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoABApMM : rk(Oo :: A :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMm : rk(Oo :: A :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoABApMeq HOoABApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApM *)
(* dans la couche 0 *)
Lemma LOoACApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Ap :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMP requis par la preuve de (?)OoACApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMP requis par la preuve de (?)OoACApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMP requis par la preuve de (?)OoACApMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMPm2 : rk(Oo :: A :: C :: Ap :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMPm3 : rk(Oo :: A :: C :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMPm4 : rk(Oo :: A :: C :: Ap :: M :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApMPM : rk(Oo :: A :: C :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMPm : rk(Oo :: A :: C :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoACApMPeq HOoACApMPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApM *)
(* dans la couche 0 *)
Lemma LOoACMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACMP requis par la preuve de (?)OoACMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACMP requis par la preuve de (?)OoACMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACMP requis par la preuve de (?)OoACMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMPm2 : rk(Oo :: A :: C :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACMPM3 : rk(Oo :: A :: C :: M :: P :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: M :: P :: nil) (Oo :: A :: C :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: M :: P :: nil) ((Oo :: A :: C :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (A :: M :: P :: nil) (A :: nil) 2 2 1 HOoACMtmp HAMPMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMPm3 : rk(Oo :: A :: C :: M :: P :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: C :: M :: P :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACMPM : rk(Oo :: A :: C :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACMPm : rk(Oo :: A :: C :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoACMPeq HOoACMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm2 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm3 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMm2 : rk(Oo :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: M :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApMm3 : rk(Oo :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMmtmp : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoACApMeq HOoACApMm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMmtmp;try rewrite HT2 in HOoACApMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApMmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMM1. try clear HOoACApMM2. try clear HOoACApMM3. try clear HOoACApMm4. try clear HOoACApMm3. try clear HOoACApMm2. try clear HOoACApMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApMm4 : rk(Oo :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HOoACMPeq : rk(Oo :: A :: C :: M :: P :: nil) = 3) by (apply LOoACMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMPMtmp : rk(Oo :: A :: C :: M :: P :: nil) <= 3) by (solve_hyps_max HOoACMPeq HOoACMPM3).
	try assert(HOoACApMPeq : rk(Oo :: A :: C :: Ap :: M :: P :: nil) = 4) by (apply LOoACApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMPmtmp : rk(Oo :: A :: C :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoACApMPeq HOoACApMPm4).
	try assert(HOoCMeq : rk(Oo :: C :: M :: nil) = 3) by (apply LOoCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCMmtmp : rk(Oo :: C :: M :: nil) >= 3) by (solve_hyps_min HOoCMeq HOoCMm3).
	assert(Hincl : incl (Oo :: C :: M :: nil) (list_inter (Oo :: C :: Ap :: M :: nil) (Oo :: A :: C :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: P :: nil) (Oo :: C :: Ap :: M :: Oo :: A :: C :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: M :: Oo :: A :: C :: M :: P :: nil) ((Oo :: C :: Ap :: M :: nil) ++ (Oo :: A :: C :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMPmtmp;try rewrite HT2 in HOoACApMPmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: M :: nil) (Oo :: A :: C :: M :: P :: nil) (Oo :: C :: M :: nil) 4 3 3 HOoACApMPmtmp HOoCMmtmp HOoACMPMtmp Hincl);apply HT.
}


assert(HOoCApMM : rk(Oo :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMm : rk(Oo :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoCApMeq HOoCApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpM *)
(* dans constructLemma(), requis par LOoABpMP *)
(* dans la couche 0 *)
Lemma LOoABpCpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Bp :: Cp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpMP requis par la preuve de (?)OoABpCpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpMP requis par la preuve de (?)OoABpCpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpMP requis par la preuve de (?)OoABpCpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMPm2 : rk(Oo :: A :: Bp :: Cp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoABpCpMPm3 : rk(Oo :: A :: Bp :: Cp :: M :: P :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoAApBpCpMPeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpMPmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) (Ap :: Oo :: A :: Bp :: Cp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: Bp :: Cp :: M :: P :: nil) ((Ap :: nil) ++ (Oo :: A :: Bp :: Cp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPmtmp;try rewrite HT2 in HOoAApBpCpMPmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: nil) (nil) 4 0 1 HOoAApBpCpMPmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpCpMPm4 : rk(Oo :: A :: Bp :: Cp :: M :: P :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpMPmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Bp :: Cp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Bp :: Cp :: M :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Bp :: Cp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPmtmp;try rewrite HT2 in HOoAApBpCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: nil) (Oo :: Bp :: nil) 4 2 2 HOoAApBpCpMPmtmp HOoBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoABpCpMPM : rk(Oo :: A :: Bp :: Cp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpMPm : rk(Oo :: A :: Bp :: Cp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABpCpMPeq HOoABpCpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMP requis par la preuve de (?)OoABpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMP requis par la preuve de (?)OoABpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMP requis par la preuve de (?)OoABpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMPm2 : rk(Oo :: A :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMPm3 : rk(Oo :: A :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: P :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HOoABpMPm4 : rk(Oo :: A :: Bp :: M :: P :: nil) >= 4).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoABpCpMPeq : rk(Oo :: A :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoABpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpCpMPmtmp : rk(Oo :: A :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABpCpMPeq HOoABpCpMPm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (Oo :: A :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: P :: nil) (Oo :: Bp :: Cp :: Oo :: A :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: Oo :: A :: Bp :: M :: P :: nil) ((Oo :: Bp :: Cp :: nil) ++ (Oo :: A :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMPmtmp;try rewrite HT2 in HOoABpCpMPmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (Oo :: A :: Bp :: M :: P :: nil) (Oo :: Bp :: nil) 4 2 2 HOoABpCpMPmtmp HOoBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HOoABpMPM : rk(Oo :: A :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMPm : rk(Oo :: A :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABpMPeq HOoABpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMm2 : rk(Oo :: A :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMm3 : rk(Oo :: A :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpMm4 : rk(Oo :: A :: Bp :: M :: nil) >= 4).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoABpMPeq : rk(Oo :: A :: Bp :: M :: P :: nil) = 4) by (apply LOoABpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpMPmtmp : rk(Oo :: A :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABpMPeq HOoABpMPm4).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: Bp :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: M :: P :: nil) (Oo :: A :: Bp :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: M :: A :: M :: P :: nil) ((Oo :: A :: Bp :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpMPmtmp;try rewrite HT2 in HOoABpMPmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: M :: nil) (A :: M :: P :: nil) (A :: M :: nil) 4 2 2 HOoABpMPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoABpMM : rk(Oo :: A :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMm : rk(Oo :: A :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoABpMeq HOoABpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACBpM *)
(* dans la couche 0 *)
Lemma LOoACBpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: C :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpMP requis par la preuve de (?)OoACBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpMP requis par la preuve de (?)OoACBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpMP requis par la preuve de (?)OoACBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMPm2 : rk(Oo :: A :: C :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMPm3 : rk(Oo :: A :: C :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: P :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMPm4 : rk(Oo :: A :: C :: Bp :: M :: P :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: M :: P :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACBpMPM : rk(Oo :: A :: C :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpMPm : rk(Oo :: A :: C :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoACBpMPeq HOoACBpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpM requis par la preuve de (?)ACBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpM requis par la preuve de (?)ACBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm2 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm3 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpM requis par la preuve de (?)ACBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpM requis par la preuve de (?)ACBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpMm2 : rk(A :: C :: Bp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: M ::  de rang :  3 et 4 	 AiB : A :: C :: Bp ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HACBpMm3 : rk(A :: C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpMmtmp : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoACBpMeq HOoACBpMm3).
	try assert(HACBpeq : rk(A :: C :: Bp :: nil) = 3) by (apply LACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 3) by (solve_hyps_min HACBpeq HACBpm3).
	assert(Hincl : incl (A :: C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (A :: C :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: A :: C :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: A :: C :: Bp :: M :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (A :: C :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMmtmp;try rewrite HT2 in HOoACBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: nil) 3 3 3 HOoACBpMmtmp HACBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpMM1. try clear HOoACBpMM2. try clear HOoACBpMM3. try clear HOoACBpMm4. try clear HOoACBpMm3. try clear HOoACBpMm2. try clear HOoACBpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACBpMm4 : rk(A :: C :: Bp :: M :: nil) >= 4).
{
	try assert(HOoACMPeq : rk(Oo :: A :: C :: M :: P :: nil) = 3) by (apply LOoACMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMPMtmp : rk(Oo :: A :: C :: M :: P :: nil) <= 3) by (solve_hyps_max HOoACMPeq HOoACMPM3).
	try assert(HOoACBpMPeq : rk(Oo :: A :: C :: Bp :: M :: P :: nil) = 4) by (apply LOoACBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpMPmtmp : rk(Oo :: A :: C :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoACBpMPeq HOoACBpMPm4).
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hincl : incl (A :: C :: M :: nil) (list_inter (A :: C :: Bp :: M :: nil) (Oo :: A :: C :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: P :: nil) (A :: C :: Bp :: M :: Oo :: A :: C :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: M :: Oo :: A :: C :: M :: P :: nil) ((A :: C :: Bp :: M :: nil) ++ (Oo :: A :: C :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMPmtmp;try rewrite HT2 in HOoACBpMPmtmp.
	assert(HT := rule_2 (A :: C :: Bp :: M :: nil) (Oo :: A :: C :: M :: P :: nil) (A :: C :: M :: nil) 4 3 3 HOoACBpMPmtmp HACMmtmp HOoACMPMtmp Hincl);apply HT.
}


assert(HACBpMM : rk(A :: C :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpMm : rk(A :: C :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HACBpMeq HACBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpM *)
(* dans constructLemma(), requis par LAApBpMP *)
(* dans la couche 0 *)
Lemma LAApBpCpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpCpMP requis par la preuve de (?)AApBpCpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpMP requis par la preuve de (?)AApBpCpMP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HAApBpCpMPm3 : rk(A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoAApBpCpMPeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpMPmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) (Oo :: A :: A :: Ap :: Bp :: Cp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: Ap :: Bp :: Cp :: M :: P :: nil) ((Oo :: A :: nil) ++ (A :: Ap :: Bp :: Cp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPmtmp;try rewrite HT2 in HOoAApBpCpMPmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: nil) (A :: nil) 4 1 2 HOoAApBpCpMPmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpCpMPm4 : rk(A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpMPmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: M :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPmtmp;try rewrite HT2 in HOoAApBpCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: nil) (Ap :: Bp :: nil) 4 2 2 HOoAApBpCpMPmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HAApBpCpMPM : rk(A :: Ap :: Bp :: Cp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpMPm : rk(A :: Ap :: Bp :: Cp :: M :: P ::  nil) >= 1) by (solve_hyps_min HAApBpCpMPeq HAApBpCpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Ap :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpMP requis par la preuve de (?)AApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMP requis par la preuve de (?)AApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMP requis par la preuve de (?)OoAApBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMP requis par la preuve de (?)OoAApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMPm2 : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMPm3 : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpMP requis par la preuve de (?)AApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpMP requis par la preuve de (?)AApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpMPm2 : rk(A :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: M :: P :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: P ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpMPm3 : rk(A :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpMPmtmp : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 3) by (solve_hyps_min HOoAApBpMPeq HOoAApBpMPm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: P :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMPmtmp;try rewrite HT2 in HOoAApBpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: P :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpMPmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HAApBpMPm4 : rk(A :: Ap :: Bp :: M :: P :: nil) >= 4).
{
	try assert(HApBpCpeq : rk(Ap :: Bp :: Cp :: nil) = 2) by (apply LApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpCpMtmp : rk(Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HApBpCpeq HApBpCpM2).
	try assert(HAApBpCpMPeq : rk(A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApBpCpMPmtmp : rk(A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HAApBpCpMPeq HAApBpCpMPm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: M :: P :: nil) (Ap :: Bp :: Cp :: A :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: A :: Ap :: Bp :: M :: P :: nil) ((Ap :: Bp :: Cp :: nil) ++ (A :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpMPmtmp;try rewrite HT2 in HAApBpCpMPmtmp.
	assert(HT := rule_4 (Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: M :: P :: nil) (Ap :: Bp :: nil) 4 2 2 HAApBpCpMPmtmp HApBpmtmp HApBpCpMtmp Hincl); apply HT.
}


assert(HAApBpMPM : rk(A :: Ap :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpMPm : rk(A :: Ap :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HAApBpMPeq HAApBpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpM requis par la preuve de (?)ApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpM requis par la preuve de (?)ApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpMm2 : rk(Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: M :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpMm3 : rk(Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAApBpMPeq : rk(A :: Ap :: Bp :: M :: P :: nil) = 4) by (apply LAApBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApBpMPmtmp : rk(A :: Ap :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HAApBpMPeq HAApBpMPm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: Bp :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: M :: P :: nil) (Ap :: Bp :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: M :: A :: M :: P :: nil) ((Ap :: Bp :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpMPmtmp;try rewrite HT2 in HAApBpMPmtmp.
	assert(HT := rule_2 (Ap :: Bp :: M :: nil) (A :: M :: P :: nil) (M :: nil) 4 1 2 HAApBpMPmtmp HMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HApBpMM : rk(Ap :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpMeq HApBpMM3).
assert(HApBpMm : rk(Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HApBpMeq HApBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpM *)
(* dans la couche 0 *)
Lemma LOoAApBpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMP requis par la preuve de (?)OoAApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMP requis par la preuve de (?)OoAApBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMP requis par la preuve de (?)OoAApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMPm2 : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMPm3 : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoAApBpMPm4 : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApBpCpMPeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) = 4) by (apply LOoAApBpCpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpCpMPmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPeq HOoAApBpCpMPm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: nil) (Oo :: Ap :: Cp :: Oo :: A :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: Ap :: Bp :: M :: P :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPmtmp;try rewrite HT2 in HOoAApBpCpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: nil) (Oo :: Ap :: nil) 4 2 2 HOoAApBpCpMPmtmp HOoApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoAApBpMPM : rk(Oo :: A :: Ap :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpMPm : rk(Oo :: A :: Ap :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoAApBpMPeq HOoAApBpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMm2 : rk(Oo :: Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpMM3 : rk(Oo :: Ap :: Bp :: M :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (M :: nil) (nil) 2 1 0 HOoApBpMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpMm3 : rk(Oo :: Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoAApBpMPeq : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) = 4) by (apply LOoAApBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApBpMPmtmp : rk(Oo :: A :: Ap :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoAApBpMPeq HOoAApBpMPm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: P :: nil) (Oo :: Ap :: Bp :: M :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: A :: M :: P :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMPmtmp;try rewrite HT2 in HOoAApBpMPmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: M :: nil) (A :: M :: P :: nil) (M :: nil) 4 1 2 HOoAApBpMPmtmp HMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoApBpMM : rk(Oo :: Ap :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpMm : rk(Oo :: Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoApBpMeq HOoApBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApBpM *)
(* dans constructLemma(), requis par LCApBpMQ *)
(* dans la couche 0 *)
Lemma LOoCApBpMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap :: Bp :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpMQ requis par la preuve de (?)OoCApBpMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpMQ requis par la preuve de (?)OoCApBpMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpMQ requis par la preuve de (?)OoCApBpMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQm2 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQm3 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQm4 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpMQM : rk(Oo :: C :: Ap :: Bp :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpMQm : rk(Oo :: C :: Ap :: Bp :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoCApBpMQeq HOoCApBpMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: Bp :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpMQ requis par la preuve de (?)CApBpMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpMQ requis par la preuve de (?)CApBpMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpMQ requis par la preuve de (?)OoCApBpMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpMQ requis par la preuve de (?)OoCApBpMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQm2 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQm3 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpMQ requis par la preuve de (?)CApBpMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpMQ requis par la preuve de (?)CApBpMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpMQ requis par la preuve de (?)OoACApBpMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpMQ requis par la preuve de (?)OoACApBpMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMQm2 : rk(Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMQm3 : rk(Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpMQ requis par la preuve de (?)CApBpMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: M :: Q ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpMQm2 : rk(C :: Ap :: Bp :: M :: Q :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpMQmtmp : rk(Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil) >= 3) by (solve_hyps_min HOoACApBpMQeq HOoACApBpMQm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: M :: Q :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: M :: Q :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpMQmtmp;try rewrite HT2 in HOoACApBpMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: M :: Q :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpMQmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpMQM1. try clear HOoACApBpMQM2. try clear HOoACApBpMQM3. try clear HOoACApBpMQm4. try clear HOoACApBpMQm3. try clear HOoACApBpMQm2. try clear HOoACApBpMQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: M :: Q ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpMQm3 : rk(C :: Ap :: Bp :: M :: Q :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpMQmtmp : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 3) by (solve_hyps_min HOoCApBpMQeq HOoCApBpMQm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: Q :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: M :: Q :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMQmtmp;try rewrite HT2 in HOoCApBpMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: M :: Q :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpMQmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: M :: Q ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HCApBpMQm4 : rk(C :: Ap :: Bp :: M :: Q :: nil) >= 4).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	try assert(HOoCApBpMQeq : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) = 4) by (apply LOoCApBpMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApBpMQmtmp : rk(Oo :: C :: Ap :: Bp :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoCApBpMQeq HOoCApBpMQm4).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: Q :: nil) (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: M :: Q :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (C :: Ap :: Bp :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMQmtmp;try rewrite HT2 in HOoCApBpMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: M :: Q :: nil) (Ap :: Bp :: M :: nil) 4 3 3 HOoCApBpMQmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoCApBpMQM1. try clear HOoCApBpMQM2. try clear HOoCApBpMQM3. try clear HOoCApBpMQm4. try clear HOoCApBpMQm3. try clear HOoCApBpMQm2. try clear HOoCApBpMQm1. 

assert(HCApBpMQM : rk(C :: Ap :: Bp :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpMQm : rk(C :: Ap :: Bp :: M :: Q ::  nil) >= 1) by (solve_hyps_min HCApBpMQeq HCApBpMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpM requis par la preuve de (?)CApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpM requis par la preuve de (?)CApBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpM requis par la preuve de (?)OoCApBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpM requis par la preuve de (?)OoACApBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpM requis par la preuve de (?)OoACApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMm2 : rk(Oo :: A :: C :: Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMm3 : rk(Oo :: A :: C :: Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpM requis par la preuve de (?)OoCApBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpM requis par la preuve de (?)OoCApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMm2 : rk(Oo :: C :: Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: M ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpMm3 : rk(Oo :: C :: Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpMmtmp : rk(Oo :: A :: C :: Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoACApBpMeq HOoACApBpMm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: M :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpMmtmp;try rewrite HT2 in HOoACApBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpMmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpM requis par la preuve de (?)CApBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpM requis par la preuve de (?)CApBpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: M ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpMm2 : rk(C :: Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpMmtmp : rk(Oo :: A :: C :: Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoACApBpMeq HOoACApBpMm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: M :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpMmtmp;try rewrite HT2 in HOoACApBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: M :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpMmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpMM1. try clear HOoACApBpMM2. try clear HOoACApBpMM3. try clear HOoACApBpMm4. try clear HOoACApBpMm3. try clear HOoACApBpMm2. try clear HOoACApBpMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: M ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpMm3 : rk(C :: Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpMmtmp : rk(Oo :: C :: Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoCApBpMeq HOoCApBpMm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMmtmp;try rewrite HT2 in HOoCApBpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: M :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpMmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoCApBpMM1. try clear HOoCApBpMM2. try clear HOoCApBpMM3. try clear HOoCApBpMm4. try clear HOoCApBpMm3. try clear HOoCApBpMm2. try clear HOoCApBpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApBpMm4 : rk(C :: Ap :: Bp :: M :: nil) >= 4).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HCApBpMQeq : rk(C :: Ap :: Bp :: M :: Q :: nil) = 4) by (apply LCApBpMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApBpMQmtmp : rk(C :: Ap :: Bp :: M :: Q :: nil) >= 4) by (solve_hyps_min HCApBpMQeq HCApBpMQm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (C :: Ap :: Bp :: M :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: M :: Q :: nil) (C :: Ap :: Bp :: M :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: M :: Ap :: M :: Q :: nil) ((C :: Ap :: Bp :: M :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpMQmtmp;try rewrite HT2 in HCApBpMQmtmp.
	assert(HT := rule_2 (C :: Ap :: Bp :: M :: nil) (Ap :: M :: Q :: nil) (Ap :: M :: nil) 4 2 2 HCApBpMQmtmp HApMmtmp HApMQMtmp Hincl);apply HT.
}


assert(HCApBpMM : rk(C :: Ap :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpMm : rk(C :: Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HCApBpMeq HCApBpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(N ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HNM : rk(N ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HNeq HNM1).
assert(HNm : rk(N ::  nil) >= 1) by (solve_hyps_min HNeq HNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAN *)
(* dans la couche 0 *)
Lemma LABpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Bp :: N :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpNP requis par la preuve de (?)ABpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpNP requis par la preuve de (?)ABpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpNP requis par la preuve de (?)ACBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpNP requis par la preuve de (?)ACBpNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACBpNPm2 : rk(A :: C :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: B :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Bp :: N :: P :: nil) ((Oo :: B :: nil) ++ (A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Bp :: N :: P :: nil) (nil) 4 0 2 HOoABCBpNPmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACBpNPm3 : rk(A :: C :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: A :: B :: A :: C :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Bp :: N :: P :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: P :: nil) (A :: nil) 4 1 2 HOoABCBpNPmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpNP requis par la preuve de (?)ABpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpNP requis par la preuve de (?)ABpNP pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpNPM3 : rk(A :: Bp :: N :: P :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: P :: nil) (A :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: N :: P :: nil) ((A :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Bp :: N :: P :: nil) (nil) 1 2 0 HAMtmp HBpNPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Bp :: N :: P ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABpNPm2 : rk(A :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACBpNPmtmp : rk(A :: C :: Bp :: N :: P :: nil) >= 3) by (solve_hyps_min HACBpNPeq HACBpNPm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: N :: P :: nil) (C :: A :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Bp :: N :: P :: nil) ((C :: nil) ++ (A :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpNPmtmp;try rewrite HT2 in HACBpNPmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Bp :: N :: P :: nil) (nil) 3 0 1 HACBpNPmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HACBpNPM1. try clear HACBpNPM2. try clear HACBpNPM3. try clear HACBpNPm4. try clear HACBpNPm3. try clear HACBpNPm2. try clear HACBpNPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HABpNPm3 : rk(A :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPeq : rk(Oo :: A :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoACBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpNPmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoACBpNPeq HOoACBpNPm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: nil) (Oo :: A :: C :: A :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Bp :: N :: P :: nil) ((Oo :: A :: C :: nil) ++ (A :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPmtmp;try rewrite HT2 in HOoACBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Bp :: N :: P :: nil) (A :: nil) 4 1 2 HOoACBpNPmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HABpNPM : rk(A :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpNPm : rk(A :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HABpNPeq HABpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AN requis par la preuve de (?)AN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HANm2 : rk(A :: N :: nil) >= 2).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HABpNPeq : rk(A :: Bp :: N :: P :: nil) = 3) by (apply LABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpNPmtmp : rk(A :: Bp :: N :: P :: nil) >= 3) by (solve_hyps_min HABpNPeq HABpNPm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (A :: N :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: P :: nil) (A :: N :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: N :: Bp :: N :: P :: nil) ((A :: N :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpNPmtmp;try rewrite HT2 in HABpNPmtmp.
	assert(HT := rule_2 (A :: N :: nil) (Bp :: N :: P :: nil) (N :: nil) 3 1 2 HABpNPmtmp HNmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HANM : rk(A :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HANeq HANM2).
assert(HANm : rk(A :: N ::  nil) >= 1) by (solve_hyps_min HANeq HANm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAN *)
(* dans la couche 0 *)
Lemma LOoABpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNP requis par la preuve de (?)OoABpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNP requis par la preuve de (?)OoABpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNP requis par la preuve de (?)OoABpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNPm2 : rk(Oo :: A :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABpNPm3 : rk(Oo :: A :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACBpNPeq : rk(Oo :: A :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoACBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpNPmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoACBpNPeq HOoACBpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: nil) (C :: Oo :: A :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Bp :: N :: P :: nil) ((C :: nil) ++ (Oo :: A :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPmtmp;try rewrite HT2 in HOoACBpNPmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Bp :: N :: P :: nil) (nil) 4 0 1 HOoACBpNPmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABpNPm4 : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPeq : rk(Oo :: A :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoACBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpNPmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoACBpNPeq HOoACBpNPm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: nil) (Oo :: A :: C :: Oo :: A :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Bp :: N :: P :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPmtmp;try rewrite HT2 in HOoACBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Bp :: N :: P :: nil) (Oo :: A :: nil) 4 2 2 HOoACBpNPmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABpNPM : rk(Oo :: A :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNPm : rk(Oo :: A :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoABpNPeq HOoABpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAN requis par la preuve de (?)OoAN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAN requis par la preuve de (?)OoAN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANm2 : rk(Oo :: A :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoANm3 : rk(Oo :: A :: N :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: A :: N :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Oo :: A :: N :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: Bp :: N :: P :: nil) ((Oo :: A :: N :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_2 (Oo :: A :: N :: nil) (Bp :: N :: P :: nil) (N :: nil) 4 1 2 HOoABpNPmtmp HNmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HOoANM : rk(Oo :: A :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoANeq HOoANM3).
assert(HOoANm : rk(Oo :: A :: N ::  nil) >= 1) by (solve_hyps_min HOoANeq HOoANm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABN requis par la preuve de (?)ABN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABN requis par la preuve de (?)ABN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNm2 : rk(A :: B :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABNm3 : rk(A :: B :: N :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HABBpNPeq : rk(A :: B :: Bp :: N :: P :: nil) = 4) by (apply LABBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABBpNPmtmp : rk(A :: B :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HABBpNPeq HABBpNPm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (A :: B :: N :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: N :: P :: nil) (A :: B :: N :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: N :: Bp :: N :: P :: nil) ((A :: B :: N :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpNPmtmp;try rewrite HT2 in HABBpNPmtmp.
	assert(HT := rule_2 (A :: B :: N :: nil) (Bp :: N :: P :: nil) (N :: nil) 4 1 2 HABBpNPmtmp HNmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HABNM : rk(A :: B :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABNeq HABNM3).
assert(HABNm : rk(A :: B :: N ::  nil) >= 1) by (solve_hyps_min HABNeq HABNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABN *)
(* dans la couche 0 *)
Lemma LOoABBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNP requis par la preuve de (?)OoABBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNP requis par la preuve de (?)OoABBpNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNP requis par la preuve de (?)OoABBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPm2 : rk(Oo :: A :: B :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABBpNPm3 : rk(Oo :: A :: B :: Bp :: N :: P :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (C :: Oo :: A :: B :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Bp :: N :: P :: nil) ((C :: nil) ++ (Oo :: A :: B :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Bp :: N :: P :: nil) (nil) 4 0 1 HOoABCBpNPmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABBpNPm4 : rk(Oo :: A :: B :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoABCBpNPeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) = 4) by (apply LOoABCBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCBpNPmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABCBpNPeq HOoABCBpNPm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: nil) (Oo :: A :: C :: Oo :: A :: B :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Bp :: N :: P :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPmtmp;try rewrite HT2 in HOoABCBpNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: B :: Bp :: N :: P :: nil) (Oo :: A :: nil) 4 2 2 HOoABCBpNPmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABBpNPM : rk(Oo :: A :: B :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNPm : rk(Oo :: A :: B :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoABBpNPeq HOoABBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABN requis par la preuve de (?)OoABN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABN requis par la preuve de (?)OoABN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABN requis par la preuve de (?)OoABN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNm2 : rk(Oo :: A :: B :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABNM3 : rk(Oo :: A :: B :: N :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: nil) (Oo :: A :: B :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: nil) ((Oo :: A :: B :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (N :: nil) (nil) 2 1 0 HOoABMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABNm3 : rk(Oo :: A :: B :: N :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HOoABBpNPeq : rk(Oo :: A :: B :: Bp :: N :: P :: nil) = 4) by (apply LOoABBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABBpNPmtmp : rk(Oo :: A :: B :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABBpNPeq HOoABBpNPm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: A :: B :: N :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: P :: nil) (Oo :: A :: B :: N :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: Bp :: N :: P :: nil) ((Oo :: A :: B :: N :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNPmtmp;try rewrite HT2 in HOoABBpNPmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: N :: nil) (Bp :: N :: P :: nil) (N :: nil) 4 1 2 HOoABBpNPmtmp HNmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HOoABNM : rk(Oo :: A :: B :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABNm : rk(Oo :: A :: B :: N ::  nil) >= 1) by (solve_hyps_min HOoABNeq HOoABNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpN *)
(* dans constructLemma(), requis par LBBpNQ *)
(* dans constructLemma(), requis par LOoBBpCpNQ *)
(* dans la couche 0 *)
Lemma LOoBApBpCpNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HOoBApBpCpNQM : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpCpNQm : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoBApBpCpNQeq HOoBApBpCpNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBpCpNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: B :: Bp :: Cp :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpNQ requis par la preuve de (?)OoBBpCpNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpNQ requis par la preuve de (?)OoBBpCpNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpNQ requis par la preuve de (?)OoBBpCpNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNQm2 : rk(Oo :: B :: Bp :: Cp :: N :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoBBpCpNQm3 : rk(Oo :: B :: Bp :: Cp :: N :: Q :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoBApBpCpNQeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: nil) = 4) by (apply LOoBApBpCpNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApBpCpNQmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQeq HOoBApBpCpNQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: nil) (Ap :: Oo :: B :: Bp :: Cp :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: B :: Bp :: Cp :: N :: Q :: nil) ((Ap :: nil) ++ (Oo :: B :: Bp :: Cp :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQmtmp;try rewrite HT2 in HOoBApBpCpNQmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: nil) (nil) 4 0 1 HOoBApBpCpNQmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBBpCpNQm4 : rk(Oo :: B :: Bp :: Cp :: N :: Q :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: nil) = 4) by (apply LOoBApBpCpNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApBpCpNQmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQeq HOoBApBpCpNQm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Bp :: Cp :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Bp :: Cp :: N :: Q :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Bp :: Cp :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQmtmp;try rewrite HT2 in HOoBApBpCpNQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBApBpCpNQmtmp HOoBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoBApBpCpNQM1. try clear HOoBApBpCpNQM2. try clear HOoBApBpCpNQM3. try clear HOoBApBpCpNQm4. try clear HOoBApBpCpNQm3. try clear HOoBApBpCpNQm2. try clear HOoBApBpCpNQm1. 

assert(HOoBBpCpNQM : rk(Oo :: B :: Bp :: Cp :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpNQm : rk(Oo :: B :: Bp :: Cp :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoBBpCpNQeq HOoBBpCpNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Bp :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpNQ requis par la preuve de (?)BBpNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpNQ requis par la preuve de (?)BBpNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BNQ requis par la preuve de (?)BBpNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpNQ requis par la preuve de (?)BBpNQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBBpNQM3 : rk(B :: Bp :: N :: Q :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: Q :: nil) (Bp :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: N :: Q :: nil) ((Bp :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HBpMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpNQm2 : rk(B :: Bp :: N :: Q :: nil) >= 2).
{
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: N :: Q :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: N :: Q ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpNQm3 : rk(B :: Bp :: N :: Q :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoBBpCpNQeq : rk(Oo :: B :: Bp :: Cp :: N :: Q :: nil) = 4) by (apply LOoBBpCpNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBBpCpNQmtmp : rk(Oo :: B :: Bp :: Cp :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoBBpCpNQeq HOoBBpCpNQm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: Q :: nil) (Oo :: Bp :: Cp :: B :: Bp :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: N :: Q :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNQmtmp;try rewrite HT2 in HOoBBpCpNQmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: N :: Q :: nil) (Bp :: nil) 4 1 2 HOoBBpCpNQmtmp HBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HBBpNQM : rk(B :: Bp :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpNQm : rk(B :: Bp :: N :: Q ::  nil) >= 1) by (solve_hyps_min HBBpNQeq HBBpNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpN *)
(* dans la couche 0 *)
Lemma LBNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HBNQM : rk(B :: N :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBNQeq HBNQM3).
assert(HBNQm : rk(B :: N :: Q ::  nil) >= 1) by (solve_hyps_min HBNQeq HBNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Bp :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpN requis par la preuve de (?)BpN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpNm2 : rk(Bp :: N :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBBpNQeq : rk(B :: Bp :: N :: Q :: nil) = 3) by (apply LBBpNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBBpNQmtmp : rk(B :: Bp :: N :: Q :: nil) >= 3) by (solve_hyps_min HBBpNQeq HBBpNQm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: Q :: nil) (Bp :: N :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: B :: N :: Q :: nil) ((Bp :: N :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpNQmtmp;try rewrite HT2 in HBBpNQmtmp.
	assert(HT := rule_2 (Bp :: N :: nil) (B :: N :: Q :: nil) (N :: nil) 3 1 2 HBBpNQmtmp HNmtmp HBNQMtmp Hincl);apply HT.
}


assert(HBpNM : rk(Bp :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpNeq HBpNM2).
assert(HBpNm : rk(Bp :: N ::  nil) >= 1) by (solve_hyps_min HBpNeq HBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpN requis par la preuve de (?)ABpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpN requis par la preuve de (?)ABpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm2 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm3 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpN requis par la preuve de (?)ABpN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: N ::  de rang :  3 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABpNm2 : rk(A :: Bp :: N :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpNmtmp : rk(Oo :: A :: B :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoABBpNeq HOoABBpNm3).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: Bp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: A :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: Bp :: N :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: Bp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNmtmp;try rewrite HT2 in HOoABBpNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: Bp :: N :: nil) (A :: Bp :: nil) 3 2 3 HOoABBpNmtmp HABpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpNM1. try clear HOoABBpNM2. try clear HOoABBpNM3. try clear HOoABBpNm4. try clear HOoABBpNm3. try clear HOoABBpNm2. try clear HOoABBpNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpNm3 : rk(A :: Bp :: N :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HABpNPeq : rk(A :: Bp :: N :: P :: nil) = 3) by (apply LABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpNPmtmp : rk(A :: Bp :: N :: P :: nil) >= 3) by (solve_hyps_min HABpNPeq HABpNPm3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (A :: Bp :: N :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: P :: nil) (A :: Bp :: N :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: N :: Bp :: N :: P :: nil) ((A :: Bp :: N :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpNPmtmp;try rewrite HT2 in HABpNPmtmp.
	assert(HT := rule_2 (A :: Bp :: N :: nil) (Bp :: N :: P :: nil) (Bp :: N :: nil) 3 2 2 HABpNPmtmp HBpNmtmp HBpNPMtmp Hincl);apply HT.
}
try clear HBpNM1. try clear HBpNM2. try clear HBpNM3. try clear HBpNm4. try clear HBpNm3. try clear HBpNm2. try clear HBpNm1. 

assert(HABpNM : rk(A :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABpNeq HABpNM3).
assert(HABpNm : rk(A :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HABpNeq HABpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LXMN *)
(* dans constructLemma(), requis par LAXMN *)
(* dans constructLemma(), requis par LOoAApXMN *)
(* dans la couche 0 *)
Lemma LOoAApXMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: X :: M :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApXMNP requis par la preuve de (?)OoAApXMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApXMNP requis par la preuve de (?)OoAApXMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApXMNP requis par la preuve de (?)OoAApXMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXMNPm2 : rk(Oo :: A :: Ap :: X :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: X :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXMNPm3 : rk(Oo :: A :: Ap :: X :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: M :: N :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXMNPm4 : rk(Oo :: A :: Ap :: X :: M :: N :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: X :: M :: N :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApXMNPM : rk(Oo :: A :: Ap :: X :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApXMNPm : rk(Oo :: A :: Ap :: X :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoAApXMNPeq HOoAApXMNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApXMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: X :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApXMN requis par la preuve de (?)OoAApXMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApXMN requis par la preuve de (?)OoAApXMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApXMN requis par la preuve de (?)OoAApXMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXMNm2 : rk(Oo :: A :: Ap :: X :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: X :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: X :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXMNm3 : rk(Oo :: A :: Ap :: X :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAApXMNm4 : rk(Oo :: A :: Ap :: X :: M :: N :: nil) >= 4).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoAApXMNPeq : rk(Oo :: A :: Ap :: X :: M :: N :: P :: nil) = 4) by (apply LOoAApXMNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApXMNPmtmp : rk(Oo :: A :: Ap :: X :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HOoAApXMNPeq HOoAApXMNPm4).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: Ap :: X :: M :: N :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: X :: M :: N :: P :: nil) (Oo :: A :: Ap :: X :: M :: N :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: X :: M :: N :: A :: M :: P :: nil) ((Oo :: A :: Ap :: X :: M :: N :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApXMNPmtmp;try rewrite HT2 in HOoAApXMNPmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: X :: M :: N :: nil) (A :: M :: P :: nil) (A :: M :: nil) 4 2 2 HOoAApXMNPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoAApXMNM : rk(Oo :: A :: Ap :: X :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApXMNm : rk(Oo :: A :: Ap :: X :: M :: N ::  nil) >= 1) by (solve_hyps_min HOoAApXMNeq HOoAApXMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAXMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: X :: M :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AXMN requis par la preuve de (?)AXMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour AXMNP requis par la preuve de (?)AXMN pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour AXNP requis par la preuve de (?)AXMNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABpXNP requis par la preuve de (?)AXNP pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpXNP requis par la preuve de (?)ABpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpXNP requis par la preuve de (?)ABpXNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)ABpXNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm2 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm3 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpXNP requis par la preuve de (?)ABpXNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: X :: N :: P ::  de rang :  3 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABpXNPm2 : rk(A :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpXNPmtmp : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABBpXNPeq HOoABBpXNPm3).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: Bp :: X :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: X :: N :: P :: nil) (Oo :: A :: B :: Bp :: A :: Bp :: X :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: Bp :: X :: N :: P :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: Bp :: X :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpXNPmtmp;try rewrite HT2 in HOoABBpXNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: Bp :: X :: N :: P :: nil) (A :: Bp :: nil) 3 2 3 HOoABBpXNPmtmp HABpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpXNPM1. try clear HOoABBpXNPM2. try clear HOoABBpXNPM3. try clear HOoABBpXNPm4. try clear HOoABBpXNPm3. try clear HOoABBpXNPm2. try clear HOoABBpXNPm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABpXNPM3 : rk(A :: Bp :: X :: N :: P :: nil) <= 3).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: X :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: X :: N :: P :: nil) (A :: Bp :: X :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: X :: Bp :: N :: P :: nil) ((A :: Bp :: X :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Bp :: X :: nil) (Bp :: N :: P :: nil) (Bp :: nil) 2 2 1 HABpXMtmp HBpNPMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpXNPm3 : rk(A :: Bp :: X :: N :: P :: nil) >= 3).
{
	try assert(HABpNeq : rk(A :: Bp :: N :: nil) = 3) by (apply LABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpNmtmp : rk(A :: Bp :: N :: nil) >= 3) by (solve_hyps_min HABpNeq HABpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: N :: nil) (A :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: N :: nil) (A :: Bp :: X :: N :: P :: nil) 3 3 HABpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AXNP requis par la preuve de (?)AXNP pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ANP requis par la preuve de (?)AXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour NP requis par la preuve de (?)ANP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BNPQ requis par la preuve de (?)NP pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABMNPQ requis par la preuve de (?)BNPQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 1 pour P requis par la preuve de (?)BNPQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BNPQ requis par la preuve de (?)BNPQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BNPQ requis par la preuve de (?)BNPQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BNPQ requis par la preuve de (?)BNPQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: M ::   de rang : 3 et 3 *)
assert(HBNPQm2 : rk(B :: N :: P :: Q :: nil) >= 2).
{
	try assert(HABMeq : rk(A :: B :: M :: nil) = 3) by (apply LABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMMtmp : rk(A :: B :: M :: nil) <= 3) by (solve_hyps_max HABMeq HABMM3).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: M :: nil) (B :: N :: P :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: B :: M :: B :: N :: P :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: M :: B :: N :: P :: Q :: nil) ((A :: B :: M :: nil) ++ (B :: N :: P :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: B :: M :: nil) (B :: N :: P :: Q :: nil) (B :: nil) 4 1 3 HABMNPQmtmp HBmtmp HABMMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 5 4 et 5*)
assert(HBNPQM3 : rk(B :: N :: P :: Q :: nil) <= 3).
{
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: N :: P :: Q :: nil) (P :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: B :: N :: Q :: nil) ((P :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HPMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : A :: M :: P ::   de rang : 2 et 2 *)
assert(HBNPQm3 : rk(B :: N :: P :: Q :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (A :: M :: P :: nil) (B :: N :: P :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: M :: P :: B :: N :: P :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: P :: B :: N :: P :: Q :: nil) ((A :: M :: P :: nil) ++ (B :: N :: P :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: M :: P :: nil) (B :: N :: P :: Q :: nil) (P :: nil) 4 1 2 HABMNPQmtmp HPmtmp HAMPMtmp Hincl); apply HT.
}
try clear HPM1. try clear HPM2. try clear HPM3. try clear HPm4. try clear HPm3. try clear HPm2. try clear HPm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NP requis par la preuve de (?)NP pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HNPm2 : rk(N :: P :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(HBNPQmtmp : rk(B :: N :: P :: Q :: nil) >= 3) by (solve_hyps_min HBNPQeq HBNPQm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (N :: P :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: N :: P :: Q :: nil) (N :: P :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: P :: B :: N :: Q :: nil) ((N :: P :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBNPQmtmp;try rewrite HT2 in HBNPQmtmp.
	assert(HT := rule_2 (N :: P :: nil) (B :: N :: Q :: nil) (N :: nil) 3 1 2 HBNPQmtmp HNmtmp HBNQMtmp Hincl);apply HT.
}
try clear HBNPQM1. try clear HBNPQM2. try clear HBNPQM3. try clear HBNPQm4. try clear HBNPQm3. try clear HBNPQm2. try clear HBNPQm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ANP requis par la preuve de (?)ANP pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ANP requis par la preuve de (?)ANP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Bp ::   de rang : 2 et 2 *)
assert(HANPm2 : rk(A :: N :: P :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpMtmp : rk(Oo :: Bp :: nil) <= 2) by (solve_hyps_max HOoBpeq HOoBpM2).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Bp :: nil) (A :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Oo :: Bp :: A :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: A :: N :: P :: nil) ((Oo :: Bp :: nil) ++ (A :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_4 (Oo :: Bp :: nil) (A :: N :: P :: nil) (nil) 4 0 2 HOoABpNPmtmp Hmtmp HOoBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HANPm3 : rk(A :: N :: P :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HABpNPeq : rk(A :: Bp :: N :: P :: nil) = 3) by (apply LABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpNPmtmp : rk(A :: Bp :: N :: P :: nil) >= 3) by (solve_hyps_min HABpNPeq HABpNPm3).
	assert(HNPmtmp : rk(N :: P :: nil) >= 2) by (solve_hyps_min HNPeq HNPm2).
	assert(Hincl : incl (N :: P :: nil) (list_inter (A :: N :: P :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: P :: nil) (A :: N :: P :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: N :: P :: Bp :: N :: P :: nil) ((A :: N :: P :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpNPmtmp;try rewrite HT2 in HABpNPmtmp.
	assert(HT := rule_2 (A :: N :: P :: nil) (Bp :: N :: P :: nil) (N :: P :: nil) 3 2 2 HABpNPmtmp HNPmtmp HBpNPMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AXNP requis par la preuve de (?)AXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXNP requis par la preuve de (?)AXNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXNP requis par la preuve de (?)OoABXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXNP requis par la preuve de (?)OoABXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXNPm2 : rk(Oo :: A :: B :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXNPm3 : rk(Oo :: A :: B :: X :: N :: P :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: N :: P :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AXNP requis par la preuve de (?)AXNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: N :: P ::  de rang :  3 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HAXNPm2 : rk(A :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXNPmtmp : rk(Oo :: A :: B :: X :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABXNPeq HOoABXNPm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (A :: X :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: N :: P :: nil) (Oo :: A :: B :: X :: A :: X :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: A :: X :: N :: P :: nil) ((Oo :: A :: B :: X :: nil) ++ (A :: X :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXNPmtmp;try rewrite HT2 in HOoABXNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (A :: X :: N :: P :: nil) (A :: X :: nil) 3 2 3 HOoABXNPmtmp HAXmtmp HOoABXMtmp Hincl); apply HT.
}
try clear HOoABXNPM1. try clear HOoABXNPM2. try clear HOoABXNPM3. try clear HOoABXNPm4. try clear HOoABXNPm3. try clear HOoABXNPm2. try clear HOoABXNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAXNPm3 : rk(A :: X :: N :: P :: nil) >= 3).
{
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: N :: P :: nil) (A :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: N :: P :: nil) (A :: X :: N :: P :: nil) 3 3 HANPmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAXNPM3 : rk(A :: X :: N :: P :: nil) <= 3).
{
	assert(HABpXNPMtmp : rk(A :: Bp :: X :: N :: P :: nil) <= 3) by (solve_hyps_max HABpXNPeq HABpXNPM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: X :: N :: P :: nil) (A :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: X :: N :: P :: nil) (A :: Bp :: X :: N :: P :: nil) 3 3 HABpXNPMtmp Hcomp Hincl);apply HT.
}
try clear HABpXNPM1. try clear HABpXNPM2. try clear HABpXNPM3. try clear HABpXNPm4. try clear HABpXNPm3. try clear HABpXNPm2. try clear HABpXNPm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour AMNP requis par la preuve de (?)AXMNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AMNP requis par la preuve de (?)AMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AMNP requis par la preuve de (?)AMNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABMNP requis par la preuve de (?)AMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMNP requis par la preuve de (?)OoABMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMNP requis par la preuve de (?)OoABMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMNPm2 : rk(Oo :: A :: B :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMNPm3 : rk(Oo :: A :: B :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: N :: P :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AMNP requis par la preuve de (?)AMNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: M :: N :: P ::  de rang :  3 et 4 	 AiB : A :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HAMNPm2 : rk(A :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	assert(HOoABMNPmtmp : rk(Oo :: A :: B :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABMNPeq HOoABMNPm3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: N :: P :: nil) (Oo :: A :: B :: M :: A :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: M :: N :: P :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABMNPmtmp;try rewrite HT2 in HOoABMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: M :: N :: P :: nil) (A :: M :: nil) 3 2 3 HOoABMNPmtmp HAMmtmp HOoABMMtmp Hincl); apply HT.
}
try clear HOoABMNPM1. try clear HOoABMNPM2. try clear HOoABMNPM3. try clear HOoABMNPm4. try clear HOoABMNPm3. try clear HOoABMNPm2. try clear HOoABMNPm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAMNPM3 : rk(A :: M :: N :: P :: nil) <= 3).
{
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (N :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: M :: N :: P :: nil) (N :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: A :: M :: P :: nil) ((N :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (N :: nil) (A :: M :: P :: nil) (nil) 1 2 0 HNMtmp HAMPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAMNPm3 : rk(A :: M :: N :: P :: nil) >= 3).
{
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: N :: P :: nil) (A :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: N :: P :: nil) (A :: M :: N :: P :: nil) 3 3 HANPmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AXMNP requis par la preuve de (?)AXMNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AXMNP requis par la preuve de (?)AXMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMNP requis par la preuve de (?)AXMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMNP requis par la preuve de (?)OoABXMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMNP requis par la preuve de (?)OoABXMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNPm2 : rk(Oo :: A :: B :: X :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNPm3 : rk(Oo :: A :: B :: X :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AXMNP requis par la preuve de (?)AXMNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: N :: P ::  de rang :  3 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HAXMNPm2 : rk(A :: X :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXMNPmtmp : rk(Oo :: A :: B :: X :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABXMNPeq HOoABXMNPm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: N :: P :: nil) (Oo :: A :: B :: X :: A :: X :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: A :: X :: M :: N :: P :: nil) ((Oo :: A :: B :: X :: nil) ++ (A :: X :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMNPmtmp;try rewrite HT2 in HOoABXMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: P :: nil) (A :: X :: nil) 3 2 3 HOoABXMNPmtmp HAXmtmp HOoABXMtmp Hincl); apply HT.
}
try clear HOoABXMNPM1. try clear HOoABXMNPM2. try clear HOoABXMNPM3. try clear HOoABXMNPm4. try clear HOoABXMNPm3. try clear HOoABXMNPm2. try clear HOoABXMNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAXMNPm3 : rk(A :: X :: M :: N :: P :: nil) >= 3).
{
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: N :: P :: nil) (A :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: N :: P :: nil) (A :: X :: M :: N :: P :: nil) 3 3 HANPmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 5 5 et 5*)
assert(HAXMNPM3 : rk(A :: X :: M :: N :: P :: nil) <= 3).
{
	assert(HAXNPMtmp : rk(A :: X :: N :: P :: nil) <= 3) by (solve_hyps_max HAXNPeq HAXNPM3).
	assert(HAMNPMtmp : rk(A :: M :: N :: P :: nil) <= 3) by (solve_hyps_max HAMNPeq HAMNPM3).
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hincl : incl (A :: N :: P :: nil) (list_inter (A :: X :: N :: P :: nil) (A :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: X :: M :: N :: P :: nil) (A :: X :: N :: P :: A :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: X :: N :: P :: A :: M :: N :: P :: nil) ((A :: X :: N :: P :: nil) ++ (A :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: X :: N :: P :: nil) (A :: M :: N :: P :: nil) (A :: N :: P :: nil) 3 3 3 HAXNPMtmp HAMNPMtmp HANPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HAXNPM1. try clear HAXNPM2. try clear HAXNPM3. try clear HAXNPm4. try clear HAXNPm3. try clear HAXNPm2. try clear HAXNPm1. try clear HAMNPM1. try clear HAMNPM2. try clear HAMNPM3. try clear HAMNPm4. try clear HAMNPm3. try clear HAMNPm2. try clear HAMNPm1. try clear HANPM1. try clear HANPM2. try clear HANPM3. try clear HANPm4. try clear HANPm3. try clear HANPm2. try clear HANPm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)AXMN pour la règle 3  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm2 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm3 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)AXMN pour la règle 3  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoANP requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoANP requis par la preuve de (?)OoANP pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoANP requis par la preuve de (?)OoANP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoANP requis par la preuve de (?)OoANP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANPm2 : rk(Oo :: A :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoANPm3 : rk(Oo :: A :: N :: P :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: A :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Bp :: Oo :: A :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: A :: N :: P :: nil) ((Bp :: nil) ++ (Oo :: A :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: A :: N :: P :: nil) (nil) 4 0 1 HOoABpNPmtmp Hmtmp HBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HOoANPm4 : rk(Oo :: A :: N :: P :: nil) >= 4).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	assert(HNPmtmp : rk(N :: P :: nil) >= 2) by (solve_hyps_min HNPeq HNPm2).
	assert(Hincl : incl (N :: P :: nil) (list_inter (Oo :: A :: N :: P :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Oo :: A :: N :: P :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: P :: Bp :: N :: P :: nil) ((Oo :: A :: N :: P :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_2 (Oo :: A :: N :: P :: nil) (Bp :: N :: P :: nil) (N :: P :: nil) 4 2 2 HOoABpNPmtmp HNPmtmp HBpNPMtmp Hincl);apply HT.
}
try clear HNPM1. try clear HNPM2. try clear HNPM3. try clear HNPm4. try clear HNPm3. try clear HNPm2. try clear HNPm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNPQm2 : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNPQm3 : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HOoAXMNPQm4 : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 4).
{
	assert(HOoANPmtmp : rk(Oo :: A :: N :: P :: nil) >= 4) by (solve_hyps_min HOoANPeq HOoANPm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: P :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: P :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil) 4 4 HOoANPmtmp Hcomp Hincl);apply HT.
}
try clear HOoANPM1. try clear HOoANPM2. try clear HOoANPM3. try clear HOoANPm4. try clear HOoANPm3. try clear HOoANPm2. try clear HOoANPm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AXMN requis par la preuve de (?)AXMN pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMN requis par la preuve de (?)AXMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMN requis par la preuve de (?)OoABXMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMN requis par la preuve de (?)OoABXMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNm2 : rk(Oo :: A :: B :: X :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNm3 : rk(Oo :: A :: B :: X :: M :: N :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AXMN requis par la preuve de (?)AXMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: N ::  de rang :  3 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HAXMNm2 : rk(A :: X :: M :: N :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXMNmtmp : rk(Oo :: A :: B :: X :: M :: N :: nil) >= 3) by (solve_hyps_min HOoABXMNeq HOoABXMNm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: N :: nil) (Oo :: A :: B :: X :: A :: X :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: A :: X :: M :: N :: nil) ((Oo :: A :: B :: X :: nil) ++ (A :: X :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMNmtmp;try rewrite HT2 in HOoABXMNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: nil) (A :: X :: nil) 3 2 3 HOoABXMNmtmp HAXmtmp HOoABXMtmp Hincl); apply HT.
}
try clear HOoABXMNM1. try clear HOoABXMNM2. try clear HOoABXMNM3. try clear HOoABXMNm4. try clear HOoABXMNm3. try clear HOoABXMNm2. try clear HOoABXMNm1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 5 5 et 5*)
assert(HAXMNM3 : rk(A :: X :: M :: N :: nil) <= 3).
{
	assert(HAXMNPMtmp : rk(A :: X :: M :: N :: P :: nil) <= 3) by (solve_hyps_max HAXMNPeq HAXMNPM3).
	assert(HOoAXMNQMtmp : rk(Oo :: A :: X :: M :: N :: Q :: nil) <= 4) by (solve_hyps_max HOoAXMNQeq HOoAXMNQM4).
	assert(HOoAXMNPQmtmp : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HOoAXMNPQeq HOoAXMNPQm4).
	assert(Hincl : incl (A :: X :: M :: N :: nil) (list_inter (A :: X :: M :: N :: P :: nil) (Oo :: A :: X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: X :: M :: N :: P :: Q :: nil) (A :: X :: M :: N :: P :: Oo :: A :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: X :: M :: N :: P :: Oo :: A :: X :: M :: N :: Q :: nil) ((A :: X :: M :: N :: P :: nil) ++ (Oo :: A :: X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAXMNPQmtmp;try rewrite HT2 in HOoAXMNPQmtmp.
	assert(HT := rule_3 (A :: X :: M :: N :: P :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) (A :: X :: M :: N :: nil) 3 4 4 HAXMNPMtmp HOoAXMNQMtmp HOoAXMNPQmtmp Hincl);apply HT.
}
try clear HAXMNPM1. try clear HAXMNPM2. try clear HAXMNPM3. try clear HAXMNPm4. try clear HAXMNPm3. try clear HAXMNPm2. try clear HAXMNPm1. try clear HOoAXMNPQM1. try clear HOoAXMNPQM2. try clear HOoAXMNPQM3. try clear HOoAXMNPQm4. try clear HOoAXMNPQm3. try clear HOoAXMNPQm2. try clear HOoAXMNPQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: X :: M :: N ::  de rang :  4 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: X ::   de rang : 3 et 3 *)
assert(HAXMNm3 : rk(A :: X :: M :: N :: nil) >= 3).
{
	try assert(HOoAApXeq : rk(Oo :: A :: Ap :: X :: nil) = 3) by (apply LOoAApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApXMtmp : rk(Oo :: A :: Ap :: X :: nil) <= 3) by (solve_hyps_max HOoAApXeq HOoAApXM3).
	try assert(HOoAApXMNeq : rk(Oo :: A :: Ap :: X :: M :: N :: nil) = 4) by (apply LOoAApXMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApXMNmtmp : rk(Oo :: A :: Ap :: X :: M :: N :: nil) >= 4) by (solve_hyps_min HOoAApXMNeq HOoAApXMNm4).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: Ap :: X :: nil) (A :: X :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: X :: M :: N :: nil) (Oo :: A :: Ap :: X :: A :: X :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: X :: A :: X :: M :: N :: nil) ((Oo :: A :: Ap :: X :: nil) ++ (A :: X :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApXMNmtmp;try rewrite HT2 in HOoAApXMNmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: X :: nil) (A :: X :: M :: N :: nil) (A :: X :: nil) 4 2 3 HOoAApXMNmtmp HAXmtmp HOoAApXMtmp Hincl); apply HT.
}


assert(HAXMNM : rk(A :: X :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAXMNm : rk(A :: X :: M :: N ::  nil) >= 1) by (solve_hyps_min HAXMNeq HAXMNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LXMN *)
(* dans constructLemma(), requis par LXMNQ *)
(* dans constructLemma(), requis par LBXMNQ *)
(* dans constructLemma(), requis par LBXMQ *)
(* dans la couche 0 *)
Lemma LBApXMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Ap :: X :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApXMQ requis par la preuve de (?)BApXMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApXMQ requis par la preuve de (?)BApXMQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApXMQ requis par la preuve de (?)BApXMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApXMQ requis par la preuve de (?)OoABApXMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApXMQ requis par la preuve de (?)OoABApXMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXMQm2 : rk(Oo :: A :: B :: Ap :: X :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: X :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXMQm3 : rk(Oo :: A :: B :: Ap :: X :: M :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: M :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApXMQ requis par la preuve de (?)BApXMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: M :: Q ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApXMQm2 : rk(B :: Ap :: X :: M :: Q :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApXMQmtmp : rk(Oo :: A :: B :: Ap :: X :: M :: Q :: nil) >= 3) by (solve_hyps_min HOoABApXMQeq HOoABApXMQm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: X :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: M :: Q :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: X :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: X :: M :: Q :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: X :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXMQmtmp;try rewrite HT2 in HOoABApXMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: X :: M :: Q :: nil) (B :: Ap :: nil) 3 2 3 HOoABApXMQmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApXMQM1. try clear HOoABApXMQM2. try clear HOoABApXMQM3. try clear HOoABApXMQm4. try clear HOoABApXMQm3. try clear HOoABApXMQm2. try clear HOoABApXMQm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBApXMQM3 : rk(B :: Ap :: X :: M :: Q :: nil) <= 3).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: X :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: X :: M :: Q :: nil) (B :: Ap :: X :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: Ap :: M :: Q :: nil) ((B :: Ap :: X :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Ap :: X :: nil) (Ap :: M :: Q :: nil) (Ap :: nil) 2 2 1 HBApXMtmp HApMQMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApXMQm3 : rk(B :: Ap :: X :: M :: Q :: nil) >= 3).
{
	try assert(HBApMeq : rk(B :: Ap :: M :: nil) = 3) by (apply LBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMmtmp : rk(B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HBApMeq HBApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: M :: nil) (B :: Ap :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: M :: nil) (B :: Ap :: X :: M :: Q :: nil) 3 3 HBApMmtmp Hcomp Hincl);apply HT.
}


assert(HBApXMQM : rk(B :: Ap :: X :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApXMQm : rk(B :: Ap :: X :: M :: Q ::  nil) >= 1) by (solve_hyps_min HBApXMQeq HBApXMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBXMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: X :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BXMQ requis par la preuve de (?)BXMQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BMQ requis par la preuve de (?)BXMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour MQ requis par la preuve de (?)BMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BMNQ requis par la preuve de (?)MQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABMNPQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBMNQM3 : rk(B :: M :: N :: Q :: nil) <= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: B :: N :: Q :: nil) ((M :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (M :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HMMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBMNQm2 : rk(B :: M :: N :: Q :: nil) >= 2).
{
	try assert(HBMeq : rk(B :: M :: nil) = 2) by (apply LBM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMmtmp : rk(B :: M :: nil) >= 2) by (solve_hyps_min HBMeq HBMm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: M :: nil) (B :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: M :: nil) (B :: M :: N :: Q :: nil) 2 2 HBMmtmp Hcomp Hincl);apply HT.
}
try clear HBMM1. try clear HBMM2. try clear HBMM3. try clear HBMm4. try clear HBMm3. try clear HBMm2. try clear HBMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : A :: M :: P ::   de rang : 2 et 2 *)
assert(HBMNQm3 : rk(B :: M :: N :: Q :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: P :: nil) (B :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: M :: P :: B :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: P :: B :: M :: N :: Q :: nil) ((A :: M :: P :: nil) ++ (B :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: M :: P :: nil) (B :: M :: N :: Q :: nil) (M :: nil) 4 1 2 HABMNPQmtmp HMmtmp HAMPMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 1 pour Q requis par la preuve de (?)MQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MQ requis par la preuve de (?)MQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 4*)
assert(HMQm2 : rk(M :: Q :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(HBMNQmtmp : rk(B :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HBMNQeq HBMNQm3).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (M :: Q :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: Q :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Q :: B :: N :: Q :: nil) ((M :: Q :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBMNQmtmp;try rewrite HT2 in HBMNQmtmp.
	assert(HT := rule_2 (M :: Q :: nil) (B :: N :: Q :: nil) (Q :: nil) 3 1 2 HBMNQmtmp HQmtmp HBNQMtmp Hincl);apply HT.
}
try clear HBMNQM1. try clear HBMNQM2. try clear HBMNQM3. try clear HBMNQm4. try clear HBMNQm3. try clear HBMNQm2. try clear HBMNQm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMQ requis par la preuve de (?)BMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMQ requis par la preuve de (?)BMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HBMQm2 : rk(B :: M :: Q :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoBApMQeq : rk(Oo :: B :: Ap :: M :: Q :: nil) = 4) by (apply LOoBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApMQmtmp : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBApMQeq HOoBApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (B :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Q :: nil) (Oo :: Ap :: B :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: B :: M :: Q :: nil) ((Oo :: Ap :: nil) ++ (B :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMQmtmp;try rewrite HT2 in HOoBApMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (B :: M :: Q :: nil) (nil) 4 0 2 HOoBApMQmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HBMQm3 : rk(B :: M :: Q :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBApMQeq : rk(B :: Ap :: M :: Q :: nil) = 3) by (apply LBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMQmtmp : rk(B :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBApMQeq HBApMQm3).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (B :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: M :: Q :: Ap :: M :: Q :: nil) ((B :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQmtmp;try rewrite HT2 in HBApMQmtmp.
	assert(HT := rule_2 (B :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 3 2 2 HBApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BXMQ requis par la preuve de (?)BXMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMQ requis par la preuve de (?)BXMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMQ requis par la preuve de (?)OoABXMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMQ requis par la preuve de (?)OoABXMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMQm2 : rk(Oo :: A :: B :: X :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMQm3 : rk(Oo :: A :: B :: X :: M :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BXMQ requis par la preuve de (?)BXMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: Q ::  de rang :  3 et 4 	 AiB : B :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HBXMQm2 : rk(B :: X :: M :: Q :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXMQmtmp : rk(Oo :: A :: B :: X :: M :: Q :: nil) >= 3) by (solve_hyps_min HOoABXMQeq HOoABXMQm3).
	try assert(HBXeq : rk(B :: X :: nil) = 2) by (apply LBX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBXmtmp : rk(B :: X :: nil) >= 2) by (solve_hyps_min HBXeq HBXm2).
	assert(Hincl : incl (B :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (B :: X :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: Q :: nil) (Oo :: A :: B :: X :: B :: X :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: B :: X :: M :: Q :: nil) ((Oo :: A :: B :: X :: nil) ++ (B :: X :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMQmtmp;try rewrite HT2 in HOoABXMQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (B :: X :: M :: Q :: nil) (B :: X :: nil) 3 2 3 HOoABXMQmtmp HBXmtmp HOoABXMtmp Hincl); apply HT.
}
try clear HOoABXMQM1. try clear HOoABXMQM2. try clear HOoABXMQM3. try clear HOoABXMQm4. try clear HOoABXMQm3. try clear HOoABXMQm2. try clear HOoABXMQm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HBXMQm3 : rk(B :: X :: M :: Q :: nil) >= 3).
{
	assert(HBMQmtmp : rk(B :: M :: Q :: nil) >= 3) by (solve_hyps_min HBMQeq HBMQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: M :: Q :: nil) (B :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: M :: Q :: nil) (B :: X :: M :: Q :: nil) 3 3 HBMQmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBXMQM3 : rk(B :: X :: M :: Q :: nil) <= 3).
{
	try assert(HBApXMQeq : rk(B :: Ap :: X :: M :: Q :: nil) = 3) by (apply LBApXMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMQMtmp : rk(B :: Ap :: X :: M :: Q :: nil) <= 3) by (solve_hyps_max HBApXMQeq HBApXMQM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: X :: M :: Q :: nil) (B :: Ap :: X :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: X :: M :: Q :: nil) (B :: Ap :: X :: M :: Q :: nil) 3 3 HBApXMQMtmp Hcomp Hincl);apply HT.
}


assert(HBXMQM : rk(B :: X :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBXMQm : rk(B :: X :: M :: Q ::  nil) >= 1) by (solve_hyps_min HBXMQeq HBXMQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBXMNQ *)
(* dans constructLemma(), requis par LBQ *)
(* dans la couche 0 *)
Lemma LQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Q ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HQM : rk(Q ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HQeq HQM1).
assert(HQm : rk(Q ::  nil) >= 1) by (solve_hyps_min HQeq HQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BQ requis par la preuve de (?)BQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBQm2 : rk(B :: Q :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBApMQeq : rk(B :: Ap :: M :: Q :: nil) = 3) by (apply LBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMQmtmp : rk(B :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBApMQeq HBApMQm3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (B :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: Ap :: M :: Q :: nil) ((B :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQmtmp;try rewrite HT2 in HBApMQmtmp.
	assert(HT := rule_2 (B :: Q :: nil) (Ap :: M :: Q :: nil) (Q :: nil) 3 1 2 HBApMQmtmp HQmtmp HApMQMtmp Hincl);apply HT.
}


assert(HBQM : rk(B :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBQeq HBQM2).
assert(HBQm : rk(B :: Q ::  nil) >= 1) by (solve_hyps_min HBQeq HBQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBXMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: X :: M :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BXMNQ requis par la preuve de (?)BXMNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BMQ requis par la preuve de (?)BXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour MQ requis par la preuve de (?)BMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BMNQ requis par la preuve de (?)MQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABMNPQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBMNQM3 : rk(B :: M :: N :: Q :: nil) <= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: B :: N :: Q :: nil) ((M :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (M :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HMMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBMNQm2 : rk(B :: M :: N :: Q :: nil) >= 2).
{
	try assert(HBMeq : rk(B :: M :: nil) = 2) by (apply LBM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMmtmp : rk(B :: M :: nil) >= 2) by (solve_hyps_min HBMeq HBMm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: M :: nil) (B :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: M :: nil) (B :: M :: N :: Q :: nil) 2 2 HBMmtmp Hcomp Hincl);apply HT.
}
try clear HBMM1. try clear HBMM2. try clear HBMM3. try clear HBMm4. try clear HBMm3. try clear HBMm2. try clear HBMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : A :: M :: P ::   de rang : 2 et 2 *)
assert(HBMNQm3 : rk(B :: M :: N :: Q :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: P :: nil) (B :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: M :: P :: B :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: P :: B :: M :: N :: Q :: nil) ((A :: M :: P :: nil) ++ (B :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: M :: P :: nil) (B :: M :: N :: Q :: nil) (M :: nil) 4 1 2 HABMNPQmtmp HMmtmp HAMPMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MQ requis par la preuve de (?)MQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HMQm2 : rk(M :: Q :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(HBMNQmtmp : rk(B :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HBMNQeq HBMNQm3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (M :: Q :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: Q :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Q :: B :: N :: Q :: nil) ((M :: Q :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBMNQmtmp;try rewrite HT2 in HBMNQmtmp.
	assert(HT := rule_2 (M :: Q :: nil) (B :: N :: Q :: nil) (Q :: nil) 3 1 2 HBMNQmtmp HQmtmp HBNQMtmp Hincl);apply HT.
}
try clear HBMNQM1. try clear HBMNQM2. try clear HBMNQM3. try clear HBMNQm4. try clear HBMNQm3. try clear HBMNQm2. try clear HBMNQm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMQ requis par la preuve de (?)BMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMQ requis par la preuve de (?)BMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HBMQm2 : rk(B :: M :: Q :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoBApMQeq : rk(Oo :: B :: Ap :: M :: Q :: nil) = 4) by (apply LOoBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApMQmtmp : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBApMQeq HOoBApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (B :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Q :: nil) (Oo :: Ap :: B :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: B :: M :: Q :: nil) ((Oo :: Ap :: nil) ++ (B :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMQmtmp;try rewrite HT2 in HOoBApMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (B :: M :: Q :: nil) (nil) 4 0 2 HOoBApMQmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 4*)
assert(HBMQm3 : rk(B :: M :: Q :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBApMQeq : rk(B :: Ap :: M :: Q :: nil) = 3) by (apply LBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMQmtmp : rk(B :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBApMQeq HBApMQm3).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (B :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: M :: Q :: Ap :: M :: Q :: nil) ((B :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQmtmp;try rewrite HT2 in HBApMQmtmp.
	assert(HT := rule_2 (B :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 3 2 2 HBApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BXMNQ requis par la preuve de (?)BXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)BXMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm2 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm3 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BXMNQ requis par la preuve de (?)BXMNQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: N :: Q ::  de rang :  3 et 4 	 AiB : B :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HBXMNQm2 : rk(B :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXMNQmtmp : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoABXMNQeq HOoABXMNQm3).
	try assert(HBXeq : rk(B :: X :: nil) = 2) by (apply LBX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBXmtmp : rk(B :: X :: nil) >= 2) by (solve_hyps_min HBXeq HBXm2).
	assert(Hincl : incl (B :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (B :: X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: N :: Q :: nil) (Oo :: A :: B :: X :: B :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: B :: X :: M :: N :: Q :: nil) ((Oo :: A :: B :: X :: nil) ++ (B :: X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMNQmtmp;try rewrite HT2 in HOoABXMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (B :: X :: M :: N :: Q :: nil) (B :: X :: nil) 3 2 3 HOoABXMNQmtmp HBXmtmp HOoABXMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HBXMNQm3 : rk(B :: X :: M :: N :: Q :: nil) >= 3).
{
	assert(HBMQmtmp : rk(B :: M :: Q :: nil) >= 3) by (solve_hyps_min HBMQeq HBMQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: M :: Q :: nil) (B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: M :: Q :: nil) (B :: X :: M :: N :: Q :: nil) 3 3 HBMQmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBXMNQM3 : rk(B :: X :: M :: N :: Q :: nil) <= 3).
{
	try assert(HBXMQeq : rk(B :: X :: M :: Q :: nil) = 3) by (apply LBXMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBXMQMtmp : rk(B :: X :: M :: Q :: nil) <= 3) by (solve_hyps_max HBXMQeq HBXMQM3).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBQmtmp : rk(B :: Q :: nil) >= 2) by (solve_hyps_min HBQeq HBQm2).
	assert(Hincl : incl (B :: Q :: nil) (list_inter (B :: X :: M :: Q :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: X :: M :: N :: Q :: nil) (B :: X :: M :: Q :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: X :: M :: Q :: B :: N :: Q :: nil) ((B :: X :: M :: Q :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: X :: M :: Q :: nil) (B :: N :: Q :: nil) (B :: Q :: nil) 3 2 2 HBXMQMtmp HBNQMtmp HBQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HBQM1. try clear HBQM2. try clear HBQM3. try clear HBQm4. try clear HBQm3. try clear HBQm2. try clear HBQm1. 

assert(HBXMNQM : rk(B :: X :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBXMNQm : rk(B :: X :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HBXMNQeq HBXMNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LXMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(X :: M :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour XMNQ requis par la preuve de (?)XMNQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQm2 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoAApMQm3 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (C :: Oo :: A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: M :: Q :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Ap :: M :: Q :: nil) (nil) 4 0 1 HOoACApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoAApMQm4 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Oo :: A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: nil) 4 2 2 HOoACApMQmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour MQ requis par la preuve de (?)OoAMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BMNQ requis par la preuve de (?)MQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABMNPQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBMNQM3 : rk(B :: M :: N :: Q :: nil) <= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: B :: N :: Q :: nil) ((M :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (M :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HMMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBMNQm2 : rk(B :: M :: N :: Q :: nil) >= 2).
{
	try assert(HBMeq : rk(B :: M :: nil) = 2) by (apply LBM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMmtmp : rk(B :: M :: nil) >= 2) by (solve_hyps_min HBMeq HBMm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: M :: nil) (B :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: M :: nil) (B :: M :: N :: Q :: nil) 2 2 HBMmtmp Hcomp Hincl);apply HT.
}
try clear HBMM1. try clear HBMM2. try clear HBMM3. try clear HBMm4. try clear HBMm3. try clear HBMm2. try clear HBMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : A :: M :: P ::   de rang : 2 et 2 *)
assert(HBMNQm3 : rk(B :: M :: N :: Q :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: P :: nil) (B :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: M :: P :: B :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: P :: B :: M :: N :: Q :: nil) ((A :: M :: P :: nil) ++ (B :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: M :: P :: nil) (B :: M :: N :: Q :: nil) (M :: nil) 4 1 2 HABMNPQmtmp HMmtmp HAMPMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MQ requis par la preuve de (?)MQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HMQm2 : rk(M :: Q :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(HBMNQmtmp : rk(B :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HBMNQeq HBMNQm3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (M :: Q :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: Q :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Q :: B :: N :: Q :: nil) ((M :: Q :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBMNQmtmp;try rewrite HT2 in HBMNQmtmp.
	assert(HT := rule_2 (M :: Q :: nil) (B :: N :: Q :: nil) (Q :: nil) 3 1 2 HBMNQmtmp HQmtmp HBNQMtmp Hincl);apply HT.
}
try clear HBMNQM1. try clear HBMNQM2. try clear HBMNQM3. try clear HBMNQm4. try clear HBMNQm3. try clear HBMNQm2. try clear HBMNQm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAMQm2 : rk(Oo :: A :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoAMQm3 : rk(Oo :: A :: M :: Q :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HOoAApMQmtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAApMQeq HOoAApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: nil) (Ap :: Oo :: A :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: M :: Q :: nil) ((Ap :: nil) ++ (Oo :: A :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQmtmp;try rewrite HT2 in HOoAApMQmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: M :: Q :: nil) (nil) 4 0 1 HOoAApMQmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 4*)
assert(HOoAMQm4 : rk(Oo :: A :: M :: Q :: nil) >= 4).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(HOoAApMQmtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAApMQeq HOoAApMQm4).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (Oo :: A :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: M :: Q :: Ap :: M :: Q :: nil) ((Oo :: A :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQmtmp;try rewrite HT2 in HOoAApMQmtmp.
	assert(HT := rule_2 (Oo :: A :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 4 2 2 HOoAApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm2 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm3 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HOoAXMNQm4 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 4).
{
	assert(HOoAMQmtmp : rk(Oo :: A :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAMQeq HOoAMQm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: Q :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: Q :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 4 4 HOoAMQmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour NQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ApMNQ requis par la preuve de (?)NQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ApBpMNPQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMNQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMNQ requis par la preuve de (?)ApMNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMNQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMNQm2 : rk(Ap :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMNQmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoABApMNQeq HOoABApMNQm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Q :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQmtmp;try rewrite HT2 in HOoABApMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Q :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMNQmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HApMM1. try clear HApMM2. try clear HApMM3. try clear HApMm4. try clear HApMm3. try clear HApMm2. try clear HApMm1. try clear HOoABApMNQM1. try clear HOoABApMNQM2. try clear HOoABApMNQM3. try clear HOoABApMNQm4. try clear HOoABApMNQm3. try clear HOoABApMNQm2. try clear HOoABApMNQm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApMNQM3 : rk(Ap :: M :: N :: Q :: nil) <= 3).
{
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (N :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: N :: Q :: nil) (N :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: Ap :: M :: Q :: nil) ((N :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (N :: nil) (Ap :: M :: Q :: nil) (nil) 1 2 0 HNMtmp HApMQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : N ::  de rang :  1 et 1 	 A : Bp :: N :: P ::   de rang : 2 et 2 *)
assert(HApMNQm3 : rk(Ap :: M :: N :: Q :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	assert(HApBpMNPQmtmp : rk(Ap :: Bp :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HApBpMNPQeq HApBpMNPQm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: P :: nil) (Ap :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Q :: nil) (Bp :: N :: P :: Ap :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: P :: Ap :: M :: N :: Q :: nil) ((Bp :: N :: P :: nil) ++ (Ap :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPQmtmp;try rewrite HT2 in HApBpMNPQmtmp.
	assert(HT := rule_4 (Bp :: N :: P :: nil) (Ap :: M :: N :: Q :: nil) (N :: nil) 4 1 2 HApBpMNPQmtmp HNmtmp HBpNPMtmp Hincl); apply HT.
}
try clear HApBpMNPQM1. try clear HApBpMNPQM2. try clear HApBpMNPQM3. try clear HApBpMNPQm4. try clear HApBpMNPQm3. try clear HApBpMNPQm2. try clear HApBpMNPQm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NQ requis par la preuve de (?)NQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Ap :: M :: N :: Q ::  de rang :  3 et 3 	 AiB : Q ::  de rang :  1 et 1 	 A : Ap :: M :: Q ::   de rang : 2 et 2 *)
assert(HNQm2 : rk(N :: Q :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(HApMNQmtmp : rk(Ap :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HApMNQeq HApMNQm3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Ap :: M :: Q :: nil) (N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: N :: Q :: nil) (Ap :: M :: Q :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: N :: Q :: nil) ((Ap :: M :: Q :: nil) ++ (N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApMNQmtmp;try rewrite HT2 in HApMNQmtmp.
	assert(HT := rule_4 (Ap :: M :: Q :: nil) (N :: Q :: nil) (Q :: nil) 3 1 2 HApMNQmtmp HQmtmp HApMQMtmp Hincl); apply HT.
}
try clear HQM1. try clear HQM2. try clear HQM3. try clear HQm4. try clear HQm3. try clear HQm2. try clear HQm1. try clear HApMNQM1. try clear HApMNQM2. try clear HApMNQM3. try clear HApMNQm4. try clear HApMNQm3. try clear HApMNQm2. try clear HApMNQm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoANQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoABNQ requis par la preuve de (?)OoANQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQm2 : rk(Oo :: A :: B :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABNQM3 : rk(Oo :: A :: B :: N :: Q :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: Q :: nil) (Oo :: A :: B :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: N :: Q :: nil) ((Oo :: A :: B :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: N :: Q :: nil) (B :: nil) 2 2 1 HOoABMtmp HBNQMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQm3 : rk(Oo :: A :: B :: N :: Q :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoANQ requis par la preuve de (?)OoANQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoANQ requis par la preuve de (?)OoANQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoANQ requis par la preuve de (?)OoANQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANQm2 : rk(Oo :: A :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANQm3 : rk(Oo :: A :: N :: Q :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: N :: Q :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HOoANQM3 : rk(Oo :: A :: N :: Q :: nil) <= 3).
{
	assert(HOoABNQMtmp : rk(Oo :: A :: B :: N :: Q :: nil) <= 3) by (solve_hyps_max HOoABNQeq HOoABNQM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: Q :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: N :: Q :: nil) (Oo :: A :: B :: N :: Q :: nil) 3 3 HOoABNQMtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour XMNQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm2 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm3 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HOoABXMNQm4 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 4).
{
	assert(HOoAMQmtmp : rk(Oo :: A :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAMQeq HOoAMQm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: Q :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: Q :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 4 4 HOoAMQmtmp Hcomp Hincl);apply HT.
}
try clear HOoAMQM1. try clear HOoAMQM2. try clear HOoAMQM3. try clear HOoAMQm4. try clear HOoAMQm3. try clear HOoAMQm2. try clear HOoAMQm1. 

(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABMQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMQm2 : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApMQm3 : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (C :: Oo :: A :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: M :: Q :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil) (nil) 4 0 1 HOoABCApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABApMQm4 : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMQmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABMQ requis par la preuve de (?)OoABMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMQ requis par la preuve de (?)OoABMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMQ requis par la preuve de (?)OoABMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMQm2 : rk(Oo :: A :: B :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoABMQm3 : rk(Oo :: A :: B :: M :: Q :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HOoABApMQmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABApMQeq HOoABApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: B :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: nil) (Ap :: Oo :: A :: B :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: B :: M :: Q :: nil) ((Ap :: nil) ++ (Oo :: A :: B :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQmtmp;try rewrite HT2 in HOoABApMQmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: B :: M :: Q :: nil) (nil) 4 0 1 HOoABApMQmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 4*)
assert(HOoABMQm4 : rk(Oo :: A :: B :: M :: Q :: nil) >= 4).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(HOoABApMQmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABApMQeq HOoABApMQm4).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (Oo :: A :: B :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: nil) (Oo :: A :: B :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: Q :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQmtmp;try rewrite HT2 in HOoABApMQmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 4 2 2 HOoABApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}
try clear HOoABApMQM1. try clear HOoABApMQM2. try clear HOoABApMQM3. try clear HOoABApMQm4. try clear HOoABApMQm3. try clear HOoABApMQm2. try clear HOoABApMQm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour XMNQ requis par la preuve de (?)XMNQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: N :: Q ::  de rang :  4 et 4 	 AiB : M :: Q ::  de rang :  2 et 2 	 A : Oo :: A :: B :: M :: Q ::   de rang : 4 et 4 *)
assert(HXMNQm2 : rk(X :: M :: N :: Q :: nil) >= 2).
{
	assert(HOoABMQMtmp : rk(Oo :: A :: B :: M :: Q :: nil) <= 4) by (solve_hyps_max HOoABMQeq HOoABMQM4).
	assert(HOoABXMNQmtmp : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoABXMNQeq HOoABXMNQm4).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (Oo :: A :: B :: M :: Q :: nil) (X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: N :: Q :: nil) (Oo :: A :: B :: M :: Q :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: Q :: X :: M :: N :: Q :: nil) ((Oo :: A :: B :: M :: Q :: nil) ++ (X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMNQmtmp;try rewrite HT2 in HOoABXMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: Q :: nil) (X :: M :: N :: Q :: nil) (M :: Q :: nil) 4 2 4 HOoABXMNQmtmp HMQmtmp HOoABMQMtmp Hincl); apply HT.
}
try clear HOoABMQM1. try clear HOoABMQM2. try clear HOoABMQM3. try clear HOoABMQm4. try clear HOoABMQm3. try clear HOoABMQm2. try clear HOoABMQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : Oo :: A :: X :: M :: N :: Q ::  de rang :  4 et 4 	 AiB : N :: Q ::  de rang :  2 et 2 	 A : Oo :: A :: N :: Q ::   de rang : 3 et 3 *)
assert(HXMNQm3 : rk(X :: M :: N :: Q :: nil) >= 3).
{
	assert(HOoANQMtmp : rk(Oo :: A :: N :: Q :: nil) <= 3) by (solve_hyps_max HOoANQeq HOoANQM3).
	assert(HOoAXMNQmtmp : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoAXMNQeq HOoAXMNQm4).
	assert(HNQmtmp : rk(N :: Q :: nil) >= 2) by (solve_hyps_min HNQeq HNQm2).
	assert(Hincl : incl (N :: Q :: nil) (list_inter (Oo :: A :: N :: Q :: nil) (X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: X :: M :: N :: Q :: nil) (Oo :: A :: N :: Q :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: Q :: X :: M :: N :: Q :: nil) ((Oo :: A :: N :: Q :: nil) ++ (X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAXMNQmtmp;try rewrite HT2 in HOoAXMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: N :: Q :: nil) (X :: M :: N :: Q :: nil) (N :: Q :: nil) 4 2 3 HOoAXMNQmtmp HNQmtmp HOoANQMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HXMNQM3 : rk(X :: M :: N :: Q :: nil) <= 3).
{
	try assert(HBXMNQeq : rk(B :: X :: M :: N :: Q :: nil) = 3) by (apply LBXMNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBXMNQMtmp : rk(B :: X :: M :: N :: Q :: nil) <= 3) by (solve_hyps_max HBXMNQeq HBXMNQM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (X :: M :: N :: Q :: nil) (B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (X :: M :: N :: Q :: nil) (B :: X :: M :: N :: Q :: nil) 3 3 HBXMNQMtmp Hcomp Hincl);apply HT.
}


assert(HXMNQM : rk(X :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HXMNQm : rk(X :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HXMNQeq HXMNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LXMN *)
(* dans constructLemma(), requis par LAXMNQ *)
(* dans constructLemma(), requis par LOoAXMNQ *)
(* dans constructLemma(), requis par LOoAMQ *)
(* dans la couche 0 *)
Lemma LOoAApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQm2 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoAApMQm3 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (C :: Oo :: A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: M :: Q :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Ap :: M :: Q :: nil) (nil) 4 0 1 HOoACApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoAApMQm4 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQeq : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoACApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMQmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoACApMQeq HOoACApMQm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Oo :: A :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQmtmp;try rewrite HT2 in HOoACApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: nil) 4 2 2 HOoACApMQmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoAApMQM : rk(Oo :: A :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMQm : rk(Oo :: A :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoAApMQeq HOoAApMQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAMQ *)
(* dans constructLemma(), requis par LMQ *)
(* dans constructLemma(), requis par LBMNQ *)
(* dans la couche 0 *)
Lemma LABMNPQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HABMNPQM : rk(A :: B :: M :: N :: P :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABMNPQm : rk(A :: B :: M :: N :: P :: Q ::  nil) >= 1) by (solve_hyps_min HABMNPQeq HABMNPQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: M :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BMNQ requis par la preuve de (?)BMNQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBMNQM3 : rk(B :: M :: N :: Q :: nil) <= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: B :: N :: Q :: nil) ((M :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (M :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HMMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBMNQm2 : rk(B :: M :: N :: Q :: nil) >= 2).
{
	try assert(HBMeq : rk(B :: M :: nil) = 2) by (apply LBM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMmtmp : rk(B :: M :: nil) >= 2) by (solve_hyps_min HBMeq HBMm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: M :: nil) (B :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: M :: nil) (B :: M :: N :: Q :: nil) 2 2 HBMmtmp Hcomp Hincl);apply HT.
}
try clear HBMM1. try clear HBMM2. try clear HBMM3. try clear HBMm4. try clear HBMm3. try clear HBMm2. try clear HBMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : A :: M :: P ::   de rang : 2 et 2 *)
assert(HBMNQm3 : rk(B :: M :: N :: Q :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HABMNPQeq : rk(A :: B :: M :: N :: P :: Q :: nil) = 4) by (apply LABMNPQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: P :: nil) (B :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: M :: P :: B :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: P :: B :: M :: N :: Q :: nil) ((A :: M :: P :: nil) ++ (B :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: M :: P :: nil) (B :: M :: N :: Q :: nil) (M :: nil) 4 1 2 HABMNPQmtmp HMmtmp HAMPMtmp Hincl); apply HT.
}


assert(HBMNQM : rk(B :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBMNQm : rk(B :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HBMNQeq HBMNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(M :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MQ requis par la preuve de (?)MQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HMQm2 : rk(M :: Q :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBMNQeq : rk(B :: M :: N :: Q :: nil) = 3) by (apply LBMNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBMNQmtmp : rk(B :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HBMNQeq HBMNQm3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (M :: Q :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: M :: N :: Q :: nil) (M :: Q :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Q :: B :: N :: Q :: nil) ((M :: Q :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBMNQmtmp;try rewrite HT2 in HBMNQmtmp.
	assert(HT := rule_2 (M :: Q :: nil) (B :: N :: Q :: nil) (Q :: nil) 3 1 2 HBMNQmtmp HQmtmp HBNQMtmp Hincl);apply HT.
}


assert(HMQM : rk(M :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HMQeq HMQM2).
assert(HMQm : rk(M :: Q ::  nil) >= 1) by (solve_hyps_min HMQeq HMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAMQ requis par la preuve de (?)OoAMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAMQm2 : rk(Oo :: A :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoAMQm3 : rk(Oo :: A :: M :: Q :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMQmtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAApMQeq HOoAApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: nil) (Ap :: Oo :: A :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: M :: Q :: nil) ((Ap :: nil) ++ (Oo :: A :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQmtmp;try rewrite HT2 in HOoAApMQmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: M :: Q :: nil) (nil) 4 0 1 HOoAApMQmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAMQm4 : rk(Oo :: A :: M :: Q :: nil) >= 4).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMQmtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAApMQeq HOoAApMQm4).
	try assert(HMQeq : rk(M :: Q :: nil) = 2) by (apply LMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (Oo :: A :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: M :: Q :: Ap :: M :: Q :: nil) ((Oo :: A :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQmtmp;try rewrite HT2 in HOoAApMQmtmp.
	assert(HT := rule_2 (Oo :: A :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 4 2 2 HOoAApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


assert(HOoAMQM : rk(Oo :: A :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAMQm : rk(Oo :: A :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoAMQeq HOoAMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAXMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: X :: M :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAXMNQ requis par la preuve de (?)OoAXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm2 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm3 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNQm4 : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 4).
{
	try assert(HOoAMQeq : rk(Oo :: A :: M :: Q :: nil) = 4) by (apply LOoAMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMQmtmp : rk(Oo :: A :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAMQeq HOoAMQm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: Q :: nil) (Oo :: A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: Q :: nil) (Oo :: A :: X :: M :: N :: Q :: nil) 4 4 HOoAMQmtmp Hcomp Hincl);apply HT.
}


assert(HOoAXMNQM : rk(Oo :: A :: X :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAXMNQm : rk(Oo :: A :: X :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoAXMNQeq HOoAXMNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAXMNQ *)
(* dans constructLemma(), requis par LANQ *)
(* dans la couche 0 *)
Lemma LABNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABNQ requis par la preuve de (?)ABNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABNQ requis par la preuve de (?)ABNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABNQ requis par la preuve de (?)ABNQ pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABNQM3 : rk(A :: B :: N :: Q :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: N :: Q :: nil) (A :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: N :: Q :: nil) ((A :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HAMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNQm2 : rk(A :: B :: N :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: N :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNQm3 : rk(A :: B :: N :: Q :: nil) >= 3).
{
	try assert(HABNeq : rk(A :: B :: N :: nil) = 3) by (apply LABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABNmtmp : rk(A :: B :: N :: nil) >= 3) by (solve_hyps_min HABNeq HABNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: N :: nil) (A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: N :: nil) (A :: B :: N :: Q :: nil) 3 3 HABNmtmp Hcomp Hincl);apply HT.
}


assert(HABNQM : rk(A :: B :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABNQm : rk(A :: B :: N :: Q ::  nil) >= 1) by (solve_hyps_min HABNQeq HABNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LANQ *)
(* dans constructLemma(), requis par LNQ *)
(* dans constructLemma(), requis par LApMNQ *)
(* dans la couche 0 *)
Lemma LApBpMNPQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HApBpMNPQM : rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpMNPQm : rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) >= 1) by (solve_hyps_min HApBpMNPQeq HApBpMNPQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: M :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMNQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMNQ requis par la preuve de (?)ApMNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMNQ requis par la preuve de (?)ApMNQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMNQm2 : rk(Ap :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMNQmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoABApMNQeq HOoABApMNQm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Q :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQmtmp;try rewrite HT2 in HOoABApMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Q :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMNQmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HApMM1. try clear HApMM2. try clear HApMM3. try clear HApMm4. try clear HApMm3. try clear HApMm2. try clear HApMm1. try clear HOoABApMNQM1. try clear HOoABApMNQM2. try clear HOoABApMNQM3. try clear HOoABApMNQm4. try clear HOoABApMNQm3. try clear HOoABApMNQm2. try clear HOoABApMNQm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApMNQM3 : rk(Ap :: M :: N :: Q :: nil) <= 3).
{
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (N :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: N :: Q :: nil) (N :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: Ap :: M :: Q :: nil) ((N :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (N :: nil) (Ap :: M :: Q :: nil) (nil) 1 2 0 HNMtmp HApMQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : N ::  de rang :  1 et 1 	 A : Bp :: N :: P ::   de rang : 2 et 2 *)
assert(HApMNQm3 : rk(Ap :: M :: N :: Q :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HApBpMNPQeq : rk(Ap :: Bp :: M :: N :: P :: Q :: nil) = 4) by (apply LApBpMNPQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpMNPQmtmp : rk(Ap :: Bp :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HApBpMNPQeq HApBpMNPQm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: P :: nil) (Ap :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Q :: nil) (Bp :: N :: P :: Ap :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: P :: Ap :: M :: N :: Q :: nil) ((Bp :: N :: P :: nil) ++ (Ap :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPQmtmp;try rewrite HT2 in HApBpMNPQmtmp.
	assert(HT := rule_4 (Bp :: N :: P :: nil) (Ap :: M :: N :: Q :: nil) (N :: nil) 4 1 2 HApBpMNPQmtmp HNmtmp HBpNPMtmp Hincl); apply HT.
}
try clear HApBpMNPQM1. try clear HApBpMNPQM2. try clear HApBpMNPQM3. try clear HApBpMNPQm4. try clear HApBpMNPQm3. try clear HApBpMNPQm2. try clear HApBpMNPQm1. 

assert(HApMNQM : rk(Ap :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApMNQm : rk(Ap :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HApMNQeq HApMNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(N :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NQ requis par la preuve de (?)NQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: M :: N :: Q ::  de rang :  3 et 3 	 AiB : Q ::  de rang :  1 et 1 	 A : Ap :: M :: Q ::   de rang : 2 et 2 *)
assert(HNQm2 : rk(N :: Q :: nil) >= 2).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HApMNQeq : rk(Ap :: M :: N :: Q :: nil) = 3) by (apply LApMNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMNQmtmp : rk(Ap :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HApMNQeq HApMNQm3).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Ap :: M :: Q :: nil) (N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: N :: Q :: nil) (Ap :: M :: Q :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: N :: Q :: nil) ((Ap :: M :: Q :: nil) ++ (N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApMNQmtmp;try rewrite HT2 in HApMNQmtmp.
	assert(HT := rule_4 (Ap :: M :: Q :: nil) (N :: Q :: nil) (Q :: nil) 3 1 2 HApMNQmtmp HQmtmp HApMQMtmp Hincl); apply HT.
}
try clear HQM1. try clear HQM2. try clear HQM3. try clear HQm4. try clear HQm3. try clear HQm2. try clear HQm1. 

assert(HNQM : rk(N :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNQeq HNQM2).
assert(HNQm : rk(N :: Q ::  nil) >= 1) by (solve_hyps_min HNQeq HNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LANQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ANQ requis par la preuve de (?)ANQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoABNQ requis par la preuve de (?)ANQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQm2 : rk(Oo :: A :: B :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABNQM3 : rk(Oo :: A :: B :: N :: Q :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: Q :: nil) (Oo :: A :: B :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: N :: Q :: nil) ((Oo :: A :: B :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: N :: Q :: nil) (B :: nil) 2 2 1 HOoABMtmp HBNQMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQm3 : rk(Oo :: A :: B :: N :: Q :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ANQ requis par la preuve de (?)ANQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: N :: Q ::  de rang :  3 et 3 	 AiB : A :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: N ::   de rang : 3 et 3 *)
assert(HANQm2 : rk(A :: N :: Q :: nil) >= 2).
{
	try assert(HOoABNeq : rk(Oo :: A :: B :: N :: nil) = 3) by (apply LOoABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABNMtmp : rk(Oo :: A :: B :: N :: nil) <= 3) by (solve_hyps_max HOoABNeq HOoABNM3).
	assert(HOoABNQmtmp : rk(Oo :: A :: B :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoABNQeq HOoABNQm3).
	try assert(HANeq : rk(A :: N :: nil) = 2) by (apply LAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HANmtmp : rk(A :: N :: nil) >= 2) by (solve_hyps_min HANeq HANm2).
	assert(Hincl : incl (A :: N :: nil) (list_inter (Oo :: A :: B :: N :: nil) (A :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: Q :: nil) (Oo :: A :: B :: N :: A :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: A :: N :: Q :: nil) ((Oo :: A :: B :: N :: nil) ++ (A :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABNQmtmp;try rewrite HT2 in HOoABNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: N :: nil) (A :: N :: Q :: nil) (A :: N :: nil) 3 2 3 HOoABNQmtmp HANmtmp HOoABNMtmp Hincl); apply HT.
}
try clear HANM1. try clear HANM2. try clear HANM3. try clear HANm4. try clear HANm3. try clear HANm2. try clear HANm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HANQm3 : rk(A :: N :: Q :: nil) >= 3).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HABNQeq : rk(A :: B :: N :: Q :: nil) = 3) by (apply LABNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABNQmtmp : rk(A :: B :: N :: Q :: nil) >= 3) by (solve_hyps_min HABNQeq HABNQm3).
	try assert(HNQeq : rk(N :: Q :: nil) = 2) by (apply LNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNQmtmp : rk(N :: Q :: nil) >= 2) by (solve_hyps_min HNQeq HNQm2).
	assert(Hincl : incl (N :: Q :: nil) (list_inter (A :: N :: Q :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: N :: Q :: nil) (A :: N :: Q :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: N :: Q :: B :: N :: Q :: nil) ((A :: N :: Q :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABNQmtmp;try rewrite HT2 in HABNQmtmp.
	assert(HT := rule_2 (A :: N :: Q :: nil) (B :: N :: Q :: nil) (N :: Q :: nil) 3 2 2 HABNQmtmp HNQmtmp HBNQMtmp Hincl);apply HT.
}


assert(HANQM : rk(A :: N :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HANQeq HANQM3).
assert(HANQm : rk(A :: N :: Q ::  nil) >= 1) by (solve_hyps_min HANQeq HANQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAXMNQ *)
(* dans constructLemma(), requis par LOoANQ *)
(* dans la couche 0 *)
Lemma LOoABNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABNQ requis par la preuve de (?)OoABNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQm2 : rk(Oo :: A :: B :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABNQM3 : rk(Oo :: A :: B :: N :: Q :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: Q :: nil) (Oo :: A :: B :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: N :: Q :: nil) ((Oo :: A :: B :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: N :: Q :: nil) (B :: nil) 2 2 1 HOoABMtmp HBNQMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQm3 : rk(Oo :: A :: B :: N :: Q :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


assert(HOoABNQM : rk(Oo :: A :: B :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABNQm : rk(Oo :: A :: B :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoABNQeq HOoABNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoANQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: N :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoANQ requis par la preuve de (?)OoANQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoANQ requis par la preuve de (?)OoANQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoANQ requis par la preuve de (?)OoANQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANQm2 : rk(Oo :: A :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANQm3 : rk(Oo :: A :: N :: Q :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: N :: Q :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANQM3 : rk(Oo :: A :: N :: Q :: nil) <= 3).
{
	try assert(HOoABNQeq : rk(Oo :: A :: B :: N :: Q :: nil) = 3) by (apply LOoABNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABNQMtmp : rk(Oo :: A :: B :: N :: Q :: nil) <= 3) by (solve_hyps_max HOoABNQeq HOoABNQM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: Q :: nil) (Oo :: A :: B :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: N :: Q :: nil) (Oo :: A :: B :: N :: Q :: nil) 3 3 HOoABNQMtmp Hcomp Hincl);apply HT.
}


assert(HOoANQM : rk(Oo :: A :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoANQm : rk(Oo :: A :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoANQeq HOoANQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAXMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: X :: M :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AXMNQ requis par la preuve de (?)AXMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour AMQ requis par la preuve de (?)AXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AMQ requis par la preuve de (?)AMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AMQ requis par la preuve de (?)AMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HAMQm2 : rk(A :: M :: Q :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMQmtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAApMQeq HOoAApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (A :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: Ap :: A :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: A :: M :: Q :: nil) ((Oo :: Ap :: nil) ++ (A :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQmtmp;try rewrite HT2 in HOoAApMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (A :: M :: Q :: nil) (nil) 4 0 2 HOoAApMQmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAMQm3 : rk(A :: M :: Q :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HAApMQeq : rk(A :: Ap :: M :: Q :: nil) = 3) by (apply LAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApMQmtmp : rk(A :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HAApMQeq HAApMQm3).
	try assert(HMQeq : rk(M :: Q :: nil) = 2) by (apply LMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (A :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: nil) (A :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: Q :: Ap :: M :: Q :: nil) ((A :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMQmtmp;try rewrite HT2 in HAApMQmtmp.
	assert(HT := rule_2 (A :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 3 2 2 HAApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AXMNQ requis par la preuve de (?)AXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)AXMNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm2 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm3 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AXMNQ requis par la preuve de (?)AXMNQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: N :: Q ::  de rang :  3 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HAXMNQm2 : rk(A :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXMNQmtmp : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoABXMNQeq HOoABXMNQm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: N :: Q :: nil) (Oo :: A :: B :: X :: A :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: A :: X :: M :: N :: Q :: nil) ((Oo :: A :: B :: X :: nil) ++ (A :: X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMNQmtmp;try rewrite HT2 in HOoABXMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: Q :: nil) (A :: X :: nil) 3 2 3 HOoABXMNQmtmp HAXmtmp HOoABXMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAXMNQm3 : rk(A :: X :: M :: N :: Q :: nil) >= 3).
{
	assert(HAMQmtmp : rk(A :: M :: Q :: nil) >= 3) by (solve_hyps_min HAMQeq HAMQm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: M :: Q :: nil) (A :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: M :: Q :: nil) (A :: X :: M :: N :: Q :: nil) 3 3 HAMQmtmp Hcomp Hincl);apply HT.
}
try clear HAMQM1. try clear HAMQM2. try clear HAMQM3. try clear HAMQm4. try clear HAMQm3. try clear HAMQm2. try clear HAMQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: X :: M :: N :: Q ::  de rang :  4 et 4 	 AiB : A :: N :: Q ::  de rang :  3 et 3 	 A : Oo :: A :: N :: Q ::   de rang : 3 et 3 *)
assert(HAXMNQm4 : rk(A :: X :: M :: N :: Q :: nil) >= 4).
{
	try assert(HOoANQeq : rk(Oo :: A :: N :: Q :: nil) = 3) by (apply LOoANQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANQMtmp : rk(Oo :: A :: N :: Q :: nil) <= 3) by (solve_hyps_max HOoANQeq HOoANQM3).
	try assert(HOoAXMNQeq : rk(Oo :: A :: X :: M :: N :: Q :: nil) = 4) by (apply LOoAXMNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXMNQmtmp : rk(Oo :: A :: X :: M :: N :: Q :: nil) >= 4) by (solve_hyps_min HOoAXMNQeq HOoAXMNQm4).
	try assert(HANQeq : rk(A :: N :: Q :: nil) = 3) by (apply LANQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HANQmtmp : rk(A :: N :: Q :: nil) >= 3) by (solve_hyps_min HANQeq HANQm3).
	assert(Hincl : incl (A :: N :: Q :: nil) (list_inter (Oo :: A :: N :: Q :: nil) (A :: X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: X :: M :: N :: Q :: nil) (Oo :: A :: N :: Q :: A :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: Q :: A :: X :: M :: N :: Q :: nil) ((Oo :: A :: N :: Q :: nil) ++ (A :: X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAXMNQmtmp;try rewrite HT2 in HOoAXMNQmtmp.
	assert(HT := rule_4 (Oo :: A :: N :: Q :: nil) (A :: X :: M :: N :: Q :: nil) (A :: N :: Q :: nil) 4 3 3 HOoAXMNQmtmp HANQmtmp HOoANQMtmp Hincl); apply HT.
}


assert(HAXMNQM : rk(A :: X :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAXMNQm : rk(A :: X :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HAXMNQeq HAXMNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LXMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(X :: M :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour XMN requis par la preuve de (?)XMN pour la règle 3  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour XMN requis par la preuve de (?)XMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: X :: M :: N ::  de rang :  4 et 4 	 AiB : X ::  de rang :  1 et 1 	 A : Oo :: A :: Ap :: X ::   de rang : 3 et 3 *)
assert(HXMNm2 : rk(X :: M :: N :: nil) >= 2).
{
	try assert(HOoAApXeq : rk(Oo :: A :: Ap :: X :: nil) = 3) by (apply LOoAApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApXMtmp : rk(Oo :: A :: Ap :: X :: nil) <= 3) by (solve_hyps_max HOoAApXeq HOoAApXM3).
	try assert(HOoAApXMNeq : rk(Oo :: A :: Ap :: X :: M :: N :: nil) = 4) by (apply LOoAApXMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApXMNmtmp : rk(Oo :: A :: Ap :: X :: M :: N :: nil) >= 4) by (solve_hyps_min HOoAApXMNeq HOoAApXMNm4).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXmtmp : rk(X :: nil) >= 1) by (solve_hyps_min HXeq HXm1).
	assert(Hincl : incl (X :: nil) (list_inter (Oo :: A :: Ap :: X :: nil) (X :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: X :: M :: N :: nil) (Oo :: A :: Ap :: X :: X :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: X :: X :: M :: N :: nil) ((Oo :: A :: Ap :: X :: nil) ++ (X :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApXMNmtmp;try rewrite HT2 in HOoAApXMNmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: X :: nil) (X :: M :: N :: nil) (X :: nil) 4 1 3 HOoAApXMNmtmp HXmtmp HOoAApXMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HXMNM2 : rk(X :: M :: N :: nil) <= 2).
{
	try assert(HAXMNeq : rk(A :: X :: M :: N :: nil) = 3) by (apply LAXMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXMNMtmp : rk(A :: X :: M :: N :: nil) <= 3) by (solve_hyps_max HAXMNeq HAXMNM3).
	try assert(HXMNQeq : rk(X :: M :: N :: Q :: nil) = 3) by (apply LXMNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXMNQMtmp : rk(X :: M :: N :: Q :: nil) <= 3) by (solve_hyps_max HXMNQeq HXMNQM3).
	try assert(HAXMNQeq : rk(A :: X :: M :: N :: Q :: nil) = 4) by (apply LAXMNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXMNQmtmp : rk(A :: X :: M :: N :: Q :: nil) >= 4) by (solve_hyps_min HAXMNQeq HAXMNQm4).
	assert(Hincl : incl (X :: M :: N :: nil) (list_inter (A :: X :: M :: N :: nil) (X :: M :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: X :: M :: N :: Q :: nil) (A :: X :: M :: N :: X :: M :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: X :: M :: N :: X :: M :: N :: Q :: nil) ((A :: X :: M :: N :: nil) ++ (X :: M :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAXMNQmtmp;try rewrite HT2 in HAXMNQmtmp.
	assert(HT := rule_3 (A :: X :: M :: N :: nil) (X :: M :: N :: Q :: nil) (X :: M :: N :: nil) 3 3 4 HAXMNMtmp HXMNQMtmp HAXMNQmtmp Hincl);apply HT.
}


assert(HXMNM : rk(X :: M :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HXMNeq HXMNM3).
assert(HXMNm : rk(X :: M :: N ::  nil) >= 1) by (solve_hyps_min HXMNeq HXMNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApYZMN *)
(* dans la couche 0 *)
Lemma LOoAApYZMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApYZMNP requis par la preuve de (?)OoAApYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApYZMNP requis par la preuve de (?)OoAApYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApYZMNP requis par la preuve de (?)OoAApYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYZMNPm2 : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYZMNPm3 : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYZMNPm4 : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApYZMNPM : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApYZMNPm : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoAApYZMNPeq HOoAApYZMNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: Ap :: Y :: Z :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApYZMN requis par la preuve de (?)OoAApYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApYZMN requis par la preuve de (?)OoAApYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApYZMN requis par la preuve de (?)OoAApYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYZMNm2 : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYZMNm3 : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAApYZMNm4 : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) >= 4).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HOoAApYZMNPeq : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) = 4) by (apply LOoAApYZMNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApYZMNPmtmp : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HOoAApYZMNPeq HOoAApYZMNPm4).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Y :: Z :: M :: N :: P :: nil) (Oo :: A :: Ap :: Y :: Z :: M :: N :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Y :: Z :: M :: N :: A :: M :: P :: nil) ((Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApYZMNPmtmp;try rewrite HT2 in HOoAApYZMNPmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) (A :: M :: P :: nil) (A :: M :: nil) 4 2 2 HOoAApYZMNPmtmp HAMmtmp HAMPMtmp Hincl);apply HT.
}


assert(HOoAApYZMNM : rk(Oo :: A :: Ap :: Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApYZMNm : rk(Oo :: A :: Ap :: Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HOoAApYZMNeq HOoAApYZMNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpYZMN *)
(* dans constructLemma(), requis par LCApBpYZMN *)
(* dans constructLemma(), requis par LCApBpYZMNP *)
(* dans la couche 0 *)
Lemma LOoCApBpYZMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpYZMNP requis par la preuve de (?)OoACApBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpYZMNP requis par la preuve de (?)OoACApBpYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpYZMNPm2 : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpYZMNPm3 : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpYZMNPm2 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpYZMNPm3 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpYZMNPmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoACApBpYZMNPeq HOoACApBpYZMNPm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpYZMNPmtmp;try rewrite HT2 in HOoACApBpYZMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpYZMNPmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpYZMNPm4 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpYZMNPM : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpYZMNPm : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoCApBpYZMNPeq HOoCApBpYZMNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpYZMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpYZMNP requis par la preuve de (?)CApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpYZMNP requis par la preuve de (?)CApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpYZMNP requis par la preuve de (?)OoACApBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpYZMNP requis par la preuve de (?)OoACApBpYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpYZMNPm2 : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpYZMNPm3 : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpYZMNP requis par la preuve de (?)OoCApBpYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpYZMNPm2 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpYZMNPm3 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpYZMNPmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoACApBpYZMNPeq HOoACApBpYZMNPm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpYZMNPmtmp;try rewrite HT2 in HOoACApBpYZMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpYZMNPmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpYZMNP requis par la preuve de (?)CApBpYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpYZMNP requis par la preuve de (?)CApBpYZMNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpYZMNPm2 : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpYZMNPmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoACApBpYZMNPeq HOoACApBpYZMNPm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpYZMNPmtmp;try rewrite HT2 in HOoACApBpYZMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpYZMNPmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpYZMNPM1. try clear HOoACApBpYZMNPM2. try clear HOoACApBpYZMNPM3. try clear HOoACApBpYZMNPm4. try clear HOoACApBpYZMNPm3. try clear HOoACApBpYZMNPm2. try clear HOoACApBpYZMNPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpYZMNPm3 : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpYZMNPmtmp : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoCApBpYZMNPeq HOoCApBpYZMNPm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpYZMNPmtmp;try rewrite HT2 in HOoCApBpYZMNPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpYZMNPmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HCApBpYZMNPm4 : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	try assert(HOoCApBpYZMNPeq : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) = 4) by (apply LOoCApBpYZMNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApBpYZMNPmtmp : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HOoCApBpYZMNPeq HOoCApBpYZMNPm4).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpYZMNPmtmp;try rewrite HT2 in HOoCApBpYZMNPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (Ap :: Bp :: M :: nil) 4 3 3 HOoCApBpYZMNPmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoCApBpYZMNPM1. try clear HOoCApBpYZMNPM2. try clear HOoCApBpYZMNPM3. try clear HOoCApBpYZMNPm4. try clear HOoCApBpYZMNPm3. try clear HOoCApBpYZMNPm2. try clear HOoCApBpYZMNPm1. 

assert(HCApBpYZMNPM : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpYZMNPm : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HCApBpYZMNPeq HCApBpYZMNPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApBpYZMN *)
(* dans constructLemma(), requis par LCApBpMP *)
(* dans la couche 0 *)
Lemma LOoCApBpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: C :: Ap :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpMP requis par la preuve de (?)OoACApBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpMP requis par la preuve de (?)OoACApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMPm2 : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMPm3 : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMPm2 : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: M :: P ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpMPm3 : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpMPmtmp : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 3) by (solve_hyps_min HOoACApBpMPeq HOoACApBpMPm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: M :: P :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpMPmtmp;try rewrite HT2 in HOoACApBpMPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpMPmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMPm4 : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpMPM : rk(Oo :: C :: Ap :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpMPm : rk(Oo :: C :: Ap :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoCApBpMPeq HOoCApBpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpMP requis par la preuve de (?)CApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpMP requis par la preuve de (?)CApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpMP requis par la preuve de (?)OoACApBpMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpMP requis par la preuve de (?)OoACApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMPm2 : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpMPm3 : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpMP requis par la preuve de (?)OoCApBpMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMPm2 : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: M :: P ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpMPm3 : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpMPmtmp : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 3) by (solve_hyps_min HOoACApBpMPeq HOoACApBpMPm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: M :: P :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpMPmtmp;try rewrite HT2 in HOoACApBpMPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpMPmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpMP requis par la preuve de (?)CApBpMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpMP requis par la preuve de (?)CApBpMP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: M :: P ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpMPm2 : rk(C :: Ap :: Bp :: M :: P :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpMPmtmp : rk(Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) >= 3) by (solve_hyps_min HOoACApBpMPeq HOoACApBpMPm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: M :: P :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpMPmtmp;try rewrite HT2 in HOoACApBpMPmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: M :: P :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpMPmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpMPM1. try clear HOoACApBpMPM2. try clear HOoACApBpMPM3. try clear HOoACApBpMPm4. try clear HOoACApBpMPm3. try clear HOoACApBpMPm2. try clear HOoACApBpMPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: M :: P ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpMPm3 : rk(C :: Ap :: Bp :: M :: P :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpMPmtmp : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 3) by (solve_hyps_min HOoCApBpMPeq HOoCApBpMPm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: M :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMPmtmp;try rewrite HT2 in HOoCApBpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: M :: P :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpMPmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: M :: P ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HCApBpMPm4 : rk(C :: Ap :: Bp :: M :: P :: nil) >= 4).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	try assert(HOoCApBpMPeq : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) = 4) by (apply LOoCApBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApBpMPmtmp : rk(Oo :: C :: Ap :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HOoCApBpMPeq HOoCApBpMPm4).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: P :: nil) (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: M :: P :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (C :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMPmtmp;try rewrite HT2 in HOoCApBpMPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: M :: P :: nil) (Ap :: Bp :: M :: nil) 4 3 3 HOoCApBpMPmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoCApBpMPM1. try clear HOoCApBpMPM2. try clear HOoCApBpMPM3. try clear HOoCApBpMPm4. try clear HOoCApBpMPm3. try clear HOoCApBpMPm2. try clear HOoCApBpMPm1. 

assert(HCApBpMPM : rk(C :: Ap :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpMPm : rk(C :: Ap :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HCApBpMPeq HCApBpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: Bp :: Y :: Z :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpYZMN requis par la preuve de (?)CApBpYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpYZMN requis par la preuve de (?)CApBpYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpYZMN requis par la preuve de (?)OoCApBpYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpYZMN requis par la preuve de (?)OoACApBpYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpYZMN requis par la preuve de (?)OoACApBpYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpYZMNm2 : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpYZMNm3 : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpYZMN requis par la preuve de (?)OoCApBpYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpYZMN requis par la preuve de (?)OoCApBpYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpYZMNm2 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpYZMNm3 : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpYZMNmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoACApBpYZMNeq HOoACApBpYZMNm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpYZMNmtmp;try rewrite HT2 in HOoACApBpYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpYZMNmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpYZMN requis par la preuve de (?)CApBpYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpYZMN requis par la preuve de (?)CApBpYZMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpYZMNm2 : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpYZMNmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoACApBpYZMNeq HOoACApBpYZMNm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpYZMNmtmp;try rewrite HT2 in HOoACApBpYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpYZMNmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpYZMNM1. try clear HOoACApBpYZMNM2. try clear HOoACApBpYZMNM3. try clear HOoACApBpYZMNm4. try clear HOoACApBpYZMNm3. try clear HOoACApBpYZMNm2. try clear HOoACApBpYZMNm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpYZMNm3 : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpYZMNmtmp : rk(Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoCApBpYZMNeq HOoCApBpYZMNm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpYZMNmtmp;try rewrite HT2 in HOoCApBpYZMNmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpYZMNmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoCApBpYZMNM1. try clear HOoCApBpYZMNM2. try clear HOoCApBpYZMNM3. try clear HOoCApBpYZMNm4. try clear HOoCApBpYZMNm3. try clear HOoCApBpYZMNm2. try clear HOoCApBpYZMNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApBpYZMNm4 : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 4).
{
	try assert(HCApBpMPeq : rk(C :: Ap :: Bp :: M :: P :: nil) = 4) by (apply LCApBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApBpMPMtmp : rk(C :: Ap :: Bp :: M :: P :: nil) <= 4) by (solve_hyps_max HCApBpMPeq HCApBpMPM4).
	try assert(HCApBpYZMNPeq : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) = 4) by (apply LCApBpYZMNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApBpYZMNPmtmp : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HCApBpYZMNPeq HCApBpYZMNPm4).
	try assert(HCApBpMeq : rk(C :: Ap :: Bp :: M :: nil) = 4) by (apply LCApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApBpMmtmp : rk(C :: Ap :: Bp :: M :: nil) >= 4) by (solve_hyps_min HCApBpMeq HCApBpMm4).
	assert(Hincl : incl (C :: Ap :: Bp :: M :: nil) (list_inter (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (C :: Ap :: Bp :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: Y :: Z :: M :: N :: P :: nil) (C :: Ap :: Bp :: Y :: Z :: M :: N :: C :: Ap :: Bp :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: Y :: Z :: M :: N :: C :: Ap :: Bp :: M :: P :: nil) ((C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) ++ (C :: Ap :: Bp :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpYZMNPmtmp;try rewrite HT2 in HCApBpYZMNPmtmp.
	assert(HT := rule_2 (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (C :: Ap :: Bp :: M :: P :: nil) (C :: Ap :: Bp :: M :: nil) 4 4 4 HCApBpYZMNPmtmp HCApBpMmtmp HCApBpMPMtmp Hincl);apply HT.
}


assert(HCApBpYZMNM : rk(C :: Ap :: Bp :: Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpYZMNm : rk(C :: Ap :: Bp :: Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HCApBpYZMNeq HCApBpYZMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Bp :: Y :: Z :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpYZMN requis par la preuve de (?)CBpYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)CBpYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)ACBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)ACBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)ACBpYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpYZMNPm2 : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpYZMNPm3 : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HACBpeq : rk(A :: C :: Bp :: nil) = 3) by (apply LACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 3) by (solve_hyps_min HACBpeq HACBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Bp :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Bp :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) 3 3 HACBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpYZMNPm4 : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HACBpMeq : rk(A :: C :: Bp :: M :: nil) = 4) by (apply LACBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACBpMmtmp : rk(A :: C :: Bp :: M :: nil) >= 4) by (solve_hyps_min HACBpMeq HACBpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) 4 4 HACBpMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpYZMN requis par la preuve de (?)CBpYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpYZMN requis par la preuve de (?)CBpYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpYZMN requis par la preuve de (?)OoACBpYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpYZMN requis par la preuve de (?)OoACBpYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpYZMNm2 : rk(Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpYZMNm3 : rk(Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpYZMN requis par la preuve de (?)CBpYZMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpYZMNm2 : rk(C :: Bp :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpYZMNmtmp : rk(Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoACBpYZMNeq HOoACBpYZMNm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Y :: Z :: M :: N :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Y :: Z :: M :: N :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpYZMNmtmp;try rewrite HT2 in HOoACBpYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Y :: Z :: M :: N :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpYZMNmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HCBpM1. try clear HCBpM2. try clear HCBpM3. try clear HCBpm4. try clear HCBpm3. try clear HCBpm2. try clear HCBpm1. try clear HOoACBpYZMNM1. try clear HOoACBpYZMNM2. try clear HOoACBpYZMNM3. try clear HOoACBpYZMNm4. try clear HOoACBpYZMNm3. try clear HOoACBpYZMNm2. try clear HOoACBpYZMNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HCBpYZMNm3 : rk(C :: Bp :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(HACBpYZMNPmtmp : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HACBpYZMNPeq HACBpYZMNPm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (C :: Bp :: Y :: Z :: M :: N :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) (C :: Bp :: Y :: Z :: M :: N :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Y :: Z :: M :: N :: A :: M :: P :: nil) ((C :: Bp :: Y :: Z :: M :: N :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpYZMNPmtmp;try rewrite HT2 in HACBpYZMNPmtmp.
	assert(HT := rule_2 (C :: Bp :: Y :: Z :: M :: N :: nil) (A :: M :: P :: nil) (M :: nil) 4 1 2 HACBpYZMNPmtmp HMmtmp HAMPMtmp Hincl);apply HT.
}
try clear HACBpYZMNPM1. try clear HACBpYZMNPM2. try clear HACBpYZMNPM3. try clear HACBpYZMNPm4. try clear HACBpYZMNPm3. try clear HACBpYZMNPm2. try clear HACBpYZMNPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: Bp :: Y :: Z :: M :: N ::  de rang :  4 et 4 	 AiB : C :: Y ::  de rang :  2 et 2 	 A : C :: Ap :: Y ::   de rang : 2 et 2 *)
assert(HCBpYZMNm4 : rk(C :: Bp :: Y :: Z :: M :: N :: nil) >= 4).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	try assert(HCApBpYZMNeq : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) = 4) by (apply LCApBpYZMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApBpYZMNmtmp : rk(C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) >= 4) by (solve_hyps_min HCApBpYZMNeq HCApBpYZMNm4).
	try assert(HCYeq : rk(C :: Y :: nil) = 2) by (apply LCY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCYmtmp : rk(C :: Y :: nil) >= 2) by (solve_hyps_min HCYeq HCYm2).
	assert(Hincl : incl (C :: Y :: nil) (list_inter (C :: Ap :: Y :: nil) (C :: Bp :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: Y :: Z :: M :: N :: nil) (C :: Ap :: Y :: C :: Bp :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: C :: Bp :: Y :: Z :: M :: N :: nil) ((C :: Ap :: Y :: nil) ++ (C :: Bp :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpYZMNmtmp;try rewrite HT2 in HCApBpYZMNmtmp.
	assert(HT := rule_4 (C :: Ap :: Y :: nil) (C :: Bp :: Y :: Z :: M :: N :: nil) (C :: Y :: nil) 4 2 2 HCApBpYZMNmtmp HCYmtmp HCApYMtmp Hincl); apply HT.
}
try clear HCYM1. try clear HCYM2. try clear HCYM3. try clear HCYm4. try clear HCYm3. try clear HCYm2. try clear HCYm1. 

assert(HCBpYZMNM : rk(C :: Bp :: Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpYZMNm : rk(C :: Bp :: Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HCBpYZMNeq HCBpYZMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LXYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(X :: Y :: Z :: M :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour XYZMN requis par la preuve de (?)XYZMN pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)XYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)BCApXYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXYZMNP requis par la preuve de (?)OoABCApXYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXYZMNP requis par la preuve de (?)OoABCApXYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNPm2 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNPm3 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApXYZMNPm2 : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApXYZMNPm3 : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApXYZMNPmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABCApXYZMNPeq HOoABCApXYZMNPm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXYZMNPmtmp;try rewrite HT2 in HOoABCApXYZMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABCApXYZMNPmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApXYZMNPM1. try clear HOoABCApXYZMNPM2. try clear HOoABCApXYZMNPM3. try clear HOoABCApXYZMNPm4. try clear HOoABCApXYZMNPm3. try clear HOoABCApXYZMNPm2. try clear HOoABCApXYZMNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApXYZMNPm4 : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HABApMeq : rk(A :: B :: Ap :: M :: nil) = 4) by (apply LABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApMmtmp : rk(A :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HABApMeq HABApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: M :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: M :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 4 4 HABApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABCMP requis par la preuve de (?)BCApXYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoABCMP requis par la preuve de (?)ABCMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCMP requis par la preuve de (?)OoABCMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABMP requis par la preuve de (?)OoABCMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMPm2 : rk(Oo :: A :: B :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABMPM3 : rk(Oo :: A :: B :: M :: P :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: P :: nil) (Oo :: A :: B :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: M :: P :: nil) ((Oo :: A :: B :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (A :: M :: P :: nil) (A :: nil) 2 2 1 HOoABMtmp HAMPMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCMP requis par la preuve de (?)OoABCMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCMP requis par la preuve de (?)OoABCMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCMPm2 : rk(Oo :: A :: B :: C :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABCMPM3 : rk(Oo :: A :: B :: C :: M :: P :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HOoABMPMtmp : rk(Oo :: A :: B :: M :: P :: nil) <= 3) by (solve_hyps_max HOoABMPeq HOoABMPM3).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: M :: P :: nil) (Oo :: A :: C :: Oo :: A :: B :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: M :: P :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: A :: B :: M :: P :: nil) (Oo :: A :: nil) 2 3 2 HOoACMtmp HOoABMPMtmp HOoAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HOoABMPM1. try clear HOoABMPM2. try clear HOoABMPM3. try clear HOoABMPm4. try clear HOoABMPm3. try clear HOoABMPm2. try clear HOoABMPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCMPm3 : rk(Oo :: A :: B :: C :: M :: P :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: C :: M :: P :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCMP requis par la preuve de (?)ABCMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCMP requis par la preuve de (?)ABCMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCMP requis par la preuve de (?)ABCMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCMPm2 : rk(A :: B :: C :: M :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: M :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABCMPM3 : rk(A :: B :: C :: M :: P :: nil) <= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: M :: P :: nil) (A :: B :: C :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: M :: P :: nil) ((A :: B :: C :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (A :: M :: P :: nil) (A :: nil) 2 2 1 HABCMtmp HAMPMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: M :: P ::  de rang :  3 et 3 	 AiB : A :: B :: M ::  de rang :  3 et 3 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HABCMPm3 : rk(A :: B :: C :: M :: P :: nil) >= 3).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	assert(HOoABCMPmtmp : rk(Oo :: A :: B :: C :: M :: P :: nil) >= 3) by (solve_hyps_min HOoABCMPeq HOoABCMPm3).
	try assert(HABMeq : rk(A :: B :: M :: nil) = 3) by (apply LABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMmtmp : rk(A :: B :: M :: nil) >= 3) by (solve_hyps_min HABMeq HABMm3).
	assert(Hincl : incl (A :: B :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: B :: C :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: M :: P :: nil) (Oo :: A :: B :: M :: A :: B :: C :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: B :: C :: M :: P :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: B :: C :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCMPmtmp;try rewrite HT2 in HOoABCMPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: B :: C :: M :: P :: nil) (A :: B :: M :: nil) 3 3 3 HOoABCMPmtmp HABMmtmp HOoABMMtmp Hincl); apply HT.
}
try clear HOoABCMPM1. try clear HOoABCMPM2. try clear HOoABCMPM3. try clear HOoABCMPm4. try clear HOoABCMPm3. try clear HOoABCMPm2. try clear HOoABCMPm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoABCApXYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoABCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNm2 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNm3 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApXYZMNm2 : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApXYZMNm3 : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApXYZMNmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoABCApXYZMNeq HOoABCApXYZMNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXYZMNmtmp;try rewrite HT2 in HOoABCApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApXYZMNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApXYZMNM1. try clear HOoABCApXYZMNM2. try clear HOoABCApXYZMNM3. try clear HOoABCApXYZMNm4. try clear HOoABCApXYZMNm3. try clear HOoABCApXYZMNm2. try clear HOoABCApXYZMNm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXYZMNm2 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HBCApXYZMNm3 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoBCApeq : rk(Oo :: B :: C :: Ap :: nil) = 3) by (apply LOoBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMtmp : rk(Oo :: B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoBCApeq HOoBCApM3).
	assert(HOoBCApXYZMNmtmp : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoBCApXYZMNeq HOoBCApXYZMNm3).
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: B :: C :: Ap :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: B :: C :: Ap :: nil) ++ (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApXYZMNmtmp;try rewrite HT2 in HOoBCApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: C :: Ap :: nil) 3 3 3 HOoBCApXYZMNmtmp HBCApmtmp HOoBCApMtmp Hincl); apply HT.
}
try clear HOoBCApXYZMNM1. try clear HOoBCApXYZMNM2. try clear HOoBCApXYZMNM3. try clear HOoBCApXYZMNm4. try clear HOoBCApXYZMNm3. try clear HOoBCApXYZMNm2. try clear HOoBCApXYZMNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HBCApXYZMNm4 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4).
{
	assert(HABCMPMtmp : rk(A :: B :: C :: M :: P :: nil) <= 3) by (solve_hyps_max HABCMPeq HABCMPM3).
	assert(HABCApXYZMNPmtmp : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HABCApXYZMNPeq HABCApXYZMNPm4).
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hincl : incl (B :: C :: M :: nil) (list_inter (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (A :: B :: C :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: A :: B :: C :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: X :: Y :: Z :: M :: N :: A :: B :: C :: M :: P :: nil) ((B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ++ (A :: B :: C :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApXYZMNPmtmp;try rewrite HT2 in HABCApXYZMNPmtmp.
	assert(HT := rule_2 (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (A :: B :: C :: M :: P :: nil) (B :: C :: M :: nil) 4 3 3 HABCApXYZMNPmtmp HBCMmtmp HABCMPMtmp Hincl);apply HT.
}
try clear HABCMPM1. try clear HABCMPM2. try clear HABCMPM3. try clear HABCMPm4. try clear HABCMPm3. try clear HABCMPm2. try clear HABCMPm1. try clear HABCApXYZMNPM1. try clear HABCApXYZMNPM2. try clear HABCApXYZMNPM3. try clear HABCApXYZMNPm4. try clear HABCApXYZMNPm3. try clear HABCApXYZMNPm2. try clear HABCApXYZMNPm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApXYZMN requis par la preuve de (?)OoACApXYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApXYZMN requis par la preuve de (?)OoACApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApXYZMNm2 : rk(Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApXYZMNm3 : rk(Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApXYZMNm2 : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApXYZMNmtmp : rk(Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoACApXYZMNeq HOoACApXYZMNm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApXYZMNmtmp;try rewrite HT2 in HOoACApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (C :: Ap :: nil) 3 2 3 HOoACApXYZMNmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApXYZMNM1. try clear HOoACApXYZMNM2. try clear HOoACApXYZMNM3. try clear HOoACApXYZMNm4. try clear HOoACApXYZMNm3. try clear HOoACApXYZMNm2. try clear HOoACApXYZMNm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : B :: Ap :: X ::   de rang : 2 et 2 *)
assert(HCApXYZMNm3 : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	assert(HBCApXYZMNmtmp : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HBCApXYZMNeq HBCApXYZMNm3).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((B :: Ap :: X :: nil) ++ (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApXYZMNmtmp;try rewrite HT2 in HBCApXYZMNmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Ap :: X :: nil) 3 2 2 HBCApXYZMNmtmp HApXmtmp HBApXMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  4 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : B :: Ap :: X ::   de rang : 2 et 2 *)
assert(HCApXYZMNm4 : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	assert(HBCApXYZMNmtmp : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4) by (solve_hyps_min HBCApXYZMNeq HBCApXYZMNm4).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((B :: Ap :: X :: nil) ++ (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApXYZMNmtmp;try rewrite HT2 in HBCApXYZMNmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Ap :: X :: nil) 4 2 2 HBCApXYZMNmtmp HApXmtmp HBApXMtmp Hincl); apply HT.
}
try clear HApXM1. try clear HApXM2. try clear HApXM3. try clear HApXm4. try clear HApXm3. try clear HApXm2. try clear HApXm1. try clear HBCApXYZMNM1. try clear HBCApXYZMNM2. try clear HBCApXYZMNM3. try clear HBCApXYZMNm4. try clear HBCApXYZMNm3. try clear HBCApXYZMNm2. try clear HBCApXYZMNm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour XYZMN requis par la preuve de (?)XYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour XYZMN requis par la preuve de (?)XYZMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Y ::  de rang :  1 et 1 	 A : C :: Ap :: Y ::   de rang : 2 et 2 *)
assert(HXYZMNm2 : rk(X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	assert(HCApXYZMNmtmp : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HCApXYZMNeq HCApXYZMNm3).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (C :: Ap :: Y :: nil) (X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (C :: Ap :: Y :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: X :: Y :: Z :: M :: N :: nil) ((C :: Ap :: Y :: nil) ++ (X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApXYZMNmtmp;try rewrite HT2 in HCApXYZMNmtmp.
	assert(HT := rule_4 (C :: Ap :: Y :: nil) (X :: Y :: Z :: M :: N :: nil) (Y :: nil) 3 1 2 HCApXYZMNmtmp HYmtmp HCApYMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  4 et 4 	 AiB : Y ::  de rang :  1 et 1 	 A : C :: Ap :: Y ::   de rang : 2 et 2 *)
assert(HXYZMNm3 : rk(X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	assert(HCApXYZMNmtmp : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4) by (solve_hyps_min HCApXYZMNeq HCApXYZMNm4).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (C :: Ap :: Y :: nil) (X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (C :: Ap :: Y :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: X :: Y :: Z :: M :: N :: nil) ((C :: Ap :: Y :: nil) ++ (X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApXYZMNmtmp;try rewrite HT2 in HCApXYZMNmtmp.
	assert(HT := rule_4 (C :: Ap :: Y :: nil) (X :: Y :: Z :: M :: N :: nil) (Y :: nil) 4 1 2 HCApXYZMNmtmp HYmtmp HCApYMtmp Hincl); apply HT.
}
try clear HCApXYZMNM1. try clear HCApXYZMNM2. try clear HCApXYZMNM3. try clear HCApXYZMNm4. try clear HCApXYZMNm3. try clear HCApXYZMNm2. try clear HCApXYZMNm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HXYZMNM3 : rk(X :: Y :: Z :: M :: N :: nil) <= 3).
{
	try assert(HXYZeq : rk(X :: Y :: Z :: nil) = 2) by (apply LXYZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXYZMtmp : rk(X :: Y :: Z :: nil) <= 2) by (solve_hyps_max HXYZeq HXYZM2).
	try assert(HXMNeq : rk(X :: M :: N :: nil) = 2) by (apply LXMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXMNMtmp : rk(X :: M :: N :: nil) <= 2) by (solve_hyps_max HXMNeq HXMNM2).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXmtmp : rk(X :: nil) >= 1) by (solve_hyps_min HXeq HXm1).
	assert(Hincl : incl (X :: nil) (list_inter (X :: Y :: Z :: nil) (X :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (X :: Y :: Z :: M :: N :: nil) (X :: Y :: Z :: X :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (X :: Y :: Z :: X :: M :: N :: nil) ((X :: Y :: Z :: nil) ++ (X :: M :: N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (X :: Y :: Z :: nil) (X :: M :: N :: nil) (X :: nil) 2 2 1 HXYZMtmp HXMNMtmp HXmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HXYZM1. try clear HXYZM2. try clear HXYZM3. try clear HXYZm4. try clear HXYZm3. try clear HXYZm2. try clear HXYZm1. 

assert(HXYZMNM : rk(X :: Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HXYZMNm : rk(X :: Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HXYZMNeq HXYZMNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApXYZMN *)
(* dans constructLemma(), requis par LBCApXYZMN *)
(* dans la couche 0 *)
Lemma LABCApXYZMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXYZMNP requis par la preuve de (?)OoABCApXYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXYZMNP requis par la preuve de (?)OoABCApXYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNPm2 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNPm3 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApXYZMNP requis par la preuve de (?)ABCApXYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApXYZMNPm2 : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApXYZMNPm3 : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApXYZMNPmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABCApXYZMNPeq HOoABCApXYZMNPm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXYZMNPmtmp;try rewrite HT2 in HOoABCApXYZMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABCApXYZMNPmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApXYZMNPM1. try clear HOoABCApXYZMNPM2. try clear HOoABCApXYZMNPM3. try clear HOoABCApXYZMNPm4. try clear HOoABCApXYZMNPm3. try clear HOoABCApXYZMNPm2. try clear HOoABCApXYZMNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApXYZMNPm4 : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HABApMeq : rk(A :: B :: Ap :: M :: nil) = 4) by (apply LABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABApMmtmp : rk(A :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HABApMeq HABApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: M :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: M :: nil) (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) 4 4 HABApMmtmp Hcomp Hincl);apply HT.
}


assert(HABCApXYZMNPM : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApXYZMNPm : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HABCApXYZMNPeq HABCApXYZMNPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCApXYZMN *)
(* dans constructLemma(), requis par LABCMP *)
(* dans la couche 0 *)
Lemma LOoABCMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCMP requis par la preuve de (?)OoABCMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABMP requis par la preuve de (?)OoABCMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMP requis par la preuve de (?)OoABMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMPm2 : rk(Oo :: A :: B :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABMPM3 : rk(Oo :: A :: B :: M :: P :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: P :: nil) (Oo :: A :: B :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: M :: P :: nil) ((Oo :: A :: B :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (A :: M :: P :: nil) (A :: nil) 2 2 1 HOoABMtmp HAMPMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCMP requis par la preuve de (?)OoABCMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCMP requis par la preuve de (?)OoABCMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCMPm2 : rk(Oo :: A :: B :: C :: M :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: M :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABCMPM3 : rk(Oo :: A :: B :: C :: M :: P :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HOoABMPMtmp : rk(Oo :: A :: B :: M :: P :: nil) <= 3) by (solve_hyps_max HOoABMPeq HOoABMPM3).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: M :: P :: nil) (Oo :: A :: C :: Oo :: A :: B :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: M :: P :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: A :: B :: M :: P :: nil) (Oo :: A :: nil) 2 3 2 HOoACMtmp HOoABMPMtmp HOoAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HOoABMPM1. try clear HOoABMPM2. try clear HOoABMPM3. try clear HOoABMPm4. try clear HOoABMPm3. try clear HOoABMPm2. try clear HOoABMPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCMPm3 : rk(Oo :: A :: B :: C :: M :: P :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: C :: M :: P :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCMPM : rk(Oo :: A :: B :: C :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCMPm : rk(Oo :: A :: B :: C :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABCMPeq HOoABCMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: B :: C :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCMP requis par la preuve de (?)ABCMP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCMP requis par la preuve de (?)ABCMP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCMP requis par la preuve de (?)ABCMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCMPm2 : rk(A :: B :: C :: M :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: M :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABCMPM3 : rk(A :: B :: C :: M :: P :: nil) <= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: M :: P :: nil) (A :: B :: C :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: M :: P :: nil) ((A :: B :: C :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (A :: M :: P :: nil) (A :: nil) 2 2 1 HABCMtmp HAMPMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: M :: P ::  de rang :  3 et 3 	 AiB : A :: B :: M ::  de rang :  3 et 3 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HABCMPm3 : rk(A :: B :: C :: M :: P :: nil) >= 3).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	try assert(HOoABCMPeq : rk(Oo :: A :: B :: C :: M :: P :: nil) = 3) by (apply LOoABCMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCMPmtmp : rk(Oo :: A :: B :: C :: M :: P :: nil) >= 3) by (solve_hyps_min HOoABCMPeq HOoABCMPm3).
	try assert(HABMeq : rk(A :: B :: M :: nil) = 3) by (apply LABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMmtmp : rk(A :: B :: M :: nil) >= 3) by (solve_hyps_min HABMeq HABMm3).
	assert(Hincl : incl (A :: B :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: B :: C :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: M :: P :: nil) (Oo :: A :: B :: M :: A :: B :: C :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: B :: C :: M :: P :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: B :: C :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCMPmtmp;try rewrite HT2 in HOoABCMPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: B :: C :: M :: P :: nil) (A :: B :: M :: nil) 3 3 3 HOoABCMPmtmp HABMmtmp HOoABMMtmp Hincl); apply HT.
}


assert(HABCMPM : rk(A :: B :: C :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCMPm : rk(A :: B :: C :: M :: P ::  nil) >= 1) by (solve_hyps_min HABCMPeq HABCMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApXYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: C :: Ap :: X :: Y :: Z :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoABCApXYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoABCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNm2 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNm3 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApXYZMNm2 : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApXYZMNm3 : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApXYZMNmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoABCApXYZMNeq HOoABCApXYZMNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXYZMNmtmp;try rewrite HT2 in HOoABCApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApXYZMNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApXYZMNM1. try clear HOoABCApXYZMNM2. try clear HOoABCApXYZMNM3. try clear HOoABCApXYZMNm4. try clear HOoABCApXYZMNm3. try clear HOoABCApXYZMNm2. try clear HOoABCApXYZMNm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXYZMNm2 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HBCApXYZMNm3 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoBCApeq : rk(Oo :: B :: C :: Ap :: nil) = 3) by (apply LOoBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMtmp : rk(Oo :: B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoBCApeq HOoBCApM3).
	assert(HOoBCApXYZMNmtmp : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoBCApXYZMNeq HOoBCApXYZMNm3).
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: B :: C :: Ap :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: B :: C :: Ap :: nil) ++ (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApXYZMNmtmp;try rewrite HT2 in HOoBCApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: C :: Ap :: nil) 3 3 3 HOoBCApXYZMNmtmp HBCApmtmp HOoBCApMtmp Hincl); apply HT.
}
try clear HOoBCApXYZMNM1. try clear HOoBCApXYZMNM2. try clear HOoBCApXYZMNM3. try clear HOoBCApXYZMNm4. try clear HOoBCApXYZMNm3. try clear HOoBCApXYZMNm2. try clear HOoBCApXYZMNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCApXYZMNm4 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4).
{
	try assert(HABCMPeq : rk(A :: B :: C :: M :: P :: nil) = 3) by (apply LABCMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCMPMtmp : rk(A :: B :: C :: M :: P :: nil) <= 3) by (solve_hyps_max HABCMPeq HABCMPM3).
	try assert(HABCApXYZMNPeq : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) = 4) by (apply LABCApXYZMNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABCApXYZMNPmtmp : rk(A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) >= 4) by (solve_hyps_min HABCApXYZMNPeq HABCApXYZMNPm4).
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hincl : incl (B :: C :: M :: nil) (list_inter (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (A :: B :: C :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: P :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: A :: B :: C :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: X :: Y :: Z :: M :: N :: A :: B :: C :: M :: P :: nil) ((B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ++ (A :: B :: C :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApXYZMNPmtmp;try rewrite HT2 in HABCApXYZMNPmtmp.
	assert(HT := rule_2 (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (A :: B :: C :: M :: P :: nil) (B :: C :: M :: nil) 4 3 3 HABCApXYZMNPmtmp HBCMmtmp HABCMPMtmp Hincl);apply HT.
}


assert(HBCApXYZMNM : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApXYZMNm : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HBCApXYZMNeq HBCApXYZMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApXYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(C :: Ap :: X :: Y :: Z :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoABCApXYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXYZMN requis par la preuve de (?)OoABCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNm2 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXYZMNm3 : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApXYZMN requis par la preuve de (?)OoBCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApXYZMNm2 : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApXYZMNm3 : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApXYZMNmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoABCApXYZMNeq HOoABCApXYZMNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXYZMNmtmp;try rewrite HT2 in HOoABCApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApXYZMNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApXYZMNM1. try clear HOoABCApXYZMNM2. try clear HOoABCApXYZMNM3. try clear HOoABCApXYZMNm4. try clear HOoABCApXYZMNm3. try clear HOoABCApXYZMNm2. try clear HOoABCApXYZMNm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApXYZMN requis par la preuve de (?)BCApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXYZMNm2 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HBCApXYZMNm3 : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoBCApeq : rk(Oo :: B :: C :: Ap :: nil) = 3) by (apply LOoBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBCApMtmp : rk(Oo :: B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoBCApeq HOoBCApM3).
	assert(HOoBCApXYZMNmtmp : rk(Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoBCApXYZMNeq HOoBCApXYZMNm3).
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: B :: C :: Ap :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: B :: C :: Ap :: nil) ++ (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApXYZMNmtmp;try rewrite HT2 in HOoBCApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: C :: Ap :: nil) 3 3 3 HOoBCApXYZMNmtmp HBCApmtmp HOoBCApMtmp Hincl); apply HT.
}
try clear HOoBCApXYZMNM1. try clear HOoBCApXYZMNM2. try clear HOoBCApXYZMNM3. try clear HOoBCApXYZMNm4. try clear HOoBCApXYZMNm3. try clear HOoBCApXYZMNm2. try clear HOoBCApXYZMNm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApXYZMN requis par la preuve de (?)OoACApXYZMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApXYZMN requis par la preuve de (?)OoACApXYZMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApXYZMNm2 : rk(Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApXYZMNm3 : rk(Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApXYZMN requis par la preuve de (?)CApXYZMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApXYZMNm2 : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApXYZMNmtmp : rk(Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HOoACApXYZMNeq HOoACApXYZMNm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApXYZMNmtmp;try rewrite HT2 in HOoACApXYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (C :: Ap :: nil) 3 2 3 HOoACApXYZMNmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApXYZMNM1. try clear HOoACApXYZMNM2. try clear HOoACApXYZMNM3. try clear HOoACApXYZMNm4. try clear HOoACApXYZMNm3. try clear HOoACApXYZMNm2. try clear HOoACApXYZMNm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  3 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : B :: Ap :: X ::   de rang : 2 et 2 *)
assert(HCApXYZMNm3 : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	assert(HBCApXYZMNmtmp : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 3) by (solve_hyps_min HBCApXYZMNeq HBCApXYZMNm3).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((B :: Ap :: X :: nil) ++ (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApXYZMNmtmp;try rewrite HT2 in HBCApXYZMNmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Ap :: X :: nil) 3 2 2 HBCApXYZMNmtmp HApXmtmp HBApXMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: X :: Y :: Z :: M :: N ::  de rang :  4 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : B :: Ap :: X ::   de rang : 2 et 2 *)
assert(HCApXYZMNm4 : rk(C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HBCApXYZMNeq : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) = 4) by (apply LBCApXYZMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBCApXYZMNmtmp : rk(B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) >= 4) by (solve_hyps_min HBCApXYZMNeq HBCApXYZMNm4).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: C :: Ap :: X :: Y :: Z :: M :: N :: nil) ((B :: Ap :: X :: nil) ++ (C :: Ap :: X :: Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApXYZMNmtmp;try rewrite HT2 in HBCApXYZMNmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: nil) (C :: Ap :: X :: Y :: Z :: M :: N :: nil) (Ap :: X :: nil) 4 2 2 HBCApXYZMNmtmp HApXmtmp HBApXMtmp Hincl); apply HT.
}
try clear HApXM1. try clear HApXM2. try clear HApXM3. try clear HApXm4. try clear HApXm3. try clear HApXm2. try clear HApXm1. try clear HBCApXYZMNM1. try clear HBCApXYZMNM2. try clear HBCApXYZMNM3. try clear HBCApXYZMNm4. try clear HBCApXYZMNm3. try clear HBCApXYZMNm2. try clear HBCApXYZMNm1. 

assert(HCApXYZMNM : rk(C :: Ap :: X :: Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApXYZMNm : rk(C :: Ap :: X :: Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HCApXYZMNeq HCApXYZMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(P ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

assert(HPM : rk(P ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HPeq HPM1).
assert(HPm : rk(P ::  nil) >= 1) by (solve_hyps_min HPeq HPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LNP *)
(* dans la couche 0 *)
Lemma LBNPQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: N :: P :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BNPQ requis par la preuve de (?)BNPQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BNPQ requis par la preuve de (?)BNPQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BNPQ requis par la preuve de (?)BNPQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: M ::   de rang : 3 et 3 *)
assert(HBNPQm2 : rk(B :: N :: P :: Q :: nil) >= 2).
{
	try assert(HABMeq : rk(A :: B :: M :: nil) = 3) by (apply LABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMMtmp : rk(A :: B :: M :: nil) <= 3) by (solve_hyps_max HABMeq HABMM3).
	try assert(HABMNPQeq : rk(A :: B :: M :: N :: P :: Q :: nil) = 4) by (apply LABMNPQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: M :: nil) (B :: N :: P :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: B :: M :: B :: N :: P :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: M :: B :: N :: P :: Q :: nil) ((A :: B :: M :: nil) ++ (B :: N :: P :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: B :: M :: nil) (B :: N :: P :: Q :: nil) (B :: nil) 4 1 3 HABMNPQmtmp HBmtmp HABMMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBNPQM3 : rk(B :: N :: P :: Q :: nil) <= 3).
{
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (P :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: N :: P :: Q :: nil) (P :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (P :: B :: N :: Q :: nil) ((P :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (P :: nil) (B :: N :: Q :: nil) (nil) 1 2 0 HPMtmp HBNQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: M :: N :: P :: Q ::  de rang :  4 et 4 	 AiB : P ::  de rang :  1 et 1 	 A : A :: M :: P ::   de rang : 2 et 2 *)
assert(HBNPQm3 : rk(B :: N :: P :: Q :: nil) >= 3).
{
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	try assert(HABMNPQeq : rk(A :: B :: M :: N :: P :: Q :: nil) = 4) by (apply LABMNPQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABMNPQmtmp : rk(A :: B :: M :: N :: P :: Q :: nil) >= 4) by (solve_hyps_min HABMNPQeq HABMNPQm4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (A :: M :: P :: nil) (B :: N :: P :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: M :: N :: P :: Q :: nil) (A :: M :: P :: B :: N :: P :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: P :: B :: N :: P :: Q :: nil) ((A :: M :: P :: nil) ++ (B :: N :: P :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABMNPQmtmp;try rewrite HT2 in HABMNPQmtmp.
	assert(HT := rule_4 (A :: M :: P :: nil) (B :: N :: P :: Q :: nil) (P :: nil) 4 1 2 HABMNPQmtmp HPmtmp HAMPMtmp Hincl); apply HT.
}
try clear HPM1. try clear HPM2. try clear HPM3. try clear HPm4. try clear HPm3. try clear HPm2. try clear HPm1. try clear HABMNPQM1. try clear HABMNPQM2. try clear HABMNPQM3. try clear HABMNPQm4. try clear HABMNPQm3. try clear HABMNPQm2. try clear HABMNPQm1. 

assert(HBNPQM : rk(B :: N :: P :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBNPQm : rk(B :: N :: P :: Q ::  nil) >= 1) by (solve_hyps_min HBNPQeq HBNPQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(N :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NP requis par la preuve de (?)NP pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HNPm2 : rk(N :: P :: nil) >= 2).
{
	try assert(HBNQeq : rk(B :: N :: Q :: nil) = 2) by (apply LBNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNQMtmp : rk(B :: N :: Q :: nil) <= 2) by (solve_hyps_max HBNQeq HBNQM2).
	try assert(HBNPQeq : rk(B :: N :: P :: Q :: nil) = 3) by (apply LBNPQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBNPQmtmp : rk(B :: N :: P :: Q :: nil) >= 3) by (solve_hyps_min HBNPQeq HBNPQm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (N :: P :: nil) (B :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: N :: P :: Q :: nil) (N :: P :: B :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: P :: B :: N :: Q :: nil) ((N :: P :: nil) ++ (B :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBNPQmtmp;try rewrite HT2 in HBNPQmtmp.
	assert(HT := rule_2 (N :: P :: nil) (B :: N :: Q :: nil) (N :: nil) 3 1 2 HBNPQmtmp HNmtmp HBNQMtmp Hincl);apply HT.
}


assert(HNPM : rk(N :: P ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNPeq HNPM2).
assert(HNPm : rk(N :: P ::  nil) >= 1) by (solve_hyps_min HNPeq HNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LANP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: N :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ANP requis par la preuve de (?)ANP pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ANP requis par la preuve de (?)ANP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Bp ::   de rang : 2 et 2 *)
assert(HANPm2 : rk(A :: N :: P :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBpMtmp : rk(Oo :: Bp :: nil) <= 2) by (solve_hyps_max HOoBpeq HOoBpM2).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Bp :: nil) (A :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Oo :: Bp :: A :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: A :: N :: P :: nil) ((Oo :: Bp :: nil) ++ (A :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_4 (Oo :: Bp :: nil) (A :: N :: P :: nil) (nil) 4 0 2 HOoABpNPmtmp Hmtmp HOoBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HANPm3 : rk(A :: N :: P :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HABpNPeq : rk(A :: Bp :: N :: P :: nil) = 3) by (apply LABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpNPmtmp : rk(A :: Bp :: N :: P :: nil) >= 3) by (solve_hyps_min HABpNPeq HABpNPm3).
	try assert(HNPeq : rk(N :: P :: nil) = 2) by (apply LNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNPmtmp : rk(N :: P :: nil) >= 2) by (solve_hyps_min HNPeq HNPm2).
	assert(Hincl : incl (N :: P :: nil) (list_inter (A :: N :: P :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: P :: nil) (A :: N :: P :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: N :: P :: Bp :: N :: P :: nil) ((A :: N :: P :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpNPmtmp;try rewrite HT2 in HABpNPmtmp.
	assert(HT := rule_2 (A :: N :: P :: nil) (Bp :: N :: P :: nil) (N :: P :: nil) 3 2 2 HABpNPmtmp HNPmtmp HBpNPMtmp Hincl);apply HT.
}


assert(HANPM : rk(A :: N :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HANPeq HANPM3).
assert(HANPm : rk(A :: N :: P ::  nil) >= 1) by (solve_hyps_min HANPeq HANPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoANP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoANP requis par la preuve de (?)OoANP pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoANP requis par la preuve de (?)OoANP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoANP requis par la preuve de (?)OoANP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANPm2 : rk(Oo :: A :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoANPm3 : rk(Oo :: A :: N :: P :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: A :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Bp :: Oo :: A :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: A :: N :: P :: nil) ((Bp :: nil) ++ (Oo :: A :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: A :: N :: P :: nil) (nil) 4 0 1 HOoABpNPmtmp Hmtmp HBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoANPm4 : rk(Oo :: A :: N :: P :: nil) >= 4).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HOoABpNPeq : rk(Oo :: A :: Bp :: N :: P :: nil) = 4) by (apply LOoABpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpNPmtmp : rk(Oo :: A :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABpNPeq HOoABpNPm4).
	try assert(HNPeq : rk(N :: P :: nil) = 2) by (apply LNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNPmtmp : rk(N :: P :: nil) >= 2) by (solve_hyps_min HNPeq HNPm2).
	assert(Hincl : incl (N :: P :: nil) (list_inter (Oo :: A :: N :: P :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: nil) (Oo :: A :: N :: P :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: P :: Bp :: N :: P :: nil) ((Oo :: A :: N :: P :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPmtmp;try rewrite HT2 in HOoABpNPmtmp.
	assert(HT := rule_2 (Oo :: A :: N :: P :: nil) (Bp :: N :: P :: nil) (N :: P :: nil) 4 2 2 HOoABpNPmtmp HNPmtmp HBpNPMtmp Hincl);apply HT.
}
try clear HNPM1. try clear HNPM2. try clear HNPM3. try clear HNPm4. try clear HNPm3. try clear HNPm2. try clear HNPm1. 

assert(HOoANPM : rk(Oo :: A :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoANPm : rk(Oo :: A :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoANPeq HOoANPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAXNP *)
(* dans la couche 0 *)
Lemma LABpXNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: Bp :: X :: N :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpXNP requis par la preuve de (?)ABpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpXNP requis par la preuve de (?)ABpXNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)ABpXNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm2 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm3 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpXNP requis par la preuve de (?)ABpXNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: X :: N :: P ::  de rang :  3 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABpXNPm2 : rk(A :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpXNPmtmp : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABBpXNPeq HOoABBpXNPm3).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: Bp :: X :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: X :: N :: P :: nil) (Oo :: A :: B :: Bp :: A :: Bp :: X :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: Bp :: X :: N :: P :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: Bp :: X :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpXNPmtmp;try rewrite HT2 in HOoABBpXNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: Bp :: X :: N :: P :: nil) (A :: Bp :: nil) 3 2 3 HOoABBpXNPmtmp HABpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpXNPM1. try clear HOoABBpXNPM2. try clear HOoABBpXNPM3. try clear HOoABBpXNPm4. try clear HOoABBpXNPm3. try clear HOoABBpXNPm2. try clear HOoABBpXNPm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABpXNPM3 : rk(A :: Bp :: X :: N :: P :: nil) <= 3).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: X :: nil) (Bp :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: X :: N :: P :: nil) (A :: Bp :: X :: Bp :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: X :: Bp :: N :: P :: nil) ((A :: Bp :: X :: nil) ++ (Bp :: N :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Bp :: X :: nil) (Bp :: N :: P :: nil) (Bp :: nil) 2 2 1 HABpXMtmp HBpNPMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpXNPm3 : rk(A :: Bp :: X :: N :: P :: nil) >= 3).
{
	try assert(HABpNeq : rk(A :: Bp :: N :: nil) = 3) by (apply LABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpNmtmp : rk(A :: Bp :: N :: nil) >= 3) by (solve_hyps_min HABpNeq HABpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: N :: nil) (A :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: N :: nil) (A :: Bp :: X :: N :: P :: nil) 3 3 HABpNmtmp Hcomp Hincl);apply HT.
}


assert(HABpXNPM : rk(A :: Bp :: X :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpXNPm : rk(A :: Bp :: X :: N :: P ::  nil) >= 1) by (solve_hyps_min HABpXNPeq HABpXNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAXNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: X :: N :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AXNP requis par la preuve de (?)AXNP pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AXNP requis par la preuve de (?)AXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXNP requis par la preuve de (?)AXNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXNP requis par la preuve de (?)OoABXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXNP requis par la preuve de (?)OoABXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXNPm2 : rk(Oo :: A :: B :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXNPm3 : rk(Oo :: A :: B :: X :: N :: P :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: N :: P :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AXNP requis par la preuve de (?)AXNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: N :: P ::  de rang :  3 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HAXNPm2 : rk(A :: X :: N :: P :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXNPmtmp : rk(Oo :: A :: B :: X :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABXNPeq HOoABXNPm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (A :: X :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: N :: P :: nil) (Oo :: A :: B :: X :: A :: X :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: A :: X :: N :: P :: nil) ((Oo :: A :: B :: X :: nil) ++ (A :: X :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXNPmtmp;try rewrite HT2 in HOoABXNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (A :: X :: N :: P :: nil) (A :: X :: nil) 3 2 3 HOoABXNPmtmp HAXmtmp HOoABXMtmp Hincl); apply HT.
}
try clear HOoABXNPM1. try clear HOoABXNPM2. try clear HOoABXNPM3. try clear HOoABXNPm4. try clear HOoABXNPm3. try clear HOoABXNPm2. try clear HOoABXNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAXNPm3 : rk(A :: X :: N :: P :: nil) >= 3).
{
	try assert(HANPeq : rk(A :: N :: P :: nil) = 3) by (apply LANP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: N :: P :: nil) (A :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: N :: P :: nil) (A :: X :: N :: P :: nil) 3 3 HANPmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAXNPM3 : rk(A :: X :: N :: P :: nil) <= 3).
{
	try assert(HABpXNPeq : rk(A :: Bp :: X :: N :: P :: nil) = 3) by (apply LABpXNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HABpXNPMtmp : rk(A :: Bp :: X :: N :: P :: nil) <= 3) by (solve_hyps_max HABpXNPeq HABpXNPM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: X :: N :: P :: nil) (A :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: X :: N :: P :: nil) (A :: Bp :: X :: N :: P :: nil) 3 3 HABpXNPMtmp Hcomp Hincl);apply HT.
}


assert(HAXNPM : rk(A :: X :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAXNPm : rk(A :: X :: N :: P ::  nil) >= 1) by (solve_hyps_min HAXNPeq HAXNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: M :: N :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AMNP requis par la preuve de (?)AMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AMNP requis par la preuve de (?)AMNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABMNP requis par la preuve de (?)AMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMNP requis par la preuve de (?)OoABMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMNP requis par la preuve de (?)OoABMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMNPm2 : rk(Oo :: A :: B :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMNPm3 : rk(Oo :: A :: B :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: N :: P :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AMNP requis par la preuve de (?)AMNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: M :: N :: P ::  de rang :  3 et 4 	 AiB : A :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HAMNPm2 : rk(A :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	assert(HOoABMNPmtmp : rk(Oo :: A :: B :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABMNPeq HOoABMNPm3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: N :: P :: nil) (Oo :: A :: B :: M :: A :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: M :: N :: P :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABMNPmtmp;try rewrite HT2 in HOoABMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: M :: N :: P :: nil) (A :: M :: nil) 3 2 3 HOoABMNPmtmp HAMmtmp HOoABMMtmp Hincl); apply HT.
}
try clear HAMM1. try clear HAMM2. try clear HAMM3. try clear HAMm4. try clear HAMm3. try clear HAMm2. try clear HAMm1. try clear HOoABMNPM1. try clear HOoABMNPM2. try clear HOoABMNPM3. try clear HOoABMNPm4. try clear HOoABMNPm3. try clear HOoABMNPm2. try clear HOoABMNPm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAMNPM3 : rk(A :: M :: N :: P :: nil) <= 3).
{
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	try assert(HAMPeq : rk(A :: M :: P :: nil) = 2) by (apply LAMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMPMtmp : rk(A :: M :: P :: nil) <= 2) by (solve_hyps_max HAMPeq HAMPM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (N :: nil) (A :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: M :: N :: P :: nil) (N :: A :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: A :: M :: P :: nil) ((N :: nil) ++ (A :: M :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (N :: nil) (A :: M :: P :: nil) (nil) 1 2 0 HNMtmp HAMPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAMNPm3 : rk(A :: M :: N :: P :: nil) >= 3).
{
	try assert(HANPeq : rk(A :: N :: P :: nil) = 3) by (apply LANP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: N :: P :: nil) (A :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: N :: P :: nil) (A :: M :: N :: P :: nil) 3 3 HANPmtmp Hcomp Hincl);apply HT.
}


assert(HAMNPM : rk(A :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAMNPm : rk(A :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HAMNPeq HAMNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAXMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: X :: M :: N :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AXMNP requis par la preuve de (?)AXMNP pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AXMNP requis par la preuve de (?)AXMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMNP requis par la preuve de (?)AXMNP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMNP requis par la preuve de (?)OoABXMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMNP requis par la preuve de (?)OoABXMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNPm2 : rk(Oo :: A :: B :: X :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNPm3 : rk(Oo :: A :: B :: X :: M :: N :: P :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: P :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AXMNP requis par la preuve de (?)AXMNP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: X :: M :: N :: P ::  de rang :  3 et 4 	 AiB : A :: X ::  de rang :  2 et 2 	 A : Oo :: A :: B :: X ::   de rang : 3 et 3 *)
assert(HAXMNPm2 : rk(A :: X :: M :: N :: P :: nil) >= 2).
{
	try assert(HOoABXeq : rk(Oo :: A :: B :: X :: nil) = 3) by (apply LOoABX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABXMtmp : rk(Oo :: A :: B :: X :: nil) <= 3) by (solve_hyps_max HOoABXeq HOoABXM3).
	assert(HOoABXMNPmtmp : rk(Oo :: A :: B :: X :: M :: N :: P :: nil) >= 3) by (solve_hyps_min HOoABXMNPeq HOoABXMNPm3).
	try assert(HAXeq : rk(A :: X :: nil) = 2) by (apply LAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXmtmp : rk(A :: X :: nil) >= 2) by (solve_hyps_min HAXeq HAXm2).
	assert(Hincl : incl (A :: X :: nil) (list_inter (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: X :: M :: N :: P :: nil) (Oo :: A :: B :: X :: A :: X :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: X :: A :: X :: M :: N :: P :: nil) ((Oo :: A :: B :: X :: nil) ++ (A :: X :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABXMNPmtmp;try rewrite HT2 in HOoABXMNPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: X :: nil) (A :: X :: M :: N :: P :: nil) (A :: X :: nil) 3 2 3 HOoABXMNPmtmp HAXmtmp HOoABXMtmp Hincl); apply HT.
}
try clear HOoABXMNPM1. try clear HOoABXMNPM2. try clear HOoABXMNPM3. try clear HOoABXMNPm4. try clear HOoABXMNPm3. try clear HOoABXMNPm2. try clear HOoABXMNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAXMNPm3 : rk(A :: X :: M :: N :: P :: nil) >= 3).
{
	try assert(HANPeq : rk(A :: N :: P :: nil) = 3) by (apply LANP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: N :: P :: nil) (A :: X :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: N :: P :: nil) (A :: X :: M :: N :: P :: nil) 3 3 HANPmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAXMNPM3 : rk(A :: X :: M :: N :: P :: nil) <= 3).
{
	try assert(HAXNPeq : rk(A :: X :: N :: P :: nil) = 3) by (apply LAXNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAXNPMtmp : rk(A :: X :: N :: P :: nil) <= 3) by (solve_hyps_max HAXNPeq HAXNPM3).
	try assert(HAMNPeq : rk(A :: M :: N :: P :: nil) = 3) by (apply LAMNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAMNPMtmp : rk(A :: M :: N :: P :: nil) <= 3) by (solve_hyps_max HAMNPeq HAMNPM3).
	try assert(HANPeq : rk(A :: N :: P :: nil) = 3) by (apply LANP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HANPmtmp : rk(A :: N :: P :: nil) >= 3) by (solve_hyps_min HANPeq HANPm3).
	assert(Hincl : incl (A :: N :: P :: nil) (list_inter (A :: X :: N :: P :: nil) (A :: M :: N :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: X :: M :: N :: P :: nil) (A :: X :: N :: P :: A :: M :: N :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: X :: N :: P :: A :: M :: N :: P :: nil) ((A :: X :: N :: P :: nil) ++ (A :: M :: N :: P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: X :: N :: P :: nil) (A :: M :: N :: P :: nil) (A :: N :: P :: nil) 3 3 3 HAXNPMtmp HAMNPMtmp HANPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HAXMNPM : rk(A :: X :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAXMNPm : rk(A :: X :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HAXMNPeq HAXMNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBpYZMNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: C :: Bp :: Y :: Z :: M :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)ACBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)ACBpYZMNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpYZMNP requis par la preuve de (?)ACBpYZMNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpYZMNPm2 : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpYZMNPm3 : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 3).
{
	try assert(HACBpeq : rk(A :: C :: Bp :: nil) = 3) by (apply LACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 3) by (solve_hyps_min HACBpeq HACBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Bp :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Bp :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) 3 3 HACBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpYZMNPm4 : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) >= 4).
{
	try assert(HACBpMeq : rk(A :: C :: Bp :: M :: nil) = 4) by (apply LACBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HACBpMmtmp : rk(A :: C :: Bp :: M :: nil) >= 4) by (solve_hyps_min HACBpMeq HACBpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: Y :: Z :: M :: N :: P :: nil) 4 4 HACBpMmtmp Hcomp Hincl);apply HT.
}


assert(HACBpYZMNPM : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpYZMNPm : rk(A :: C :: Bp :: Y :: Z :: M :: N :: P ::  nil) >= 1) by (solve_hyps_min HACBpYZMNPeq HACBpYZMNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(A :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AMQ requis par la preuve de (?)AMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AMQ requis par la preuve de (?)AMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HAMQm2 : rk(A :: M :: Q :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMQmtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAApMQeq HOoAApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (A :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: Ap :: A :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: A :: M :: Q :: nil) ((Oo :: Ap :: nil) ++ (A :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQmtmp;try rewrite HT2 in HOoAApMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (A :: M :: Q :: nil) (nil) 4 0 2 HOoAApMQmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAMQm3 : rk(A :: M :: Q :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HAApMQeq : rk(A :: Ap :: M :: Q :: nil) = 3) by (apply LAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HAApMQmtmp : rk(A :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HAApMQeq HAApMQm3).
	try assert(HMQeq : rk(M :: Q :: nil) = 2) by (apply LMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (A :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: nil) (A :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: Q :: Ap :: M :: Q :: nil) ((A :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMQmtmp;try rewrite HT2 in HAApMQmtmp.
	assert(HT := rule_2 (A :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 3 2 2 HAApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


assert(HAMQM : rk(A :: M :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAMQeq HAMQM3).
assert(HAMQm : rk(A :: M :: Q ::  nil) >= 1) by (solve_hyps_min HAMQeq HAMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(B :: M :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BMQ requis par la preuve de (?)BMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BMQ requis par la preuve de (?)BMQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HBMQm2 : rk(B :: M :: Q :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoBApMQeq : rk(Oo :: B :: Ap :: M :: Q :: nil) = 4) by (apply LOoBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoBApMQmtmp : rk(Oo :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoBApMQeq HOoBApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (B :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Q :: nil) (Oo :: Ap :: B :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: B :: M :: Q :: nil) ((Oo :: Ap :: nil) ++ (B :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMQmtmp;try rewrite HT2 in HOoBApMQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (B :: M :: Q :: nil) (nil) 4 0 2 HOoBApMQmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBMQm3 : rk(B :: M :: Q :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBApMQeq : rk(B :: Ap :: M :: Q :: nil) = 3) by (apply LBApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HBApMQmtmp : rk(B :: Ap :: M :: Q :: nil) >= 3) by (solve_hyps_min HBApMQeq HBApMQm3).
	try assert(HMQeq : rk(M :: Q :: nil) = 2) by (apply LMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (B :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: nil) (B :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: M :: Q :: Ap :: M :: Q :: nil) ((B :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQmtmp;try rewrite HT2 in HBApMQmtmp.
	assert(HT := rule_2 (B :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 3 2 2 HBApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


assert(HBMQM : rk(B :: M :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBMQeq HBMQM3).
assert(HBMQm : rk(B :: M :: Q ::  nil) >= 1) by (solve_hyps_min HBMQeq HBMQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABMQ *)
(* dans la couche 0 *)
Lemma LOoABApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABApMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMQ requis par la preuve de (?)OoABApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMQm2 : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApMQm3 : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (C :: Oo :: A :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: M :: Q :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil) (nil) 4 0 1 HOoABCApMQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABApMQm4 : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoABCApMQeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) = 4) by (apply LOoABCApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABCApMQmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApMQeq HOoABCApMQm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Q :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQmtmp;try rewrite HT2 in HOoABCApMQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMQmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABApMQM : rk(Oo :: A :: B :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMQm : rk(Oo :: A :: B :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoABApMQeq HOoABApMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABMQ requis par la preuve de (?)OoABMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMQ requis par la preuve de (?)OoABMQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMQ requis par la preuve de (?)OoABMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMQm2 : rk(Oo :: A :: B :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoABMQm3 : rk(Oo :: A :: B :: M :: Q :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoABApMQeq : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) = 4) by (apply LOoABApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMQmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABApMQeq HOoABApMQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: B :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: nil) (Ap :: Oo :: A :: B :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: B :: M :: Q :: nil) ((Ap :: nil) ++ (Oo :: A :: B :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQmtmp;try rewrite HT2 in HOoABApMQmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: B :: M :: Q :: nil) (nil) 4 0 1 HOoABApMQmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABMQm4 : rk(Oo :: A :: B :: M :: Q :: nil) >= 4).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HOoABApMQeq : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) = 4) by (apply LOoABApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoABApMQmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoABApMQeq HOoABApMQm4).
	try assert(HMQeq : rk(M :: Q :: nil) = 2) by (apply LMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HMQmtmp : rk(M :: Q :: nil) >= 2) by (solve_hyps_min HMQeq HMQm2).
	assert(Hincl : incl (M :: Q :: nil) (list_inter (Oo :: A :: B :: M :: Q :: nil) (Ap :: M :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: nil) (Oo :: A :: B :: M :: Q :: Ap :: M :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: Q :: Ap :: M :: Q :: nil) ((Oo :: A :: B :: M :: Q :: nil) ++ (Ap :: M :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQmtmp;try rewrite HT2 in HOoABApMQmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: M :: Q :: nil) (Ap :: M :: Q :: nil) (M :: Q :: nil) 4 2 2 HOoABApMQmtmp HMQmtmp HApMQMtmp Hincl);apply HT.
}


assert(HOoABMQM : rk(Oo :: A :: B :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABMQm : rk(Oo :: A :: B :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoABMQeq HOoABMQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: Ap :: M :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQ requis par la preuve de (?)OoABApMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMNQM : rk(Oo :: A :: B :: Ap :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMNQm : rk(Oo :: A :: B :: Ap :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoABApMNQeq HOoABApMNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABXMNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: X :: M :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABXMNQ requis par la preuve de (?)OoABXMNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm2 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm3 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABXMNQm4 : rk(Oo :: A :: B :: X :: M :: N :: Q :: nil) >= 4).
{
	try assert(HOoAMQeq : rk(Oo :: A :: M :: Q :: nil) = 4) by (apply LOoAMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAMQmtmp : rk(Oo :: A :: M :: Q :: nil) >= 4) by (solve_hyps_min HOoAMQeq HOoAMQm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: Q :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: Q :: nil) (Oo :: A :: B :: X :: M :: N :: Q :: nil) 4 4 HOoAMQmtmp Hcomp Hincl);apply HT.
}


assert(HOoABXMNQM : rk(Oo :: A :: B :: X :: M :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABXMNQm : rk(Oo :: A :: B :: X :: M :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoABXMNQeq HOoABXMNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAXMNPQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Oo :: A :: X :: M :: N :: P :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAXMNPQ requis par la preuve de (?)OoAXMNPQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNPQm2 : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNPQm3 : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 3).
{
	try assert(HOoAXeq : rk(Oo :: A :: X :: nil) = 3) by (apply LOoAX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAXmtmp : rk(Oo :: A :: X :: nil) >= 3) by (solve_hyps_min HOoAXeq HOoAXm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: X :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil) 3 3 HOoAXmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAXMNPQm4 : rk(Oo :: A :: X :: M :: N :: P :: Q :: nil) >= 4).
{
	try assert(HOoANPeq : rk(Oo :: A :: N :: P :: nil) = 4) by (apply LOoANP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoANPmtmp : rk(Oo :: A :: N :: P :: nil) >= 4) by (solve_hyps_min HOoANPeq HOoANPm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: P :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: P :: nil) (Oo :: A :: X :: M :: N :: P :: Q :: nil) 4 4 HOoANPmtmp Hcomp Hincl);apply HT.
}


assert(HOoAXMNPQM : rk(Oo :: A :: X :: M :: N :: P :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAXMNPQm : rk(Oo :: A :: X :: M :: N :: P :: Q ::  nil) >= 1) by (solve_hyps_min HOoAXMNPQeq HOoAXMNPQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LYZMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(A :: M :: P ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P ::  nil) = 4 ->
rk(Bp :: N :: P ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P ::  nil) = 4 -> rk(Ap :: M :: Q ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q ::  nil) = 4 -> rk(B :: N :: Q ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q ::  nil) = 4 ->
rk(A :: B :: M :: N :: P :: Q ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q ::  nil) = 4 -> rk(Y :: Z :: M :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HAMPeq HOoAApBpCpMPeq HBpNPeq HOoABCBpNPeq HApMQeq HOoABCApMQeq HBNQeq HOoBApBpCpNQeq
HABMNPQeq HApBpMNPQeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour YZMN requis par la preuve de (?)YZMN pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour YZMN requis par la preuve de (?)YZMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour YZMN requis par la preuve de (?)YZMN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Y :: Z :: M :: N ::  de rang :  4 et 4 	 AiB : Y ::  de rang :  1 et 1 	 A : Oo :: A :: Ap :: Y ::   de rang : 3 et 3 *)
assert(HYZMNm2 : rk(Y :: Z :: M :: N :: nil) >= 2).
{
	try assert(HOoAApYeq : rk(Oo :: A :: Ap :: Y :: nil) = 3) by (apply LOoAApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApYMtmp : rk(Oo :: A :: Ap :: Y :: nil) <= 3) by (solve_hyps_max HOoAApYeq HOoAApYM3).
	try assert(HOoAApYZMNeq : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) = 4) by (apply LOoAApYZMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HOoAApYZMNmtmp : rk(Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) >= 4) by (solve_hyps_min HOoAApYZMNeq HOoAApYZMNm4).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (Oo :: A :: Ap :: Y :: nil) (Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Y :: Z :: M :: N :: nil) (Oo :: A :: Ap :: Y :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Y :: Y :: Z :: M :: N :: nil) ((Oo :: A :: Ap :: Y :: nil) ++ (Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApYZMNmtmp;try rewrite HT2 in HOoAApYZMNmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Y :: nil) (Y :: Z :: M :: N :: nil) (Y :: nil) 4 1 3 HOoAApYZMNmtmp HYmtmp HOoAApYMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: Y :: Z :: M :: N ::  de rang :  4 et 4 	 AiB : Z ::  de rang :  1 et 1 	 A : C :: Bp :: Z ::   de rang : 2 et 2 *)
assert(HYZMNm3 : rk(Y :: Z :: M :: N :: nil) >= 3).
{
	try assert(HCBpZeq : rk(C :: Bp :: Z :: nil) = 2) by (apply LCBpZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCBpZMtmp : rk(C :: Bp :: Z :: nil) <= 2) by (solve_hyps_max HCBpZeq HCBpZM2).
	try assert(HCBpYZMNeq : rk(C :: Bp :: Y :: Z :: M :: N :: nil) = 4) by (apply LCBpYZMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HCBpYZMNmtmp : rk(C :: Bp :: Y :: Z :: M :: N :: nil) >= 4) by (solve_hyps_min HCBpYZMNeq HCBpYZMNm4).
	try assert(HZeq : rk(Z :: nil) = 1) by (apply LZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HZmtmp : rk(Z :: nil) >= 1) by (solve_hyps_min HZeq HZm1).
	assert(Hincl : incl (Z :: nil) (list_inter (C :: Bp :: Z :: nil) (Y :: Z :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Y :: Z :: M :: N :: nil) (C :: Bp :: Z :: Y :: Z :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Z :: Y :: Z :: M :: N :: nil) ((C :: Bp :: Z :: nil) ++ (Y :: Z :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpYZMNmtmp;try rewrite HT2 in HCBpYZMNmtmp.
	assert(HT := rule_4 (C :: Bp :: Z :: nil) (Y :: Z :: M :: N :: nil) (Z :: nil) 4 1 2 HCBpYZMNmtmp HZmtmp HCBpZMtmp Hincl); apply HT.
}
try clear HCBpZM1. try clear HCBpZM2. try clear HCBpZM3. try clear HCBpZm4. try clear HCBpZm3. try clear HCBpZm2. try clear HCBpZm1. try clear HZM1. try clear HZM2. try clear HZM3. try clear HZm4. try clear HZm3. try clear HZm2. try clear HZm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HYZMNM3 : rk(Y :: Z :: M :: N :: nil) <= 3).
{
	try assert(HXYZMNeq : rk(X :: Y :: Z :: M :: N :: nil) = 3) by (apply LXYZMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) ;try assumption).
	assert(HXYZMNMtmp : rk(X :: Y :: Z :: M :: N :: nil) <= 3) by (solve_hyps_max HXYZMNeq HXYZMNM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Y :: Z :: M :: N :: nil) (X :: Y :: Z :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Y :: Z :: M :: N :: nil) (X :: Y :: Z :: M :: N :: nil) 3 3 HXYZMNMtmp Hcomp Hincl);apply HT.
}


assert(HYZMNM : rk(Y :: Z :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HYZMNm : rk(Y :: Z :: M :: N ::  nil) >= 1) by (solve_hyps_min HYZMNeq HYZMNm1).
intuition.
Qed.

