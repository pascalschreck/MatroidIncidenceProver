Require Export List.
Require Export Lia.
Require Export Morphisms.

Parameter Point : Set.
Parameter eq_dec : forall A B : Point, {A = B} + {~ A = B}.

Definition equivlist (l l':list Point) := forall x, List.In x l <-> List.In x l'.

Ltac simplgen H := simpl in H;generalize H.

Ltac my_inS :=
  intuition;unfold incl in *;unfold equivlist in *;
  repeat match goal with
  |[H : _ |- _] => progress intros
  |[H : _ |- _] => progress intro
  |[H : _ |- _] => progress intuition
  |[H : _ |- _] => split;intuition
  |[H : In _ (?P ::  _ ) |- _] => inversion H;clear H
  |[H : _ = _ |- _] => rewrite <-H
  |[H : In _ nil |- _] => inversion H
  end.

Parameter rk : list Point -> nat.
Parameter rk_compat : forall x x', equivlist x x' -> rk x = rk x'.

Global Instance rk_morph : Proper (equivlist ==> (@Logic.eq nat)) rk.
Proof.
intros;repeat red.
apply rk_compat.
Qed.

(*** Definition Inb ***)
Fixpoint Inb (a:Point) (l:list Point) {struct l} : bool :=
    match l with
      | nil => false
      | b :: m => if (eq_dec b a) then true else Inb a m
    end.

Lemma Inb_aux1 :
forall a l, Inb a l = true -> In a l.
Proof.
my_inS;induction l;my_inS.
- inversion H.
- simplgen H;case_eq(eq_dec a0 a);my_inS.
Qed.

Lemma Inb_aux2 :
forall a l, Inb a l = false -> ~In a l.
Proof.
my_inS;induction l;my_inS.
- rewrite H1 in *;simplgen H;case_eq(eq_dec a a);my_inS.
- simplgen H;case_eq(eq_dec a0 a);my_inS.
Qed.

(*** Definition list_inter ***)
Definition list_inter l1 l2 := filter (fun x : Point => Inb x l2) l1.

Lemma list_inter_split :
forall a l m, In a (list_inter l m) -> In a l /\ In a m.
Proof.
intros.
my_inS;induction l;my_inS.
- simplgen H;unfold list_inter;simpl;case_eq(Inb a0 m);my_inS.
- inversion H.
- simplgen H;unfold list_inter;simpl;case_eq(Inb a0 m);my_inS;apply Inb_aux1;my_inS.
Qed.

Lemma list_inter_closure :
forall a l m, In a m -> In a l -> In a (list_inter l m).
Proof.
my_inS;induction l;my_inS.
- simpl;case_eq(Inb a0 m);my_inS;assert(HH := Inb_aux2 a0 m H0);subst;my_inS.
- simpl;case_eq(Inb a0 m);my_inS.
Qed.

Ltac inv_unif :=
  unfold incl in *; try split; intros;
  repeat match goal with 
         | [H : In _ (?P ::  _ ) |- _] => inversion H;clear H
         | [H: _ = _ |- _] => rewrite <- H in *;try solve [contradiction|apply eq_sym in H;contradiction];clear H
         | [H : In _ nil |- _] => inversion H
         | [H : In _ (?L++?M) |- _] => apply in_app_iff in H; destruct H
         | [H :_ |- In _ (?L++?M) ] => apply in_app_iff
         | [H : In _ (list_inter _ _) |- _] => apply list_inter_split in H; destruct H
         | [H : _ |- In _ (list_inter _ _)] => apply list_inter_closure
         end.

Ltac solve_equivlist := first [apply in_eq | apply in_cons ; solve_equivlist].

Ltac my_inO := solve[inv_unif ; first[solve_equivlist | left;solve_equivlist | right;solve_equivlist]].

Parameter matroid1_a  : forall X, rk X >= 0.
Parameter matroid1_b : forall X, rk X <= length X.
Parameter matroid2 : forall X Y, incl X Y -> rk X <= rk Y.
Parameter matroid3 : forall X Y, rk(X ++ Y) + rk(list_inter X Y) <= rk X + rk Y.

(*** Lemmes matroides utiles ***)
Lemma matroid1_b_useful : forall (l : list Point) (m : nat), length l <= m -> rk l <= m.
Proof.
intros.
assert(HH := matroid1_b l).
lia.
Qed.

Lemma matroid3_useful : forall e e' ei : list Point,
 incl ei (list_inter e e') ->
 rk(e ++ e') + rk(ei) <= rk(e) + rk(e').
Proof.
intros.
assert (rk (e ++ e') + rk (list_inter e e') <= rk e + rk e').
apply matroid3.
assert (rk (ei) <= rk (list_inter e e')).
apply matroid2;auto.
lia.
Qed.

Lemma couple_equal : forall A B, rk(A :: B :: nil) = rk(B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_1 : forall A B C, rk(A :: B :: C :: nil) = rk(A :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_2 : forall A B C, rk(A :: B :: C :: nil) = rk(B :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_3 : forall A B C, rk(A :: B :: C :: nil) = rk(B :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_4 : forall A B C, rk(A :: B :: C :: nil) = rk(C :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma triple_equal_5 : forall A B C, rk(A :: B :: C :: nil) = rk(C :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma rk_triple_max_3 : forall X Y Z : Point, rk(X :: Y :: Z :: nil) <= 3.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_quadruple_max_4 : forall W X Y Z : Point,rk(W :: X :: Y :: Z :: nil) <= 4.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma quadruple_equal_1 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: B :: D :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_2 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: C :: B :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_3 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: C :: D :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_4 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: D :: B :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_5 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(A :: D :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_6 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: A :: C :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_7 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: A :: D :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_8 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: C :: A :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_9 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: C :: D :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_10 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: D :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_11 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(B :: D :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_12 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: A :: B :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_13 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: A :: D :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_14 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: B :: A :: D :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_15 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: B :: D :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_16 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: D :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_17 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(C :: D :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_18 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: A :: B :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_19 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: A :: C :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_20 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: B :: A :: C :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_21 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: B :: C :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_22 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: C :: A :: B :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Lemma quadruple_equal_23 : forall A B C D, rk(A :: B :: C :: D :: nil) = rk(D :: C :: B :: A :: nil).
Proof.
intros;apply rk_morph;my_inO.
Qed.

Ltac clear_all_rk :=
repeat match goal with
| H : rk _ = _ |- _ => clear H
| H : rk _ >= _ |- _ => clear H
| H : rk _ <= _ |- _ => clear H
end.

Parameter rk_singleton_ge : forall A, rk (A :: nil)  >= 1.
Parameter rk_couple_ge : forall A B, ~ A = B -> rk(A :: B :: nil) >= 2.
Parameter rk_three_points_on_lines : forall A B, exists C, rk (A :: B :: C :: nil) = 2 /\ rk (B :: C :: nil) = 2 /\ rk (A :: C :: nil) = 2.
Parameter rk_inter : forall A B C D, rk(A :: B :: C :: D :: nil) <= 3 -> exists J : Point, rk(A :: B :: J :: nil) = 2 /\ rk (C :: D :: J :: nil) = 2.
Parameter rk_lower_dim : exists A0 A1 A2 A3, rk( A0 :: A1 :: A2 :: A3 :: nil) = 4.
Parameter rk_upper_dim : forall e, rk(e) <= 4.

Lemma rk_singleton_1 : forall A, rk(A :: nil) <= 1.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_singleton : forall A, rk(A :: nil) = 1.
Proof.
intros.
assert(H := rk_singleton_ge A).
assert(HH := rk_singleton_1 A).
lia.
Qed.

Lemma matroid1_b_useful2 : forall (l : list Point) (a : Point), length (a :: l) >= 1 -> rk (a :: l) >= 1.
Proof.
intros.
assert(HH := rk_singleton a).
assert(HH0 := matroid2 (a :: nil) (a :: l)).
assert(HH1 : incl (a :: nil) (a :: l));[my_inO|].
assert(HH2 := HH0 HH1).
lia.
Qed.

Lemma rk_couple_2 : forall A B, rk(A :: B :: nil) <= 2.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma rk_couple : forall A B : Point,~ A = B -> rk(A :: B :: nil) = 2.
Proof.
intros.
assert(HH := rk_couple_2 A B).
assert(HH0 := rk_couple_ge A B H).
lia.
Qed.

Lemma rk_triple_3 : forall A B C : Point, rk (A :: B :: C :: nil) <= 3.
Proof.
intros.
apply matroid1_b_useful.
intuition.
Qed.

Lemma couple_rk1 : forall A B, rk(A :: B :: nil) = 2 -> ~ A = B.
Proof.
intros.
intro.
rewrite H0 in H.
assert(HH : equivlist (B :: B :: nil) (B :: nil));[my_inO|].
rewrite HH in H.
assert(HH0 := rk_singleton_1 B).
lia.
Qed.

Lemma couple_rk2 : forall A B, rk(A :: B :: nil) = 1 -> A = B.
Proof.
intros.
case_eq(eq_dec A B).
intros.
assumption.
intros.
assert(HH := rk_couple A B n).
lia.
Qed.

Lemma rule_1 : forall A B AiB, forall MA MB mAiB, 
rk(A) <= MA -> rk(B) <= MB -> rk(AiB) >= mAiB -> incl AiB (list_inter A B) ->
rk(A ++ B) <= MA + MB - mAiB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_2 : forall A B AiB, forall mAuB mAiB MB, 
rk(A ++ B) >= mAuB -> rk(AiB) >= mAiB -> rk(B) <= MB -> incl AiB (list_inter A B) ->
rk(A) >= mAuB + mAiB - MB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_3 : forall A B AiB, forall MA MB mAuB, 
rk(A) <= MA -> rk(B) <= MB -> rk(A ++ B) >= mAuB -> incl AiB (list_inter A B) ->
rk(AiB) <= MA + MB - mAuB.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_4 : forall A B AiB, forall mAuB mAiB MA, 
rk(A ++ B) >= mAuB -> rk(AiB) >= mAiB -> rk(A) <= MA -> incl AiB (list_inter A B) ->
rk(B) >= mAuB + mAiB - MA.
Proof.
intros.
assert(HH := matroid3_useful A B AiB H2).
lia.
Qed.

Lemma rule_5 : forall A B, forall mA mB, 
rk(A) >= mA -> mA >= mB -> incl A B ->
rk(B) >= mA.
Proof.
intros.
assert(HH := matroid2 A B H1).
lia.
Qed.

Lemma rule_6 : forall A B, forall MA MB, 
rk(B) <= MB -> MB <= MA -> incl A B ->
rk(A) <= MB.
Proof.
intros.
assert(HH := matroid2 A B H1).
lia.
Qed.

Lemma rule_7 : forall A B, forall mA mB, 
rk(B) >= mB -> mB >= mA -> incl B A ->
rk(A) >= mB.
Proof.
intros.
assert(HH := matroid2 B A H1).
lia.
Qed.

Lemma rule_8 : forall A B, forall MA MB, 
rk(A) <= MA -> MA <= MB -> incl B A ->
rk(B) <= MA.
Proof.
intros.
assert(HH := matroid2 B A H1).
lia.
Qed.

Parameter rk_pappus : forall A B C D E F G H I,
rk(A :: B :: nil) = 2 -> rk(A :: C :: nil) = 2 -> rk(A :: D :: nil) = 2 -> 
rk(A :: E :: nil) = 2 -> rk(A :: F :: nil) = 2 ->
rk(B :: C :: nil) = 2 -> rk(B :: D :: nil) = 2 -> rk(B :: E :: nil) = 2 ->
rk(B :: F :: nil) = 2 ->
rk(C :: D :: nil) = 2 -> rk(C :: E :: nil) = 2 -> rk(C :: F :: nil) = 2 ->
rk(D :: E :: nil) = 2 -> rk(D :: F :: nil) = 2 ->
rk(E :: F :: nil) = 2 ->
rk(A :: B :: C :: nil) = 2 -> rk(D :: E :: F :: nil) = 2 -> 
rk(A :: E :: G :: nil) = 2 -> rk(B :: D :: G :: nil) = 2 ->
rk(A :: F :: H :: nil) = 2 -> rk(C :: D :: H :: nil) = 2 ->
rk(B :: F :: I :: nil) = 2 -> rk(C :: E :: I :: nil) = 2 -> rk(G :: H :: I :: nil) = 2.

Ltac rk_couple_triple :=
  match goal with

| H : rk(?A :: ?B :: nil) = 2 |- rk(?A :: ?B :: nil) = 2 => assumption
| H : rk(?B :: ?A :: nil) = 2 |- rk(?A :: ?B :: nil) = 2 => rewrite couple_equal in H;assumption

| H : rk(?A :: ?B :: ?C :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => assumption
| H : rk(?A :: ?C :: ?B :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_1 in H;assumption
| H : rk(?B :: ?A :: ?C :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_2 in H;assumption
| H : rk(?B :: ?C :: ?A :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_3 in H;assumption
| H : rk(?C :: ?A :: ?B :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_4 in H;assumption
| H : rk(?C :: ?B :: ?A :: nil) = _ |-  rk(?A :: ?B :: ?C :: nil) = _ => rewrite <-triple_equal_5 in H;assumption
end.


Ltac clear_ineg_rk :=
repeat match goal with
| H : rk _ >= _ |- _ => clear H
| H : rk _ <= _ |- _ => clear H
end.


Ltac equalize_pts :=
repeat match goal with
| H : rk (?X0 :: ?X1 :: nil) = 1 |- _ => 
          let HH := fresh in assert(HH := couple_rk2 X0 X1 H);clear H;rewrite HH
end.

Ltac eliminate_hyps :=
repeat match goal with
| H : rk ?X = _, H0 : rk ?X >= _ |- _ => clear H0
| H : rk ?X = _, H0 : rk ?X <= _ |- _ => clear H0
| H : rk ?X >= _, H0 : rk ?X >= _ |- _ => clear H
| H : rk ?X <= _, H0 : rk ?X <= _ |- _ => clear H
| H : rk ?X >= ?Y, H0 : rk ?X <= ?Y |- _ =>  let HH := fresh in assert(HH : rk X = Y) by (lia)
end.

Lemma le_S_sym : forall n m : nat,
n >= S m -> n >= m.
Proof.
intros.
intuition.
Qed.

Lemma eq_to_ge : forall n m : nat,
n = m -> n >= m.
Proof.
intros.
lia.
Qed.

Lemma eq_to_le : forall n m : nat,
n = m -> n <= m.
Proof.
intros.
lia.
Qed.

Lemma eq_le_incl : forall n m, n = m -> n <= m.
Proof.
  intros; lia.
Qed.

Ltac solve_hyps_max H H0 :=
solve[apply matroid1_b_useful;simpl;repeat constructor
|apply rk_upper_dim
|apply eq_le_incl;apply H
|apply eq_le_incl;apply eq_sym;apply H
|apply H0
|apply le_S;apply H0
|apply le_S;apply le_S;apply H0
|apply le_S;apply le_S;apply le_S;apply H0
|lia
].

Ltac solve_hyps_min H H0:=
solve[apply matroid1_b_useful2;simpl;repeat constructor
|apply matroid1_a
|apply eq_le_incl;apply H
|apply eq_le_incl;apply eq_sym;apply H
|apply H0
|apply le_S_sym;apply H0
|apply le_S_sym;apply le_S_sym;apply H0
|apply le_S_sym;apply le_S_sym;apply le_S_sym;apply H0
|lia
].
 



(* dans la couche 0 *)
Lemma LOo : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LA : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HAM : rk(A ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAeq HAM1).
assert(HAm : rk(A ::  nil) >= 1) by (solve_hyps_min HAeq HAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoA : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoAM : rk(Oo :: A ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoAeq HOoAM2).
assert(HOoAm : rk(Oo :: A ::  nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LB : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBM : rk(B ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBeq HBM1).
assert(HBm : rk(B ::  nil) >= 1) by (solve_hyps_min HBeq HBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoB : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoBM : rk(Oo :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBeq HOoBM2).
assert(HOoBm : rk(Oo :: B ::  nil) >= 1) by (solve_hyps_min HOoBeq HOoBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAB : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HABM : rk(A :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABeq HABM2).
assert(HABm : rk(A :: B ::  nil) >= 1) by (solve_hyps_min HABeq HABm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAB *)
(* dans la couche 0 *)
Lemma LOoABC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoABCM : rk(Oo :: A :: B :: C ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCm : rk(Oo :: A :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoABCeq HOoABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAB : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABM2 : rk(Oo :: A :: B :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoABM : rk(Oo :: A :: B ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABeq HOoABM3).
assert(HOoABm : rk(Oo :: A :: B ::  nil) >= 1) by (solve_hyps_min HOoABeq HOoABm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HCM : rk(C ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCeq HCM1).
assert(HCm : rk(C ::  nil) >= 1) by (solve_hyps_min HCeq HCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoCM : rk(Oo :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCeq HOoCM2).
assert(HOoCm : rk(Oo :: C ::  nil) >= 1) by (solve_hyps_min HOoCeq HOoCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACm2 : rk(Oo :: A :: C :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACM2 : rk(Oo :: A :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoACM : rk(Oo :: A :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACeq HOoACM3).
assert(HOoACm : rk(Oo :: A :: C ::  nil) >= 1) by (solve_hyps_min HOoACeq HOoACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCm2 : rk(Oo :: B :: C :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCM2 : rk(Oo :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoBCM : rk(Oo :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBCeq HOoBCM3).
assert(HOoBCm : rk(Oo :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoBCeq HOoBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABC : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCM2 : rk(A :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

assert(HABCM : rk(A :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCeq HABCM3).
assert(HABCm : rk(A :: B :: C ::  nil) >= 1) by (solve_hyps_min HABCeq HABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HApM : rk(Ap ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HApeq HApM1).
assert(HApm : rk(Ap ::  nil) >= 1) by (solve_hyps_min HApeq HApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoApM : rk(Oo :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoApeq HOoApM2).
assert(HOoApm : rk(Oo :: Ap ::  nil) >= 1) by (solve_hyps_min HOoApeq HOoApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAAp *)
(* dans la couche 0 *)
Lemma LOoAAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoAApM : rk(Oo :: A :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAApeq HOoAApM3).
assert(HOoAApm : rk(Oo :: A :: Ap ::  nil) >= 1) by (solve_hyps_min HOoAApeq HOoAApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)AAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HAApm2 : rk(A :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: nil) (Oo :: A :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: Ap :: nil) ((Oo :: A :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApmtmp;try rewrite HT2 in HOoAApmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HOoAApmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


assert(HAApM : rk(A :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAApeq HAApM2).
assert(HAApm : rk(A :: Ap ::  nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans constructLemma(), requis par LBApMSp *)
(* dans constructLemma(), requis par LOoBCApMSp *)
(* dans la couche 0 *)
Lemma LOoABCApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoABCApMSpM : rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApMSpm : rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMSp requis par la preuve de (?)OoBCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMSp requis par la preuve de (?)OoBCApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMSpm3 : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMSpmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoBCApMSpm4 : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: Oo :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: nil) 4 2 2 HOoABCApMSpmtmp HOoBmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoBCApMSpM : rk(Oo :: B :: C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApMSpm : rk(Oo :: B :: C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBCApMSpeq HOoBCApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: M :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApMSp requis par la preuve de (?)BApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMSp requis par la preuve de (?)BApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMSp requis par la preuve de (?)BCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMSp requis par la preuve de (?)BCApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCApMSpm2 : rk(B :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: nil) ++ (B :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Ap :: M :: Sp :: nil) (nil) 4 0 2 HOoABCApMSpmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApMSpm3 : rk(B :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Sp :: nil) (B :: nil) 4 1 2 HOoABCApMSpmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApMSp requis par la preuve de (?)BApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApMSp requis par la preuve de (?)BApMSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApMSp requis par la preuve de (?)BApMSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBApMSpM3 : rk(B :: Ap :: M :: Sp :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Sp :: nil) (B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: M :: Sp :: nil) ((B :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: M :: Sp :: nil) (nil) 1 2 0 HBMtmp HApMSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: M :: Sp ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HBApMSpm2 : rk(B :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBCApMSpmtmp : rk(B :: C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HBCApMSpeq HBCApMSpm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Sp :: nil) (C :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: B :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMSpmtmp;try rewrite HT2 in HBCApMSpmtmp.
	assert(HT := rule_4 (C :: nil) (B :: Ap :: M :: Sp :: nil) (nil) 3 0 1 HBCApMSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HBCApMSpM1. try clear HBCApMSpM2. try clear HBCApMSpM3. try clear HBCApMSpm4. try clear HBCApMSpm3. try clear HBCApMSpm2. try clear HBCApMSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBApMSpm3 : rk(B :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMSpeq : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoBCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMSpeq HOoBCApMSpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: C :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: Ap :: M :: Sp :: nil) ((Oo :: B :: C :: nil) ++ (B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMSpmtmp;try rewrite HT2 in HOoBCApMSpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: Ap :: M :: Sp :: nil) (B :: nil) 4 1 2 HOoBCApMSpmtmp HBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBApMSpM : rk(B :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApMSpm : rk(B :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HBApMSpeq HBApMSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HApMSpM : rk(Ap :: M :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMSpeq HApMSpM3).
assert(HApMSpm : rk(Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HApMSpeq HApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HBApMSpeq : rk(B :: Ap :: M :: Sp :: nil) = 3) by (apply LBApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMSpmtmp : rk(B :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HBApMSpeq HBApMSpm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Sp :: nil) (B :: Ap :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Ap :: M :: Sp :: nil) ((B :: Ap :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMSpmtmp;try rewrite HT2 in HBApMSpmtmp.
	assert(HT := rule_2 (B :: Ap :: nil) (Ap :: M :: Sp :: nil) (Ap :: nil) 3 1 2 HBApMSpmtmp HApmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBAp *)
(* dans la couche 0 *)
Lemma LOoBApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApMSp requis par la preuve de (?)OoBApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApMSp requis par la preuve de (?)OoBApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApMSp requis par la preuve de (?)OoBApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMSpm2 : rk(Oo :: B :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBApMSpm3 : rk(Oo :: B :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoBCApMSpeq : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoBCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMSpeq HOoBCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Sp :: nil) (C :: Oo :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (Oo :: B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMSpmtmp;try rewrite HT2 in HOoBCApMSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: B :: Ap :: M :: Sp :: nil) (nil) 4 0 1 HOoBCApMSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBApMSpm4 : rk(Oo :: B :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMSpeq : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoBCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMSpeq HOoBCApMSpm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: C :: Oo :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: B :: Ap :: M :: Sp :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMSpmtmp;try rewrite HT2 in HOoBCApMSpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: B :: Ap :: M :: Sp :: nil) (Oo :: B :: nil) 4 2 2 HOoBCApMSpmtmp HOoBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HOoBApMSpM : rk(Oo :: B :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMSpm : rk(Oo :: B :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApMSpeq HOoBApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApm2 : rk(Oo :: B :: Ap :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApm3 : rk(Oo :: B :: Ap :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoBApMSpeq : rk(Oo :: B :: Ap :: M :: Sp :: nil) = 4) by (apply LOoBApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMSpmtmp : rk(Oo :: B :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApMSpeq HOoBApMSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: B :: Ap :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Sp :: nil) (Oo :: B :: Ap :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: Ap :: M :: Sp :: nil) ((Oo :: B :: Ap :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMSpmtmp;try rewrite HT2 in HOoBApMSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: nil) (Ap :: M :: Sp :: nil) (Ap :: nil) 4 1 2 HOoBApMSpmtmp HApmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoBApM : rk(Oo :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBApeq HOoBApM3).
assert(HOoBApm : rk(Oo :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBApeq HOoBApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: nil) ((Oo :: A :: B :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Ap :: nil) (nil) 2 1 0 HOoABMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCAp *)
(* dans constructLemma(), requis par LCApMSp *)
(* dans la couche 0 *)
Lemma LOoACApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMSp requis par la preuve de (?)OoACApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMSp requis par la preuve de (?)OoACApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMSp requis par la preuve de (?)OoACApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpm2 : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACApMSpm3 : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (B :: Oo :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Ap :: M :: Sp :: nil) ((B :: nil) ++ (Oo :: A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil) (nil) 4 0 1 HOoABCApMSpmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACApMSpm4 : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: Oo :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMSpmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACApMSpM : rk(Oo :: A :: C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMSpm : rk(Oo :: A :: C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApMSp requis par la preuve de (?)CApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMSp requis par la preuve de (?)CApMSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMSp requis par la preuve de (?)CApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HCApMSpm2 : rk(C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (C :: Ap :: M :: Sp :: nil) (nil) 4 0 2 HOoABCApMSpmtmp Hmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCApMSpM3 : rk(C :: Ap :: M :: Sp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: nil) (C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: M :: Sp :: nil) (nil) 1 2 0 HCMtmp HApMSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HCApMSpm3 : rk(C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (C :: Ap :: M :: Sp :: nil) (C :: nil) 4 1 2 HOoACApMSpmtmp HCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HCApMSpM : rk(C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMSpm : rk(C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HCApMSpeq HCApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)CAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApm2 : rk(C :: Ap :: nil) >= 2).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCApMSpeq : rk(C :: Ap :: M :: Sp :: nil) = 3) by (apply LCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpmtmp : rk(C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HCApMSpeq HCApMSpm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: nil) (C :: Ap :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Ap :: M :: Sp :: nil) ((C :: Ap :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMSpmtmp;try rewrite HT2 in HCApMSpmtmp.
	assert(HT := rule_2 (C :: Ap :: nil) (Ap :: M :: Sp :: nil) (Ap :: nil) 3 1 2 HCApMSpmtmp HApmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HCApM : rk(C :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCApeq HCApM2).
assert(HCApm : rk(C :: Ap ::  nil) >= 1) by (solve_hyps_min HCApeq HCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCAp *)
(* dans la couche 0 *)
Lemma LOoCApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMSp requis par la preuve de (?)OoBCApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMSpm3 : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMSpmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Sp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCApMSpm2 : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCApMSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoBCApMSpeq HOoBCApMSpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: Oo :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Ap :: M :: Sp :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMSpmtmp;try rewrite HT2 in HOoBCApMSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 3 1 2 HOoBCApMSpmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCApMSpm3 : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: Oo :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMSpmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoCApMSpm4 : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hincl : incl (Oo :: C :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: Oo :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: C :: nil) 4 2 2 HOoACApMSpmtmp HOoCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoCApMSpM : rk(Oo :: C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMSpm : rk(Oo :: C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApMSpeq HOoCApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCAp requis par la preuve de (?)OoCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCAp requis par la preuve de (?)OoCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApm2 : rk(Oo :: C :: Ap :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApm3 : rk(Oo :: C :: Ap :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoCApMSpeq : rk(Oo :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMSpmtmp : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApMSpeq HOoCApMSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: C :: Ap :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: C :: Ap :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: Ap :: M :: Sp :: nil) ((Oo :: C :: Ap :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMSpmtmp;try rewrite HT2 in HOoCApMSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: nil) (Ap :: M :: Sp :: nil) (Ap :: nil) 4 1 2 HOoCApMSpmtmp HApmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoCApM : rk(Oo :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCApeq HOoCApM3).
assert(HOoCApm : rk(Oo :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoCApeq HOoCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: nil) ((Oo :: A :: C :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Ap :: nil) (nil) 2 1 0 HOoACMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBpM : rk(Bp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBpeq HBpM1).
assert(HBpm : rk(Bp ::  nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoBpM : rk(Oo :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBpeq HOoBpM2).
assert(HOoBpm : rk(Oo :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBpeq HOoBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoAApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoAApBpCpM3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HAMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpCpM : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpm : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoApBpCpM : rk(Oo :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpCpm : rk(Oo :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoAApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpm2 : rk(Oo :: A :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpm3 : rk(Oo :: A :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoAApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABpM : rk(Oo :: A :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABpeq HOoABpM3).
assert(HOoABpm : rk(Oo :: A :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABpeq HOoABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBp *)
(* dans constructLemma(), requis par LOoBApBpCp *)
(* dans la couche 0 *)
Lemma LOoABApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABApBpCpM3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoABMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpCpM : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpCpm : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBApBpCpM3 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HBMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpCpm2 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpCpm3 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpCpmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoBApBpCpM : rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpCpm : rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)BBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpm2 : rk(B :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoBApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HBBpM : rk(B :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBBpeq HBBpM2).
assert(HBBpm : rk(B :: Bp ::  nil) >= 1) by (solve_hyps_min HBBpeq HBBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBp requis par la preuve de (?)OoBBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBBp requis par la preuve de (?)OoBBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpm2 : rk(Oo :: B :: Bp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBBpm3 : rk(Oo :: B :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoBBpM : rk(Oo :: B :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBBpeq HOoBBpM3).
assert(HOoBBpm : rk(Oo :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBBpeq HOoBBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: nil) ((Oo :: A :: B :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Bp :: nil) (nil) 2 1 0 HOoABMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpm3 : rk(Oo :: A :: B :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABBpM : rk(Oo :: A :: B :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpm : rk(Oo :: A :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABBpeq HOoABBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBp *)
(* dans constructLemma(), requis par LOoCApBpCp *)
(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACApBpCpM3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoACMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoCApBpCpM3 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HCMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpCpm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpCpmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


assert(HOoCApBpCpM : rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpm : rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBp requis par la preuve de (?)CBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpm2 : rk(C :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoCApBpCpeq : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpmtmp;try rewrite HT2 in HOoCApBpCpmtmp.
	assert(HT := rule_2 (C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoCApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HCBpM : rk(C :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCBpeq HCBpM2).
assert(HCBpm : rk(C :: Bp ::  nil) >= 1) by (solve_hyps_min HCBpeq HCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpm2 : rk(Oo :: A :: C :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACBpM3 : rk(Oo :: A :: C :: Bp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: nil) (Oo :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: nil) ((Oo :: A :: C :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Bp :: nil) (nil) 2 1 0 HOoACMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACBpm3 : rk(Oo :: A :: C :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoACApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACBpM : rk(Oo :: A :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpm : rk(Oo :: A :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoACBpeq HOoACBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpm2 : rk(Oo :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpM2 : rk(Oo :: Ap :: Bp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpM : rk(Oo :: Ap :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApBpeq HOoApBpM3).
assert(HOoApBpm : rk(Oo :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoApBpeq HOoApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HCpM : rk(Cp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCpeq HCpM1).
assert(HCpm : rk(Cp ::  nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoCpM : rk(Oo :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCpeq HOoCpM2).
assert(HOoCpm : rk(Oo :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCpeq HOoCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ACp requis par la preuve de (?)ACp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpm2 : rk(A :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoAApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HACpM : rk(A :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACpeq HACpM2).
assert(HACpm : rk(A :: Cp ::  nil) >= 1) by (solve_hyps_min HACpeq HACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpm2 : rk(Oo :: A :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpm3 : rk(Oo :: A :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoAApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACpM : rk(Oo :: A :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACpeq HOoACpM3).
assert(HOoACpm : rk(Oo :: A :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACpeq HOoACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)BCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCpm2 : rk(B :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoBApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HBCpM : rk(B :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCpeq HBCpM2).
assert(HBCpm : rk(B :: Cp ::  nil) >= 1) by (solve_hyps_min HBCpeq HBCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans constructLemma(), requis par LABCpUV *)
(* dans constructLemma(), requis par LABCCpUV *)
(* dans la couche 0 *)
Lemma LOoABCCpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoABCCpUVM : rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpUVm : rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCCpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCpUV requis par la preuve de (?)ABCCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCpUV requis par la preuve de (?)ABCCpUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCCpUVm3 : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: A :: B :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Cp :: U :: V :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoABCCpUVmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCCpUVm4 : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: A :: B :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Cp :: U :: V :: nil) (A :: B :: nil) 4 2 2 HOoABCCpUVmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCCpUVM : rk(A :: B :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCCpUVm : rk(A :: B :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HABCCpUVeq HABCCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCpUV requis par la preuve de (?)ABCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpUV requis par la preuve de (?)ABCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpUV requis par la preuve de (?)ABCpUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpUVm2 : rk(A :: B :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: U :: V :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABCpUVm3 : rk(A :: B :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCCpUVeq : rk(A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCCpUVmtmp : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HABCCpUVeq HABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: U :: V :: nil) (C :: A :: B :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Cp :: U :: V :: nil) ((C :: nil) ++ (A :: B :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpUVmtmp;try rewrite HT2 in HABCCpUVmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Cp :: U :: V :: nil) (nil) 4 0 1 HABCCpUVmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABCpUVm4 : rk(A :: B :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCCpUVeq : rk(A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCCpUVmtmp : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HABCCpUVeq HABCCpUVm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: U :: V :: nil) (A :: B :: C :: A :: B :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Cp :: U :: V :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpUVmtmp;try rewrite HT2 in HABCCpUVmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Cp :: U :: V :: nil) (A :: B :: nil) 4 2 2 HABCCpUVmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABCpUVM : rk(A :: B :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpUVm : rk(A :: B :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HABCpUVeq HABCpUVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LCpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: U :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HCpUVM : rk(Cp :: U :: V ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCpUVeq HCpUVM3).
assert(HCpUVm : rk(Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HCpUVeq HCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCpm3 : rk(A :: B :: Cp :: nil) >= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HABCpUVeq : rk(A :: B :: Cp :: U :: V :: nil) = 4) by (apply LABCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpUVmtmp : rk(A :: B :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HABCpUVeq HABCpUVm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: U :: V :: nil) (A :: B :: Cp :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: Cp :: U :: V :: nil) ((A :: B :: Cp :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCpUVmtmp;try rewrite HT2 in HABCpUVmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (Cp :: U :: V :: nil) (Cp :: nil) 4 1 2 HABCpUVmtmp HCpmtmp HCpUVMtmp Hincl);apply HT.
}


assert(HABCpM : rk(A :: B :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCpeq HABCpM3).
assert(HABCpm : rk(A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HABCpeq HABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABCpM3 : rk(Oo :: A :: B :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Cp :: nil) (nil) 2 1 0 HOoABMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCpm3 : rk(Oo :: A :: B :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoABApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABCpM : rk(Oo :: A :: B :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpm : rk(Oo :: A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCpeq HOoABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)CCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCCpm2 : rk(C :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoCApBpCpeq : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpmtmp;try rewrite HT2 in HOoCApBpCpmtmp.
	assert(HT := rule_2 (C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoCApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HCCpM : rk(C :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCCpeq HCCpM2).
assert(HCCpm : rk(C :: Cp ::  nil) >= 1) by (solve_hyps_min HCCpeq HCCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACCp *)
(* dans constructLemma(), requis par LACCpUV *)
(* dans la couche 0 *)
Lemma LOoACCpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpUV requis par la preuve de (?)OoACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpUV requis par la preuve de (?)OoACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpUV requis par la preuve de (?)OoACCpUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpUVm2 : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACCpUVm3 : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (B :: Oo :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Cp :: U :: V :: nil) ((B :: nil) ++ (Oo :: A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil) (nil) 4 0 1 HOoABCCpUVmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACCpUVm4 : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: Oo :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil) (Oo :: A :: nil) 4 2 2 HOoABCCpUVmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACCpUVM : rk(Oo :: A :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpUVm : rk(Oo :: A :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HOoACCpUVeq HOoACCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm2 : rk(A :: C :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (nil) 4 0 2 HOoABCCpUVmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm3 : rk(A :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoABCCpUVmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACCpUVm4 : rk(A :: C :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACCpUVeq : rk(Oo :: A :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoACCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpUVmtmp : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoACCpUVeq HOoACCpUVm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: U :: V :: nil) (Oo :: A :: C :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpUVmtmp;try rewrite HT2 in HOoACCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Cp :: U :: V :: nil) (A :: C :: nil) 4 2 2 HOoACCpUVmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACCpUVM : rk(A :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpUVm : rk(A :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HACCpUVeq HACCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACCpm3 : rk(A :: C :: Cp :: nil) >= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HACCpUVeq : rk(A :: C :: Cp :: U :: V :: nil) = 4) by (apply LACCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpUVmtmp : rk(A :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HACCpUVeq HACCpUVm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: C :: Cp :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: U :: V :: nil) (A :: C :: Cp :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: Cp :: U :: V :: nil) ((A :: C :: Cp :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpUVmtmp;try rewrite HT2 in HACCpUVmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (Cp :: U :: V :: nil) (Cp :: nil) 4 1 2 HACCpUVmtmp HCpmtmp HCpUVMtmp Hincl);apply HT.
}


assert(HACCpM : rk(A :: C :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACCpeq HACCpM3).
assert(HACCpm : rk(A :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HACCpeq HACCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpm2 : rk(Oo :: A :: C :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACCpM3 : rk(Oo :: A :: C :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: nil) (Oo :: A :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Cp :: nil) (nil) 2 1 0 HOoACMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACCpm3 : rk(Oo :: A :: C :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoACApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACCpM : rk(Oo :: A :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpm : rk(Oo :: A :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACCpeq HOoACCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpm2 : rk(Oo :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpM2 : rk(Oo :: Ap :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpM : rk(Oo :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApCpeq HOoApCpM3).
assert(HOoApCpm : rk(Oo :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApCpeq HOoApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBpCpM : rk(Bp :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpCpeq HBpCpM2).
assert(HBpCpm : rk(Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HBpCpeq HBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCp requis par la preuve de (?)OoBpCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpCp requis par la preuve de (?)OoBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpm2 : rk(Oo :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpM2 : rk(Oo :: Bp :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoBpCpM : rk(Oo :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpCpeq HOoBpCpM3).
assert(HOoBpCpm : rk(Oo :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBpCpeq HOoBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpCp requis par la preuve de (?)ApBpCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpCp requis par la preuve de (?)ApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpm2 : rk(Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpM2 : rk(Ap :: Bp :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HApBpCpM : rk(Ap :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpCpeq HApBpCpM3).
assert(HApBpCpm : rk(Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HApBpCpeq HApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LY : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Y ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HYM : rk(Y ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HYeq HYM1).
assert(HYm : rk(Y ::  nil) >= 1) by (solve_hyps_min HYeq HYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApY : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HCApYM : rk(C :: Ap :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApYeq HCApYM3).
assert(HCApYm : rk(C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HCApYeq HCApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpY : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HACpYM : rk(A :: Cp :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpYeq HACpYM3).
assert(HACpYm : rk(A :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HACpYeq HACpYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LZ : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Z ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HZM : rk(Z ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HZeq HZM1).
assert(HZm : rk(Z ::  nil) >= 1) by (solve_hyps_min HZeq HZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZ : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HCBpZM : rk(C :: Bp :: Z ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpZeq HCBpZM3).
assert(HCBpZm : rk(C :: Bp :: Z ::  nil) >= 1) by (solve_hyps_min HCBpZeq HCBpZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpZ : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBCpZM : rk(B :: Cp :: Z ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCpZeq HBCpZM3).
assert(HBCpZm : rk(B :: Cp :: Z ::  nil) >= 1) by (solve_hyps_min HBCpZeq HBCpZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HMM : rk(M ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HMeq HMM1).
assert(HMm : rk(M ::  nil) >= 1) by (solve_hyps_min HMeq HMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAM *)
(* dans la couche 0 *)
Lemma LAApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: M :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApMSp requis par la preuve de (?)AApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApMSp requis par la preuve de (?)AApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApMSp requis par la preuve de (?)ACApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApMSp requis par la preuve de (?)ACApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACApMSpm2 : rk(A :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: B :: nil) ++ (A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil) (nil) 4 0 2 HOoABCApMSpmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApMSpm3 : rk(A :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil) (A :: nil) 4 1 2 HOoABCApMSpmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApMSp requis par la preuve de (?)AApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMSp requis par la preuve de (?)AApMSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApMSpM3 : rk(A :: Ap :: M :: Sp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Sp :: nil) (A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: M :: Sp :: nil) ((A :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: M :: Sp :: nil) (nil) 1 2 0 HAMtmp HApMSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: M :: Sp ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HAApMSpm2 : rk(A :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACApMSpmtmp : rk(A :: C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HACApMSpeq HACApMSpm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Sp :: nil) (C :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMSpmtmp;try rewrite HT2 in HACApMSpmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Ap :: M :: Sp :: nil) (nil) 3 0 1 HACApMSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HAApMSpm3 : rk(A :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Ap :: M :: Sp :: nil) (A :: nil) 4 1 2 HOoACApMSpmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HAApMSpM : rk(A :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMSpm : rk(A :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HAApMSpeq HAApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AM requis par la preuve de (?)AM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAMm2 : rk(A :: M :: nil) >= 2).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HAApMSpeq : rk(A :: Ap :: M :: Sp :: nil) = 3) by (apply LAApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMSpmtmp : rk(A :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HAApMSpeq HAApMSpm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Sp :: nil) (A :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: Ap :: M :: Sp :: nil) ((A :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMSpmtmp;try rewrite HT2 in HAApMSpmtmp.
	assert(HT := rule_2 (A :: M :: nil) (Ap :: M :: Sp :: nil) (M :: nil) 3 1 2 HAApMSpmtmp HMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HAMM : rk(A :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAMeq HAMM2).
assert(HAMm : rk(A :: M ::  nil) >= 1) by (solve_hyps_min HAMeq HAMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAM *)
(* dans la couche 0 *)
Lemma LOoAApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm2 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoAApMSpm3 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (C :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (nil) 4 0 1 HOoACApMSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoAApMSpm4 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: nil) 4 2 2 HOoACApMSpmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoAApMSpM : rk(Oo :: A :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMSpm : rk(Oo :: A :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApMSpeq HOoAApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAM requis par la preuve de (?)OoAM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAM requis par la preuve de (?)OoAM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAMm2 : rk(Oo :: A :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAMm3 : rk(Oo :: A :: M :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoAApMSpeq : rk(Oo :: A :: Ap :: M :: Sp :: nil) = 4) by (apply LOoAApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMSpmtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMSpeq HOoAApMSpm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: A :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: M :: Ap :: M :: Sp :: nil) ((Oo :: A :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMSpmtmp;try rewrite HT2 in HOoAApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: M :: nil) (Ap :: M :: Sp :: nil) (M :: nil) 4 1 2 HOoAApMSpmtmp HMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoAMM : rk(Oo :: A :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAMeq HOoAMM3).
assert(HOoAMm : rk(Oo :: A :: M ::  nil) >= 1) by (solve_hyps_min HOoAMeq HOoAMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACM *)
(* dans la couche 0 *)
Lemma LACApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApMSp requis par la preuve de (?)ACApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApMSp requis par la preuve de (?)ACApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApMSp requis par la preuve de (?)ACApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACApMSpm2 : rk(A :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: B :: nil) ++ (A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil) (nil) 4 0 2 HOoABCApMSpmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApMSpm3 : rk(A :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Sp :: nil) (A :: nil) 4 1 2 HOoABCApMSpmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACApMSpm4 : rk(A :: C :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Ap :: M :: Sp :: nil) (A :: C :: nil) 4 2 2 HOoACApMSpmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACApMSpM : rk(A :: C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApMSpm : rk(A :: C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HACApMSpeq HACApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACMm2 : rk(A :: C :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACMm3 : rk(A :: C :: M :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HACApMSpeq : rk(A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACApMSpmtmp : rk(A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HACApMSpeq HACApMSpm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: C :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Sp :: nil) (A :: C :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: M :: Ap :: M :: Sp :: nil) ((A :: C :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMSpmtmp;try rewrite HT2 in HACApMSpmtmp.
	assert(HT := rule_2 (A :: C :: M :: nil) (Ap :: M :: Sp :: nil) (M :: nil) 4 1 2 HACApMSpmtmp HMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HACMM : rk(A :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACMeq HACMM3).
assert(HACMm : rk(A :: C :: M ::  nil) >= 1) by (solve_hyps_min HACMeq HACMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApM *)
(* dans constructLemma(), requis par LAApMU *)
(* dans constructLemma(), requis par LOoAApCpMU *)
(* dans la couche 0 *)
Lemma LOoAApBpCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoAApBpCpMUM : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpMUm : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpMU requis par la preuve de (?)OoAApCpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpMU requis par la preuve de (?)OoAApCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpMU requis par la preuve de (?)OoAApCpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMUm2 : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMUm3 : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: U :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoAApCpMUm4 : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Ap :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: U :: nil) (Oo :: Ap :: nil) 4 2 2 HOoAApBpCpMUmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoAApCpMUM : rk(Oo :: A :: Ap :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpMUm : rk(Oo :: A :: Ap :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoAApCpMUeq HOoAApCpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: M :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApMU requis par la preuve de (?)AApMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApMU requis par la preuve de (?)AApMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour AMU requis par la preuve de (?)AApMU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMU requis par la preuve de (?)AApMU pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HAApMUM3 : rk(A :: Ap :: M :: U :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: U :: nil) (Ap :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: M :: U :: nil) ((Ap :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: M :: U :: nil) (nil) 1 2 0 HApMtmp HAMUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMUm2 : rk(A :: Ap :: M :: U :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: M :: U :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApMUm3 : rk(A :: Ap :: M :: U :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMUeq : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) = 4) by (apply LOoAApCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMUeq HOoAApCpMUm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: U :: nil) (Oo :: Ap :: Cp :: A :: Ap :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: M :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMUmtmp;try rewrite HT2 in HOoAApCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: M :: U :: nil) (Ap :: nil) 4 1 2 HOoAApCpMUmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HAApMUM : rk(A :: Ap :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMUm : rk(A :: Ap :: M :: U ::  nil) >= 1) by (solve_hyps_min HAApMUeq HAApMUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApM *)
(* dans la couche 0 *)
Lemma LAMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HAMUM : rk(A :: M :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAMUeq HAMUM3).
assert(HAMUm : rk(A :: M :: U ::  nil) >= 1) by (solve_hyps_min HAMUeq HAMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApM requis par la preuve de (?)ApM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApMm2 : rk(Ap :: M :: nil) >= 2).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HAApMUeq : rk(A :: Ap :: M :: U :: nil) = 3) by (apply LAApMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMUmtmp : rk(A :: Ap :: M :: U :: nil) >= 3) by (solve_hyps_min HAApMUeq HAApMUm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: U :: nil) (Ap :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: A :: M :: U :: nil) ((Ap :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMUmtmp;try rewrite HT2 in HAApMUmtmp.
	assert(HT := rule_2 (Ap :: M :: nil) (A :: M :: U :: nil) (M :: nil) 3 1 2 HAApMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HApMM : rk(Ap :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApMeq HApMM2).
assert(HApMm : rk(Ap :: M ::  nil) >= 1) by (solve_hyps_min HApMeq HApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApM *)
(* dans la couche 0 *)
Lemma LOoApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: M :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApMSp requis par la preuve de (?)OoApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMSp requis par la preuve de (?)OoApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMSp requis par la preuve de (?)OoBCApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMSpm3 : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMSpmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMSp requis par la preuve de (?)OoCApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Sp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCApMSpm2 : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCApMSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoBCApMSpeq HOoBCApMSpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: B :: Oo :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Ap :: M :: Sp :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMSpmtmp;try rewrite HT2 in HOoBCApMSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 3 1 2 HOoBCApMSpmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCApMSpm3 : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: Oo :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMSpmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApMSp requis par la preuve de (?)OoApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApMSp requis par la preuve de (?)OoApMSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApMSpM3 : rk(Oo :: Ap :: M :: Sp :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: M :: Sp :: nil) (Oo :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: M :: Sp :: nil) ((Oo :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: M :: Sp :: nil) (nil) 1 2 0 HOoMtmp HApMSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: M :: Sp ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoApMSpm2 : rk(Oo :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoCApMSpmtmp : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoCApMSpeq HOoCApMSpm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Sp :: nil) (C :: Oo :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (Oo :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMSpmtmp;try rewrite HT2 in HOoCApMSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: Ap :: M :: Sp :: nil) (nil) 3 0 1 HOoCApMSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoApMSpm3 : rk(Oo :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: Oo :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: Ap :: M :: Sp :: nil) (Oo :: nil) 4 1 2 HOoACApMSpmtmp HOomtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoApMSpM : rk(Oo :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApMSpm : rk(Oo :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApMSpeq HOoApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApM requis par la preuve de (?)OoApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApM requis par la preuve de (?)OoApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApMm2 : rk(Oo :: Ap :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApMm3 : rk(Oo :: Ap :: M :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoApMSpeq : rk(Oo :: Ap :: M :: Sp :: nil) = 3) by (apply LOoApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMSpmtmp : rk(Oo :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoApMSpeq HOoApMSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: Ap :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: M :: Sp :: nil) (Oo :: Ap :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: M :: Ap :: M :: Sp :: nil) ((Oo :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApMSpmtmp;try rewrite HT2 in HOoApMSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HOoApMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoApMM : rk(Oo :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApMeq HOoApMM3).
assert(HOoApMm : rk(Oo :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoApMeq HOoApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMm2 : rk(Oo :: A :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMm3 : rk(Oo :: A :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAApMm4 : rk(Oo :: A :: Ap :: M :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoAApMSpeq : rk(Oo :: A :: Ap :: M :: Sp :: nil) = 4) by (apply LOoAApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMSpmtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMSpeq HOoAApMSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: Ap :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Ap :: M :: Sp :: nil) ((Oo :: A :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMSpmtmp;try rewrite HT2 in HOoAApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoAApMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoAApMM : rk(Oo :: A :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMm : rk(Oo :: A :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoAApMeq HOoAApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApM requis par la preuve de (?)OoBApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoBApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApM requis par la preuve de (?)OoBApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApM requis par la preuve de (?)OoBApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMm2 : rk(Oo :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApMm3 : rk(Oo :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABApMeq HOoABApMm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApMmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApMm4 : rk(Oo :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoBApMSpeq : rk(Oo :: B :: Ap :: M :: Sp :: nil) = 4) by (apply LOoBApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMSpmtmp : rk(Oo :: B :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApMSpeq HOoBApMSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Sp :: nil) (Oo :: B :: Ap :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: M :: Ap :: M :: Sp :: nil) ((Oo :: B :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMSpmtmp;try rewrite HT2 in HOoBApMSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoBApMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoBApMM : rk(Oo :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMm : rk(Oo :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoBApMeq HOoBApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABApM *)
(* dans la couche 0 *)
Lemma LOoABApMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSp requis par la preuve de (?)OoABApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSp requis par la preuve de (?)OoABApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSp requis par la preuve de (?)OoABApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApMSpm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (C :: Oo :: A :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: M :: Sp :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil) (nil) 4 0 1 HOoABCApMSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABApMSpm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoABCApMSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMSpeq HOoABCApMSpm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMSpmtmp;try rewrite HT2 in HOoABCApMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMSpmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABApMSpM : rk(Oo :: A :: B :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMSpm : rk(Oo :: A :: B :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApMSpeq HOoABApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABApMm4 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoABApMSpeq : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMSpmtmp : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMSpeq HOoABApMSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMSpmtmp;try rewrite HT2 in HOoABApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoABApMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoABApMM : rk(Oo :: A :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMm : rk(Oo :: A :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoABApMeq HOoABApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApM requis par la preuve de (?)CApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApM requis par la preuve de (?)CApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm2 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm3 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApM requis par la preuve de (?)CApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMm2 : rk(C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMmtmp : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoACApMeq HOoACApMm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMmtmp;try rewrite HT2 in HOoACApMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApMm3 : rk(C :: Ap :: M :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCApMSpeq : rk(C :: Ap :: M :: Sp :: nil) = 3) by (apply LCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpmtmp : rk(C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HCApMSpeq HCApMSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (C :: Ap :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: nil) (C :: Ap :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: Ap :: M :: Sp :: nil) ((C :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMSpmtmp;try rewrite HT2 in HCApMSpmtmp.
	assert(HT := rule_2 (C :: Ap :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HCApMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HCApMM : rk(C :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApMeq HCApMM3).
assert(HCApMm : rk(C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HCApMeq HCApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm2 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm3 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMm2 : rk(Oo :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: M :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApMm3 : rk(Oo :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMmtmp : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoACApMeq HOoACApMm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMmtmp;try rewrite HT2 in HOoACApMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApMmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApMm4 : rk(Oo :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoCApMSpeq : rk(Oo :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMSpmtmp : rk(Oo :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApMSpeq HOoCApMSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: C :: Ap :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Sp :: nil) (Oo :: C :: Ap :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: M :: Ap :: M :: Sp :: nil) ((Oo :: C :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMSpmtmp;try rewrite HT2 in HOoCApMSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoCApMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoCApMM : rk(Oo :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMm : rk(Oo :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoCApMeq HOoCApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpM *)
(* dans constructLemma(), requis par LABpMU *)
(* dans la couche 0 *)
Lemma LOoABpCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpMU requis par la preuve de (?)OoABpCpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpMU requis par la preuve de (?)OoABpCpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpMU requis par la preuve de (?)OoABpCpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMUm2 : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoABpCpMUm3 : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: Bp :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Ap :: Oo :: A :: Bp :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: Bp :: Cp :: M :: U :: nil) ((Ap :: nil) ++ (Oo :: A :: Bp :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: Bp :: Cp :: M :: U :: nil) (nil) 4 0 1 HOoAApBpCpMUmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpCpMUm4 : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Bp :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Bp :: Cp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Bp :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: U :: nil) (Oo :: Bp :: nil) 4 2 2 HOoAApBpCpMUmtmp HOoBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoABpCpMUM : rk(Oo :: A :: Bp :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpMUm : rk(Oo :: A :: Bp :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoABpCpMUeq HOoABpCpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp :: M :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpMU requis par la preuve de (?)ABpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpMU requis par la preuve de (?)ABpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpMU requis par la preuve de (?)ABpMU pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpMUM3 : rk(A :: Bp :: M :: U :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: M :: U :: nil) (Bp :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: M :: U :: nil) ((Bp :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: M :: U :: nil) (nil) 1 2 0 HBpMtmp HAMUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpMUm2 : rk(A :: Bp :: M :: U :: nil) >= 2).
{
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: M :: U :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HABpMUm3 : rk(A :: Bp :: M :: U :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoABpCpMUeq : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoABpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpMUmtmp : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoABpCpMUeq HOoABpCpMUm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (A :: Bp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: U :: nil) (Oo :: Bp :: Cp :: A :: Bp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: A :: Bp :: M :: U :: nil) ((Oo :: Bp :: Cp :: nil) ++ (A :: Bp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMUmtmp;try rewrite HT2 in HOoABpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (A :: Bp :: M :: U :: nil) (Bp :: nil) 4 1 2 HOoABpCpMUmtmp HBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HABpMUM : rk(A :: Bp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpMUm : rk(A :: Bp :: M :: U ::  nil) >= 1) by (solve_hyps_min HABpMUeq HABpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpM requis par la preuve de (?)BpM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpMm2 : rk(Bp :: M :: nil) >= 2).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HABpMUeq : rk(A :: Bp :: M :: U :: nil) = 3) by (apply LABpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpMUmtmp : rk(A :: Bp :: M :: U :: nil) >= 3) by (solve_hyps_min HABpMUeq HABpMUm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Bp :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: M :: U :: nil) (Bp :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: M :: A :: M :: U :: nil) ((Bp :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpMUmtmp;try rewrite HT2 in HABpMUmtmp.
	assert(HT := rule_2 (Bp :: M :: nil) (A :: M :: U :: nil) (M :: nil) 3 1 2 HABpMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HBpMM : rk(Bp :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpMeq HBpMM2).
assert(HBpMm : rk(Bp :: M ::  nil) >= 1) by (solve_hyps_min HBpMeq HBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpM *)
(* dans la couche 0 *)
Lemma LOoABpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMU requis par la preuve de (?)OoABpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMU requis par la preuve de (?)OoABpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMU requis par la preuve de (?)OoABpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMUm2 : rk(Oo :: A :: Bp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMUm3 : rk(Oo :: A :: Bp :: M :: U :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: U :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HOoABpMUm4 : rk(Oo :: A :: Bp :: M :: U :: nil) >= 4).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoABpCpMUeq : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoABpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpMUmtmp : rk(Oo :: A :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoABpCpMUeq HOoABpCpMUm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (Oo :: A :: Bp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: U :: nil) (Oo :: Bp :: Cp :: Oo :: A :: Bp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: Oo :: A :: Bp :: M :: U :: nil) ((Oo :: Bp :: Cp :: nil) ++ (Oo :: A :: Bp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMUmtmp;try rewrite HT2 in HOoABpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (Oo :: A :: Bp :: M :: U :: nil) (Oo :: Bp :: nil) 4 2 2 HOoABpCpMUmtmp HOoBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HOoABpMUM : rk(Oo :: A :: Bp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMUm : rk(Oo :: A :: Bp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoABpMUeq HOoABpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpM requis par la preuve de (?)OoBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpM requis par la preuve de (?)OoBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpMm2 : rk(Oo :: Bp :: M :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: M :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpMm3 : rk(Oo :: Bp :: M :: nil) >= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HOoABpMUeq : rk(Oo :: A :: Bp :: M :: U :: nil) = 4) by (apply LOoABpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMUmtmp : rk(Oo :: A :: Bp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoABpMUeq HOoABpMUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: Bp :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: M :: U :: nil) (Oo :: Bp :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: M :: A :: M :: U :: nil) ((Oo :: Bp :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpMUmtmp;try rewrite HT2 in HOoABpMUmtmp.
	assert(HT := rule_2 (Oo :: Bp :: M :: nil) (A :: M :: U :: nil) (M :: nil) 4 1 2 HOoABpMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HOoBpMM : rk(Oo :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpMeq HOoBpMM3).
assert(HOoBpMm : rk(Oo :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoBpMeq HOoBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpM *)
(* dans la couche 0 *)
Lemma LOoAApBpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMSp requis par la preuve de (?)OoAApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMSp requis par la preuve de (?)OoAApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMSp requis par la preuve de (?)OoAApBpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMSpm2 : rk(Oo :: A :: Ap :: Bp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMSpm3 : rk(Oo :: A :: Ap :: Bp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMSpm4 : rk(Oo :: A :: Ap :: Bp :: M :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpMSpM : rk(Oo :: A :: Ap :: Bp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpMSpm : rk(Oo :: A :: Ap :: Bp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApBpMSpeq HOoAApBpMSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpM *)
(* dans la couche 0 *)
Lemma LOoApBpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: M :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpMSp requis par la preuve de (?)OoApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpMSp requis par la preuve de (?)OoApBpMSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpMSp requis par la preuve de (?)OoApBpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMSpm2 : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApBpMSpM3 : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: Sp :: nil) (Oo :: Ap :: Bp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Ap :: M :: Sp :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (Ap :: M :: Sp :: nil) (Ap :: nil) 2 2 1 HOoApBpMtmp HApMSpMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMSpm3 : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoApMeq : rk(Oo :: Ap :: M :: nil) = 3) by (apply LOoApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMmtmp : rk(Oo :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoApMeq HOoApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil) 3 3 HOoApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpMSpM : rk(Oo :: Ap :: Bp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpMSpm : rk(Oo :: Ap :: Bp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApBpMSpeq HOoApBpMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMm2 : rk(Oo :: A :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMm3 : rk(Oo :: A :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpMm4 : rk(Oo :: A :: Bp :: M :: nil) >= 4).
{
	try assert(HOoApBpMSpeq : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) = 3) by (apply LOoApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMSpMtmp : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMSpeq HOoApBpMSpM3).
	try assert(HOoAApBpMSpeq : rk(Oo :: A :: Ap :: Bp :: M :: Sp :: nil) = 4) by (apply LOoAApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMSpeq HOoAApBpMSpm4).
	try assert(HOoBpMeq : rk(Oo :: Bp :: M :: nil) = 3) by (apply LOoBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpMmtmp : rk(Oo :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoBpMeq HOoBpMm3).
	assert(Hincl : incl (Oo :: Bp :: M :: nil) (list_inter (Oo :: A :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: Sp :: nil) (Oo :: A :: Bp :: M :: Oo :: Ap :: Bp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: M :: Oo :: Ap :: Bp :: M :: Sp :: nil) ((Oo :: A :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMSpmtmp;try rewrite HT2 in HOoAApBpMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil) (Oo :: Bp :: M :: nil) 4 3 3 HOoAApBpMSpmtmp HOoBpMmtmp HOoApBpMSpMtmp Hincl);apply HT.
}


assert(HOoABpMM : rk(Oo :: A :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMm : rk(Oo :: A :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoABpMeq HOoABpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABBpM *)
(* dans la couche 0 *)
Lemma LOoABApBpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpMSp requis par la preuve de (?)OoABApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpMSp requis par la preuve de (?)OoABApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpMSp requis par la preuve de (?)OoABApBpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpMSpm2 : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpMSpm3 : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpMSpm4 : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpMSpM : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpMSpm : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApBpMSpeq HOoABApBpMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMm2 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMm3 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpMm4 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 4).
{
	try assert(HOoApBpMSpeq : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) = 3) by (apply LOoApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMSpMtmp : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMSpeq HOoApBpMSpM3).
	try assert(HOoABApBpMSpeq : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) = 4) by (apply LOoABApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpMSpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApBpMSpeq HOoABApBpMSpm4).
	try assert(HOoBpMeq : rk(Oo :: Bp :: M :: nil) = 3) by (apply LOoBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpMmtmp : rk(Oo :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoBpMeq HOoBpMm3).
	assert(Hincl : incl (Oo :: Bp :: M :: nil) (list_inter (Oo :: A :: B :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: M :: Sp :: nil) (Oo :: A :: B :: Bp :: M :: Oo :: Ap :: Bp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: M :: Oo :: Ap :: Bp :: M :: Sp :: nil) ((Oo :: A :: B :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpMSpmtmp;try rewrite HT2 in HOoABApBpMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil) (Oo :: Bp :: M :: nil) 4 3 3 HOoABApBpMSpmtmp HOoBpMmtmp HOoApBpMSpMtmp Hincl);apply HT.
}


assert(HOoABBpMM : rk(Oo :: A :: B :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpMm : rk(Oo :: A :: B :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoABBpMeq HOoABBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpM *)
(* dans la couche 0 *)
Lemma LOoCApBpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpMSp requis par la preuve de (?)OoCApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpMSp requis par la preuve de (?)OoCApBpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpMSp requis par la preuve de (?)OoCApBpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMSpm2 : rk(Oo :: C :: Ap :: Bp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMSpm3 : rk(Oo :: C :: Ap :: Bp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMSpm4 : rk(Oo :: C :: Ap :: Bp :: M :: Sp :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: Sp :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpMSpM : rk(Oo :: C :: Ap :: Bp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpMSpm : rk(Oo :: C :: Ap :: Bp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApBpMSpeq HOoCApBpMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpM requis par la preuve de (?)CBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpM requis par la preuve de (?)CBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm2 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm3 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpM requis par la preuve de (?)CBpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: M ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpMm2 : rk(C :: Bp :: M :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpMmtmp : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoACBpMeq HOoACBpMm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: M :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMmtmp;try rewrite HT2 in HOoACBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: M :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpMmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpMM1. try clear HOoACBpMM2. try clear HOoACBpMM3. try clear HOoACBpMm4. try clear HOoACBpMm3. try clear HOoACBpMm2. try clear HOoACBpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpMm3 : rk(C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoApBpMSpeq : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) = 3) by (apply LOoApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMSpMtmp : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMSpeq HOoApBpMSpM3).
	try assert(HOoCApBpMSpeq : rk(Oo :: C :: Ap :: Bp :: M :: Sp :: nil) = 4) by (apply LOoCApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpMSpmtmp : rk(Oo :: C :: Ap :: Bp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApBpMSpeq HOoCApBpMSpm4).
	try assert(HBpMeq : rk(Bp :: M :: nil) = 2) by (apply LBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMmtmp : rk(Bp :: M :: nil) >= 2) by (solve_hyps_min HBpMeq HBpMm2).
	assert(Hincl : incl (Bp :: M :: nil) (list_inter (C :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: Sp :: nil) (C :: Bp :: M :: Oo :: Ap :: Bp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: M :: Oo :: Ap :: Bp :: M :: Sp :: nil) ((C :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMSpmtmp;try rewrite HT2 in HOoCApBpMSpmtmp.
	assert(HT := rule_2 (C :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Sp :: nil) (Bp :: M :: nil) 4 2 3 HOoCApBpMSpmtmp HBpMmtmp HOoApBpMSpMtmp Hincl);apply HT.
}


assert(HCBpMM : rk(C :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpMeq HCBpMM3).
assert(HCBpMm : rk(C :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HCBpMeq HCBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpM *)
(* dans constructLemma(), requis par LAApBpMU *)
(* dans la couche 0 *)
Lemma LAApBpCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpCpMU requis par la preuve de (?)AApBpCpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpMU requis par la preuve de (?)AApBpCpMU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HAApBpCpMUm3 : rk(A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: Ap :: Bp :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: A :: A :: Ap :: Bp :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: Ap :: Bp :: Cp :: M :: U :: nil) ((Oo :: A :: nil) ++ (A :: Ap :: Bp :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: Ap :: Bp :: Cp :: M :: U :: nil) (A :: nil) 4 1 2 HOoAApBpCpMUmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpCpMUm4 : rk(A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: M :: U :: nil) (Ap :: Bp :: nil) 4 2 2 HOoAApBpCpMUmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HAApBpCpMUM : rk(A :: Ap :: Bp :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpMUm : rk(A :: Ap :: Bp :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HAApBpCpMUeq HAApBpCpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Bp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpMU requis par la preuve de (?)AApBpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMU requis par la preuve de (?)AApBpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMU requis par la preuve de (?)OoAApBpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMU requis par la preuve de (?)OoAApBpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMUm2 : rk(Oo :: A :: Ap :: Bp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMUm3 : rk(Oo :: A :: Ap :: Bp :: M :: U :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: U :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpMU requis par la preuve de (?)AApBpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpMU requis par la preuve de (?)AApBpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpMUm2 : rk(A :: Ap :: Bp :: M :: U :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: M :: U :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: U ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpMUm3 : rk(A :: Ap :: Bp :: M :: U :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpMUmtmp : rk(Oo :: A :: Ap :: Bp :: M :: U :: nil) >= 3) by (solve_hyps_min HOoAApBpMUeq HOoAApBpMUm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: U :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMUmtmp;try rewrite HT2 in HOoAApBpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: U :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpMUmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpMUM1. try clear HOoAApBpMUM2. try clear HOoAApBpMUM3. try clear HOoAApBpMUm4. try clear HOoAApBpMUm3. try clear HOoAApBpMUm2. try clear HOoAApBpMUm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HAApBpMUm4 : rk(A :: Ap :: Bp :: M :: U :: nil) >= 4).
{
	try assert(HApBpCpeq : rk(Ap :: Bp :: Cp :: nil) = 2) by (apply LApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpCpMtmp : rk(Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HApBpCpeq HApBpCpM2).
	try assert(HAApBpCpMUeq : rk(A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpCpMUmtmp : rk(A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HAApBpCpMUeq HAApBpCpMUm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: M :: U :: nil) (Ap :: Bp :: Cp :: A :: Ap :: Bp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: A :: Ap :: Bp :: M :: U :: nil) ((Ap :: Bp :: Cp :: nil) ++ (A :: Ap :: Bp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpMUmtmp;try rewrite HT2 in HAApBpCpMUmtmp.
	assert(HT := rule_4 (Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: M :: U :: nil) (Ap :: Bp :: nil) 4 2 2 HAApBpCpMUmtmp HApBpmtmp HApBpCpMtmp Hincl); apply HT.
}


assert(HAApBpMUM : rk(A :: Ap :: Bp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpMUm : rk(A :: Ap :: Bp :: M :: U ::  nil) >= 1) by (solve_hyps_min HAApBpMUeq HAApBpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpM requis par la preuve de (?)ApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpM requis par la preuve de (?)ApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpMm2 : rk(Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: M :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpMm3 : rk(Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HAApBpMUeq : rk(A :: Ap :: Bp :: M :: U :: nil) = 4) by (apply LAApBpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpMUmtmp : rk(A :: Ap :: Bp :: M :: U :: nil) >= 4) by (solve_hyps_min HAApBpMUeq HAApBpMUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: Bp :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: M :: U :: nil) (Ap :: Bp :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: M :: A :: M :: U :: nil) ((Ap :: Bp :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpMUmtmp;try rewrite HT2 in HAApBpMUmtmp.
	assert(HT := rule_2 (Ap :: Bp :: M :: nil) (A :: M :: U :: nil) (M :: nil) 4 1 2 HAApBpMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HApBpMM : rk(Ap :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpMeq HApBpMM3).
assert(HApBpMm : rk(Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HApBpMeq HApBpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMm2 : rk(Oo :: Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpMM3 : rk(Oo :: Ap :: Bp :: M :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (M :: nil) (nil) 2 1 0 HOoApBpMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpMm3 : rk(Oo :: Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoApBpMSpeq : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) = 3) by (apply LOoApBpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMSpmtmp : rk(Oo :: Ap :: Bp :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoApBpMSpeq HOoApBpMSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: Sp :: nil) (Oo :: Ap :: Bp :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: Ap :: M :: Sp :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpMSpmtmp;try rewrite HT2 in HOoApBpMSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HOoApBpMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoApBpMM : rk(Oo :: Ap :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpMm : rk(Oo :: Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoApBpMeq HOoApBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpM *)
(* dans la couche 0 *)
Lemma LACpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpMU requis par la preuve de (?)ACpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMU requis par la preuve de (?)ACpMU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMU requis par la preuve de (?)ACpMU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HACpMUm2 : rk(A :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: Ap :: Bp :: A :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Cp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Cp :: M :: U :: nil) (nil) 4 0 2 HOoAApBpCpMUmtmp Hmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACpMUM3 : rk(A :: Cp :: M :: U :: nil) <= 3).
{
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: U :: nil) (Cp :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: M :: U :: nil) ((Cp :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: M :: U :: nil) (nil) 1 2 0 HCpMtmp HAMUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HACpMUm3 : rk(A :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMUeq : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) = 4) by (apply LOoAApCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMUeq HOoAApCpMUm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: U :: nil) (Oo :: Ap :: Cp :: A :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Cp :: M :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMUmtmp;try rewrite HT2 in HOoAApCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Cp :: M :: U :: nil) (Cp :: nil) 4 1 2 HOoAApCpMUmtmp HCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HACpMUM : rk(A :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMUm : rk(A :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HACpMUeq HACpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpM requis par la preuve de (?)CpM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpMm2 : rk(Cp :: M :: nil) >= 2).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HACpMUeq : rk(A :: Cp :: M :: U :: nil) = 3) by (apply LACpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMUmtmp : rk(A :: Cp :: M :: U :: nil) >= 3) by (solve_hyps_min HACpMUeq HACpMUm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Cp :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: U :: nil) (Cp :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: M :: A :: M :: U :: nil) ((Cp :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMUmtmp;try rewrite HT2 in HACpMUmtmp.
	assert(HT := rule_2 (Cp :: M :: nil) (A :: M :: U :: nil) (M :: nil) 3 1 2 HACpMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HCpMM : rk(Cp :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpMeq HCpMM2).
assert(HCpMm : rk(Cp :: M ::  nil) >= 1) by (solve_hyps_min HCpMeq HCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpM *)
(* dans la couche 0 *)
Lemma LOoACpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpMU requis par la preuve de (?)OoACpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpMU requis par la preuve de (?)OoACpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpMU requis par la preuve de (?)OoACpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMUm2 : rk(Oo :: A :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoACpMUm3 : rk(Oo :: A :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Cp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Cp :: M :: U :: nil) (Oo :: nil) 4 1 2 HOoAApBpCpMUmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoACpMUm4 : rk(Oo :: A :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMUeq : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) = 4) by (apply LOoAApCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMUeq HOoAApCpMUm4).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: U :: nil) (Oo :: Ap :: Cp :: Oo :: A :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: Cp :: M :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMUmtmp;try rewrite HT2 in HOoAApCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: Cp :: M :: U :: nil) (Oo :: Cp :: nil) 4 2 2 HOoAApCpMUmtmp HOoCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoACpMUM : rk(Oo :: A :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpMUm : rk(Oo :: A :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoACpMUeq HOoACpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpM requis par la preuve de (?)OoCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpM requis par la preuve de (?)OoCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpMm2 : rk(Oo :: Cp :: M :: nil) >= 2).
{
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: M :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpMm3 : rk(Oo :: Cp :: M :: nil) >= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HOoACpMUeq : rk(Oo :: A :: Cp :: M :: U :: nil) = 4) by (apply LOoACpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMUmtmp : rk(Oo :: A :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoACpMUeq HOoACpMUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: Cp :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: M :: U :: nil) (Oo :: Cp :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: M :: A :: M :: U :: nil) ((Oo :: Cp :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpMUmtmp;try rewrite HT2 in HOoACpMUmtmp.
	assert(HT := rule_2 (Oo :: Cp :: M :: nil) (A :: M :: U :: nil) (M :: nil) 4 1 2 HOoACpMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HOoCpMM : rk(Oo :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpMeq HOoCpMM3).
assert(HOoCpMm : rk(Oo :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoCpMeq HOoCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpM *)
(* dans la couche 0 *)
Lemma LOoAApCpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Cp :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpMSp requis par la preuve de (?)OoAApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpMSp requis par la preuve de (?)OoAApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpMSp requis par la preuve de (?)OoAApCpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMSpm2 : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMSpm3 : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMSpm4 : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: M :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApCpMSpM : rk(Oo :: A :: Ap :: Cp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpMSpm : rk(Oo :: A :: Ap :: Cp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApCpMSpeq HOoAApCpMSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpM *)
(* dans la couche 0 *)
Lemma LOoApCpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Cp :: M :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpMSp requis par la preuve de (?)OoApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpMSp requis par la preuve de (?)OoApCpMSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpMSp requis par la preuve de (?)OoApCpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpMSpm2 : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApCpMSpM3 : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: Sp :: nil) (Oo :: Ap :: Cp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Ap :: M :: Sp :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (Ap :: M :: Sp :: nil) (Ap :: nil) 2 2 1 HOoApCpMtmp HApMSpMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpMSpm3 : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoApMeq : rk(Oo :: Ap :: M :: nil) = 3) by (apply LOoApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMmtmp : rk(Oo :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoApMeq HOoApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: M :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: M :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil) 3 3 HOoApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpMSpM : rk(Oo :: Ap :: Cp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpMSpm : rk(Oo :: Ap :: Cp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApCpMSpeq HOoApCpMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpM requis par la preuve de (?)ACpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpM requis par la preuve de (?)ACpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpM requis par la preuve de (?)OoABCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpM requis par la preuve de (?)OoABCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMm2 : rk(Oo :: A :: B :: Cp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMm3 : rk(Oo :: A :: B :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpM requis par la preuve de (?)ACpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMm2 : rk(A :: Cp :: M :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMmtmp : rk(Oo :: A :: B :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoABCpMeq HOoABCpMm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMmtmp;try rewrite HT2 in HOoABCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMM1. try clear HOoABCpMM2. try clear HOoABCpMM3. try clear HOoABCpMm4. try clear HOoABCpMm3. try clear HOoABCpMm2. try clear HOoABCpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpMm3 : rk(A :: Cp :: M :: nil) >= 3).
{
	try assert(HOoApCpMSpeq : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) = 3) by (apply LOoApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMSpMtmp : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) <= 3) by (solve_hyps_max HOoApCpMSpeq HOoApCpMSpM3).
	try assert(HOoAApCpMSpeq : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) = 4) by (apply LOoAApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMSpmtmp : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApCpMSpeq HOoAApCpMSpm4).
	try assert(HCpMeq : rk(Cp :: M :: nil) = 2) by (apply LCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMmtmp : rk(Cp :: M :: nil) >= 2) by (solve_hyps_min HCpMeq HCpMm2).
	assert(Hincl : incl (Cp :: M :: nil) (list_inter (A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: Sp :: nil) (A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Sp :: nil) ((A :: Cp :: M :: nil) ++ (Oo :: Ap :: Cp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMSpmtmp;try rewrite HT2 in HOoAApCpMSpmtmp.
	assert(HT := rule_2 (A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil) (Cp :: M :: nil) 4 2 3 HOoAApCpMSpmtmp HCpMmtmp HOoApCpMSpMtmp Hincl);apply HT.
}
try clear HCpMM1. try clear HCpMM2. try clear HCpMM3. try clear HCpMm4. try clear HCpMm3. try clear HCpMm2. try clear HCpMm1. 

assert(HACpMM : rk(A :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpMeq HACpMM3).
assert(HACpMm : rk(A :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACpMeq HACpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpM requis par la preuve de (?)OoACpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpM requis par la preuve de (?)OoACpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpM requis par la preuve de (?)OoACpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMm2 : rk(Oo :: A :: Cp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMm3 : rk(Oo :: A :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpMm4 : rk(Oo :: A :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpMSpeq : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) = 3) by (apply LOoApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMSpMtmp : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) <= 3) by (solve_hyps_max HOoApCpMSpeq HOoApCpMSpM3).
	try assert(HOoAApCpMSpeq : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) = 4) by (apply LOoAApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMSpmtmp : rk(Oo :: A :: Ap :: Cp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApCpMSpeq HOoAApCpMSpm4).
	try assert(HOoCpMeq : rk(Oo :: Cp :: M :: nil) = 3) by (apply LOoCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpMmtmp : rk(Oo :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoCpMeq HOoCpMm3).
	assert(Hincl : incl (Oo :: Cp :: M :: nil) (list_inter (Oo :: A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: Sp :: nil) (Oo :: A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Sp :: nil) ((Oo :: A :: Cp :: M :: nil) ++ (Oo :: Ap :: Cp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMSpmtmp;try rewrite HT2 in HOoAApCpMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Sp :: nil) (Oo :: Cp :: M :: nil) 4 3 3 HOoAApCpMSpmtmp HOoCpMmtmp HOoApCpMSpMtmp Hincl);apply HT.
}


assert(HOoACpMM : rk(Oo :: A :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpMm : rk(Oo :: A :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoACpMeq HOoACpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACCpM *)
(* dans la couche 0 *)
Lemma LOoACCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpMU requis par la preuve de (?)OoACCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpMU requis par la preuve de (?)OoACCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpMU requis par la preuve de (?)OoACCpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMUm2 : rk(Oo :: A :: C :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMUm3 : rk(Oo :: A :: C :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMUm4 : rk(Oo :: A :: C :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoACpMeq : rk(Oo :: A :: Cp :: M :: nil) = 4) by (apply LOoACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMmtmp : rk(Oo :: A :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACpMeq HOoACpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: M :: U :: nil) 4 4 HOoACpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACCpMUM : rk(Oo :: A :: C :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpMUm : rk(Oo :: A :: C :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoACCpMUeq HOoACCpMUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACCpM *)
(* dans la couche 0 *)
Lemma LOoACMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: M :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACMU requis par la preuve de (?)OoACMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACMU requis par la preuve de (?)OoACMU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACMU requis par la preuve de (?)OoACMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMUm2 : rk(Oo :: A :: C :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACMUM3 : rk(Oo :: A :: C :: M :: U :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: M :: U :: nil) (Oo :: A :: C :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: M :: U :: nil) ((Oo :: A :: C :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (A :: M :: U :: nil) (A :: nil) 2 2 1 HOoACMtmp HAMUMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMUm3 : rk(Oo :: A :: C :: M :: U :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: C :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: C :: M :: U :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACMUM : rk(Oo :: A :: C :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACMUm : rk(Oo :: A :: C :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoACMUeq HOoACMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMm2 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMm3 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpMm2 : rk(A :: C :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: M ::  de rang :  3 et 4 	 AiB : A :: C :: Cp ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HACCpMm3 : rk(A :: C :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpMmtmp : rk(Oo :: A :: C :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoACCpMeq HOoACCpMm3).
	try assert(HACCpeq : rk(A :: C :: Cp :: nil) = 3) by (apply LACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 3) by (solve_hyps_min HACCpeq HACCpm3).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (A :: C :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: A :: C :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: A :: C :: Cp :: M :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (A :: C :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpMmtmp;try rewrite HT2 in HOoACCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: nil) 3 3 3 HOoACCpMmtmp HACCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpMM1. try clear HOoACCpMM2. try clear HOoACCpMM3. try clear HOoACCpMm4. try clear HOoACCpMm3. try clear HOoACCpMm2. try clear HOoACCpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACCpMm4 : rk(A :: C :: Cp :: M :: nil) >= 4).
{
	try assert(HOoACMUeq : rk(Oo :: A :: C :: M :: U :: nil) = 3) by (apply LOoACMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMUMtmp : rk(Oo :: A :: C :: M :: U :: nil) <= 3) by (solve_hyps_max HOoACMUeq HOoACMUM3).
	try assert(HOoACCpMUeq : rk(Oo :: A :: C :: Cp :: M :: U :: nil) = 4) by (apply LOoACCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMUmtmp : rk(Oo :: A :: C :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoACCpMUeq HOoACCpMUm4).
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hincl : incl (A :: C :: M :: nil) (list_inter (A :: C :: Cp :: M :: nil) (Oo :: A :: C :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: M :: U :: nil) (A :: C :: Cp :: M :: Oo :: A :: C :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: M :: Oo :: A :: C :: M :: U :: nil) ((A :: C :: Cp :: M :: nil) ++ (Oo :: A :: C :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpMUmtmp;try rewrite HT2 in HOoACCpMUmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: M :: nil) (Oo :: A :: C :: M :: U :: nil) (A :: C :: M :: nil) 4 3 3 HOoACCpMUmtmp HACMmtmp HOoACMUMtmp Hincl);apply HT.
}


assert(HACCpMM : rk(A :: C :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpMm : rk(A :: C :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACCpMeq HACCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpM *)
(* dans la couche 0 *)
Lemma LAApCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpMU requis par la preuve de (?)AApCpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpMU requis par la preuve de (?)AApCpMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpMU requis par la preuve de (?)AApCpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApCpMUm2 : rk(A :: Ap :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: M :: U :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApCpMUm3 : rk(A :: Ap :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) = 4) by (apply LOoAApBpCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMUeq HOoAApBpCpMUm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: U :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Cp :: M :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMUmtmp;try rewrite HT2 in HOoAApBpCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Cp :: M :: U :: nil) (Ap :: nil) 4 1 2 HOoAApBpCpMUmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: U ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApCpMUm4 : rk(A :: Ap :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMUeq : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) = 4) by (apply LOoAApCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMUeq HOoAApCpMUm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: U :: nil) (Oo :: Ap :: Cp :: A :: Ap :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: Cp :: M :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMUmtmp;try rewrite HT2 in HOoAApCpMUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: M :: U :: nil) (Ap :: Cp :: nil) 4 2 2 HOoAApCpMUmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HAApCpMUM : rk(A :: Ap :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpMUm : rk(A :: Ap :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HAApCpMUeq HAApCpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpM requis par la preuve de (?)ApCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpM requis par la preuve de (?)ApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpMm2 : rk(Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: M :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApCpMm3 : rk(Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HAApCpMUeq : rk(A :: Ap :: Cp :: M :: U :: nil) = 4) by (apply LAApCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApCpMUmtmp : rk(A :: Ap :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HAApCpMUeq HAApCpMUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: Cp :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: M :: U :: nil) (Ap :: Cp :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: M :: A :: M :: U :: nil) ((Ap :: Cp :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpMUmtmp;try rewrite HT2 in HAApCpMUmtmp.
	assert(HT := rule_2 (Ap :: Cp :: M :: nil) (A :: M :: U :: nil) (M :: nil) 4 1 2 HAApCpMUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HApCpMM : rk(Ap :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpMeq HApCpMM3).
assert(HApCpMm : rk(Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HApCpMeq HApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCpM : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpMm2 : rk(Oo :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApCpMM3 : rk(Oo :: Ap :: Cp :: M :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Cp :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (M :: nil) (nil) 2 1 0 HOoApCpMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApCpMm3 : rk(Oo :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoApCpMSpeq : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) = 3) by (apply LOoApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMSpmtmp : rk(Oo :: Ap :: Cp :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoApCpMSpeq HOoApCpMSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: Ap :: Cp :: M :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: Sp :: nil) (Oo :: Ap :: Cp :: M :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: Ap :: M :: Sp :: nil) ((Oo :: Ap :: Cp :: M :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpMSpmtmp;try rewrite HT2 in HOoApCpMSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Cp :: M :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HOoApCpMSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoApCpMM : rk(Oo :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpMm : rk(Oo :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoApCpMeq HOoApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HNM : rk(N ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HNeq HNM1).
assert(HNm : rk(N ::  nil) >= 1) by (solve_hyps_min HNeq HNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAN *)
(* dans constructLemma(), requis par LABpNT *)
(* dans constructLemma(), requis par LOoACBpNT *)
(* dans la couche 0 *)
Lemma LOoABCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoABCBpNTM : rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNTm : rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNT requis par la preuve de (?)OoACBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNT requis par la preuve de (?)OoACBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNT requis par la preuve de (?)OoACBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNTm2 : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACBpNTm3 : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (B :: Oo :: A :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Bp :: N :: T :: nil) ((B :: nil) ++ (Oo :: A :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Bp :: N :: T :: nil) (nil) 4 0 1 HOoABCBpNTmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACBpNTm4 : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: Oo :: A :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Bp :: N :: T :: nil) (Oo :: A :: nil) 4 2 2 HOoABCBpNTmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACBpNTM : rk(Oo :: A :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpNTm : rk(Oo :: A :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpNT requis par la preuve de (?)ABpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpNT requis par la preuve de (?)ABpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpNT requis par la preuve de (?)ACBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpNT requis par la preuve de (?)ACBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACBpNTm2 : rk(A :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: A :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Bp :: N :: T :: nil) ((Oo :: B :: nil) ++ (A :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Bp :: N :: T :: nil) (nil) 4 0 2 HOoABCBpNTmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACBpNTm3 : rk(A :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: A :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: T :: nil) (A :: nil) 4 1 2 HOoABCBpNTmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpNT requis par la preuve de (?)ABpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BpNT requis par la preuve de (?)ABpNT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpNT requis par la preuve de (?)ABpNT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABpNTM3 : rk(A :: Bp :: N :: T :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: T :: nil) (A :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: N :: T :: nil) ((A :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Bp :: N :: T :: nil) (nil) 1 2 0 HAMtmp HBpNTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABpNTm2 : rk(A :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACBpNTmtmp : rk(A :: C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HACBpNTeq HACBpNTm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: N :: T :: nil) (C :: A :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Bp :: N :: T :: nil) ((C :: nil) ++ (A :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpNTmtmp;try rewrite HT2 in HACBpNTmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Bp :: N :: T :: nil) (nil) 3 0 1 HACBpNTmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HACBpNTM1. try clear HACBpNTM2. try clear HACBpNTM3. try clear HACBpNTm4. try clear HACBpNTm3. try clear HACBpNTm2. try clear HACBpNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HABpNTm3 : rk(A :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNTeq : rk(Oo :: A :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoACBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNTmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: A :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Bp :: N :: T :: nil) ((Oo :: A :: C :: nil) ++ (A :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTmtmp;try rewrite HT2 in HOoACBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Bp :: N :: T :: nil) (A :: nil) 4 1 2 HOoACBpNTmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HABpNTM : rk(A :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpNTm : rk(A :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HABpNTeq HABpNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAN *)
(* dans la couche 0 *)
Lemma LBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBpNTM : rk(Bp :: N :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpNTeq HBpNTM3).
assert(HBpNTm : rk(Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HBpNTeq HBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AN requis par la preuve de (?)AN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HANm2 : rk(A :: N :: nil) >= 2).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HABpNTeq : rk(A :: Bp :: N :: T :: nil) = 3) by (apply LABpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpNTmtmp : rk(A :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HABpNTeq HABpNTm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (A :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: N :: T :: nil) (A :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: N :: Bp :: N :: T :: nil) ((A :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpNTmtmp;try rewrite HT2 in HABpNTmtmp.
	assert(HT := rule_2 (A :: N :: nil) (Bp :: N :: T :: nil) (N :: nil) 3 1 2 HABpNTmtmp HNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HANM : rk(A :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HANeq HANM2).
assert(HANm : rk(A :: N ::  nil) >= 1) by (solve_hyps_min HANeq HANm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAN *)
(* dans la couche 0 *)
Lemma LOoABpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNT requis par la preuve de (?)OoABpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNT requis par la preuve de (?)OoABpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNT requis par la preuve de (?)OoABpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNTm2 : rk(Oo :: A :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABpNTm3 : rk(Oo :: A :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACBpNTeq : rk(Oo :: A :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoACBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNTmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: nil) (C :: Oo :: A :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Bp :: N :: T :: nil) ((C :: nil) ++ (Oo :: A :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTmtmp;try rewrite HT2 in HOoACBpNTmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Bp :: N :: T :: nil) (nil) 4 0 1 HOoACBpNTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABpNTm4 : rk(Oo :: A :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNTeq : rk(Oo :: A :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoACBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNTmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: Oo :: A :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Bp :: N :: T :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTmtmp;try rewrite HT2 in HOoACBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Bp :: N :: T :: nil) (Oo :: A :: nil) 4 2 2 HOoACBpNTmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABpNTM : rk(Oo :: A :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNTm : rk(Oo :: A :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABpNTeq HOoABpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAN requis par la preuve de (?)OoAN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAN requis par la preuve de (?)OoAN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANm2 : rk(Oo :: A :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoANm3 : rk(Oo :: A :: N :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoABpNTeq : rk(Oo :: A :: Bp :: N :: T :: nil) = 4) by (apply LOoABpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNTmtmp : rk(Oo :: A :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABpNTeq HOoABpNTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: A :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: T :: nil) (Oo :: A :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: Bp :: N :: T :: nil) ((Oo :: A :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNTmtmp;try rewrite HT2 in HOoABpNTmtmp.
	assert(HT := rule_2 (Oo :: A :: N :: nil) (Bp :: N :: T :: nil) (N :: nil) 4 1 2 HOoABpNTmtmp HNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoANM : rk(Oo :: A :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoANeq HOoANM3).
assert(HOoANm : rk(Oo :: A :: N ::  nil) >= 1) by (solve_hyps_min HOoANeq HOoANm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBN *)
(* dans constructLemma(), requis par LBBpNT *)
(* dans la couche 0 *)
Lemma LOoBCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCBpNTm3 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: Oo :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNTmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoBCBpNTm4 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: Oo :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: nil) 4 2 2 HOoABCBpNTmtmp HOoBmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoBCBpNTM : rk(Oo :: B :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpNTm : rk(Oo :: B :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpNT requis par la preuve de (?)BBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpNT requis par la preuve de (?)BBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpNT requis par la preuve de (?)BCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpNT requis par la preuve de (?)BCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCBpNTm2 : rk(B :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: nil) ++ (B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Bp :: N :: T :: nil) (nil) 4 0 2 HOoABCBpNTmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCBpNTm3 : rk(B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Bp :: N :: T :: nil) (B :: nil) 4 1 2 HOoABCBpNTmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpNT requis par la preuve de (?)BBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpNT requis par la preuve de (?)BBpNT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBBpNTM3 : rk(B :: Bp :: N :: T :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: T :: nil) (B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: N :: T :: nil) ((B :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: N :: T :: nil) (nil) 1 2 0 HBMtmp HBpNTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HBBpNTm2 : rk(B :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBCBpNTmtmp : rk(B :: C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HBCBpNTeq HBCBpNTm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (B :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: N :: T :: nil) (C :: B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: B :: Bp :: N :: T :: nil) ((C :: nil) ++ (B :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpNTmtmp;try rewrite HT2 in HBCBpNTmtmp.
	assert(HT := rule_4 (C :: nil) (B :: Bp :: N :: T :: nil) (nil) 3 0 1 HBCBpNTmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HBCBpNTM1. try clear HBCBpNTM2. try clear HBCBpNTM3. try clear HBCBpNTm4. try clear HBCBpNTm3. try clear HBCBpNTm2. try clear HBCBpNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBBpNTm3 : rk(B :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCBpNTeq : rk(Oo :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoBCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNTmtmp : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: C :: B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: Bp :: N :: T :: nil) ((Oo :: B :: C :: nil) ++ (B :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNTmtmp;try rewrite HT2 in HOoBCBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: Bp :: N :: T :: nil) (B :: nil) 4 1 2 HOoBCBpNTmtmp HBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBBpNTM : rk(B :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpNTm : rk(B :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HBBpNTeq HBBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BN requis par la preuve de (?)BN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBNm2 : rk(B :: N :: nil) >= 2).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HBBpNTeq : rk(B :: Bp :: N :: T :: nil) = 3) by (apply LBBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpNTmtmp : rk(B :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HBBpNTeq HBBpNTm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (B :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: T :: nil) (B :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: N :: Bp :: N :: T :: nil) ((B :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpNTmtmp;try rewrite HT2 in HBBpNTmtmp.
	assert(HT := rule_2 (B :: N :: nil) (Bp :: N :: T :: nil) (N :: nil) 3 1 2 HBBpNTmtmp HNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HBNM : rk(B :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBNeq HBNM2).
assert(HBNm : rk(B :: N ::  nil) >= 1) by (solve_hyps_min HBNeq HBNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBN *)
(* dans la couche 0 *)
Lemma LOoBBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpNT requis par la preuve de (?)OoBBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpNT requis par la preuve de (?)OoBBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpNT requis par la preuve de (?)OoBBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNTm2 : rk(Oo :: B :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBBpNTm3 : rk(Oo :: B :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoBCBpNTeq : rk(Oo :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoBCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNTmtmp : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: T :: nil) (C :: Oo :: B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Bp :: N :: T :: nil) ((C :: nil) ++ (Oo :: B :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNTmtmp;try rewrite HT2 in HOoBCBpNTmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: B :: Bp :: N :: T :: nil) (nil) 4 0 1 HOoBCBpNTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBBpNTm4 : rk(Oo :: B :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCBpNTeq : rk(Oo :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoBCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNTmtmp : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: B :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: C :: Oo :: B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: B :: Bp :: N :: T :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: B :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNTmtmp;try rewrite HT2 in HOoBCBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: B :: Bp :: N :: T :: nil) (Oo :: B :: nil) 4 2 2 HOoBCBpNTmtmp HOoBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HOoBBpNTM : rk(Oo :: B :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpNTm : rk(Oo :: B :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBBpNTeq HOoBBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBN requis par la preuve de (?)OoBN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBN requis par la preuve de (?)OoBN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBNm2 : rk(Oo :: B :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBNm3 : rk(Oo :: B :: N :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoBBpNTeq : rk(Oo :: B :: Bp :: N :: T :: nil) = 4) by (apply LOoBBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNTmtmp : rk(Oo :: B :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBBpNTeq HOoBBpNTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: B :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: N :: T :: nil) (Oo :: B :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: N :: Bp :: N :: T :: nil) ((Oo :: B :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpNTmtmp;try rewrite HT2 in HOoBBpNTmtmp.
	assert(HT := rule_2 (Oo :: B :: N :: nil) (Bp :: N :: T :: nil) (N :: nil) 4 1 2 HOoBBpNTmtmp HNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoBNM : rk(Oo :: B :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBNeq HOoBNM3).
assert(HOoBNm : rk(Oo :: B :: N ::  nil) >= 1) by (solve_hyps_min HOoBNeq HOoBNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABN *)
(* dans constructLemma(), requis par LABBpNT *)
(* dans la couche 0 *)
Lemma LABCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCBpNT requis par la preuve de (?)ABCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpNT requis par la preuve de (?)ABCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCBpNTm3 : rk(A :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: A :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Bp :: N :: T :: nil) (A :: nil) 4 1 2 HOoABCBpNTmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCBpNTm4 : rk(A :: B :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: A :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Bp :: N :: T :: nil) (A :: B :: nil) 4 2 2 HOoABCBpNTmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCBpNTM : rk(A :: B :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpNTm : rk(A :: B :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HABCBpNTeq HABCBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpNT requis par la preuve de (?)ABBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpNT requis par la preuve de (?)ABBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpNT requis par la preuve de (?)ABBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpNTm2 : rk(A :: B :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Bp :: N :: T :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABBpNTm3 : rk(A :: B :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCBpNTeq : rk(A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCBpNTmtmp : rk(A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HABCBpNTeq HABCBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: N :: T :: nil) (C :: A :: B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Bp :: N :: T :: nil) ((C :: nil) ++ (A :: B :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpNTmtmp;try rewrite HT2 in HABCBpNTmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Bp :: N :: T :: nil) (nil) 4 0 1 HABCBpNTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABBpNTm4 : rk(A :: B :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCBpNTeq : rk(A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCBpNTmtmp : rk(A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HABCBpNTeq HABCBpNTm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: N :: T :: nil) (A :: B :: C :: A :: B :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Bp :: N :: T :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpNTmtmp;try rewrite HT2 in HABCBpNTmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Bp :: N :: T :: nil) (A :: B :: nil) 4 2 2 HABCBpNTmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABBpNTM : rk(A :: B :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpNTm : rk(A :: B :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HABBpNTeq HABBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABN requis par la preuve de (?)ABN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABN requis par la preuve de (?)ABN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNm2 : rk(A :: B :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABNm3 : rk(A :: B :: N :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HABBpNTeq : rk(A :: B :: Bp :: N :: T :: nil) = 4) by (apply LABBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABBpNTmtmp : rk(A :: B :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HABBpNTeq HABBpNTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (A :: B :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: N :: T :: nil) (A :: B :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: N :: Bp :: N :: T :: nil) ((A :: B :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpNTmtmp;try rewrite HT2 in HABBpNTmtmp.
	assert(HT := rule_2 (A :: B :: N :: nil) (Bp :: N :: T :: nil) (N :: nil) 4 1 2 HABBpNTmtmp HNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HABNM : rk(A :: B :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABNeq HABNM3).
assert(HABNm : rk(A :: B :: N ::  nil) >= 1) by (solve_hyps_min HABNeq HABNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABN *)
(* dans la couche 0 *)
Lemma LOoABApMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNSp requis par la preuve de (?)OoABApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNSp requis par la preuve de (?)OoABApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNSp requis par la preuve de (?)OoABApMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMNSpM : rk(Oo :: A :: B :: Ap :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMNSpm : rk(Oo :: A :: B :: Ap :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApMNSpeq HOoABApMNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABN *)
(* dans la couche 0 *)
Lemma LOoAApMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMNSp requis par la preuve de (?)OoAApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMNSp requis par la preuve de (?)OoAApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMNSp requis par la preuve de (?)OoAApMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNSpm2 : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNSpm3 : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNSpm4 : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMNSpM : rk(Oo :: A :: Ap :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMNSpm : rk(Oo :: A :: Ap :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApMNSpeq HOoAApMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABN requis par la preuve de (?)OoABN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABN requis par la preuve de (?)OoABN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABN requis par la preuve de (?)OoABN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNm2 : rk(Oo :: A :: B :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABNM3 : rk(Oo :: A :: B :: N :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: nil) (Oo :: A :: B :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: nil) ((Oo :: A :: B :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (N :: nil) (nil) 2 1 0 HOoABMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABNm3 : rk(Oo :: A :: B :: N :: nil) >= 3).
{
	try assert(HOoAApMNSpeq : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoAApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMNSpMtmp : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMNSpeq HOoAApMNSpM4).
	try assert(HOoABApMNSpeq : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoABApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMNSpmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMNSpeq HOoABApMNSpm4).
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hincl : incl (Oo :: A :: N :: nil) (list_inter (Oo :: A :: B :: N :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) (Oo :: A :: B :: N :: Oo :: A :: Ap :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: Oo :: A :: Ap :: M :: N :: Sp :: nil) ((Oo :: A :: B :: N :: nil) ++ (Oo :: A :: Ap :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNSpmtmp;try rewrite HT2 in HOoABApMNSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: N :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil) (Oo :: A :: N :: nil) 4 3 4 HOoABApMNSpmtmp HOoANmtmp HOoAApMNSpMtmp Hincl);apply HT.
}


assert(HOoABNM : rk(Oo :: A :: B :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABNm : rk(Oo :: A :: B :: N ::  nil) >= 1) by (solve_hyps_min HOoABNeq HOoABNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCN *)
(* dans la couche 0 *)
Lemma LOoCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCBpNTm3 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: Oo :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNTmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNTm2 : rk(Oo :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCBpNTmtmp : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: Oo :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Bp :: N :: T :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNTmtmp;try rewrite HT2 in HOoBCBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil) (Oo :: nil) 3 1 2 HOoBCBpNTmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNTm3 : rk(Oo :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: Oo :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNTmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoCBpNTm4 : rk(Oo :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNTeq : rk(Oo :: A :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoACBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNTmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm4).
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hincl : incl (Oo :: C :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: Oo :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: C :: Bp :: N :: T :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTmtmp;try rewrite HT2 in HOoACBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: C :: Bp :: N :: T :: nil) (Oo :: C :: nil) 4 2 2 HOoACBpNTmtmp HOoCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoCBpNTM : rk(Oo :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpNTm : rk(Oo :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoCBpNTeq HOoCBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCN requis par la preuve de (?)OoCN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCN requis par la preuve de (?)OoCN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCNm2 : rk(Oo :: C :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCNm3 : rk(Oo :: C :: N :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoCBpNTeq : rk(Oo :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCBpNTmtmp : rk(Oo :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoCBpNTeq HOoCBpNTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: C :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: N :: T :: nil) (Oo :: C :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: N :: Bp :: N :: T :: nil) ((Oo :: C :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpNTmtmp;try rewrite HT2 in HOoCBpNTmtmp.
	assert(HT := rule_2 (Oo :: C :: N :: nil) (Bp :: N :: T :: nil) (N :: nil) 4 1 2 HOoCBpNTmtmp HNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoCNM : rk(Oo :: C :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCNeq HOoCNM3).
assert(HOoCNm : rk(Oo :: C :: N ::  nil) >= 1) by (solve_hyps_min HOoCNeq HOoCNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApN *)
(* dans constructLemma(), requis par LOoBApNV *)
(* dans constructLemma(), requis par LOoBApCpNV *)
(* dans la couche 0 *)
Lemma LOoBApBpCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoBApBpCpNVM : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpCpNVm : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpNV requis par la preuve de (?)OoBApCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpNV requis par la preuve de (?)OoBApCpNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpNV requis par la preuve de (?)OoBApCpNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpNVm2 : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Cp :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpNVm3 : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: N :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBApCpNVm4 : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Ap :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Ap :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Ap :: Cp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Ap :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Ap :: Cp :: N :: V :: nil) (Oo :: Ap :: nil) 4 2 2 HOoBApBpCpNVmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoBApCpNVM : rk(Oo :: B :: Ap :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpNVm : rk(Oo :: B :: Ap :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBApCpNVeq HOoBApCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApNV requis par la preuve de (?)OoBApNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApNV requis par la preuve de (?)OoBApNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApNV requis par la preuve de (?)OoBApNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNVm2 : rk(Oo :: B :: Ap :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNVm3 : rk(Oo :: B :: Ap :: N :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoBApNVm4 : rk(Oo :: B :: Ap :: N :: V :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNVeq : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) = 4) by (apply LOoBApCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNVeq HOoBApCpNVm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: B :: Ap :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: V :: nil) (Oo :: Ap :: Cp :: Oo :: B :: Ap :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: B :: Ap :: N :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: B :: Ap :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNVmtmp;try rewrite HT2 in HOoBApCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: B :: Ap :: N :: V :: nil) (Oo :: Ap :: nil) 4 2 2 HOoBApCpNVmtmp HOoApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoBApNVM : rk(Oo :: B :: Ap :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApNVm : rk(Oo :: B :: Ap :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBApNVeq HOoBApNVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApN *)
(* dans la couche 0 *)
Lemma LBNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: N :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBNVM : rk(B :: N :: V ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBNVeq HBNVM3).
assert(HBNVm : rk(B :: N :: V ::  nil) >= 1) by (solve_hyps_min HBNVeq HBNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApN requis par la preuve de (?)OoApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApN requis par la preuve de (?)OoApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApNm2 : rk(Oo :: Ap :: N :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: N :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApNm3 : rk(Oo :: Ap :: N :: nil) >= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HOoBApNVeq : rk(Oo :: B :: Ap :: N :: V :: nil) = 4) by (apply LOoBApNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNVmtmp : rk(Oo :: B :: Ap :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApNVeq HOoBApNVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: Ap :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: N :: V :: nil) (Oo :: Ap :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: N :: B :: N :: V :: nil) ((Oo :: Ap :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApNVmtmp;try rewrite HT2 in HOoBApNVmtmp.
	assert(HT := rule_2 (Oo :: Ap :: N :: nil) (B :: N :: V :: nil) (N :: nil) 4 1 2 HOoBApNVmtmp HNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HOoApNM : rk(Oo :: Ap :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApNeq HOoApNM3).
assert(HOoApNm : rk(Oo :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoApNeq HOoApNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApN requis par la preuve de (?)OoBApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoBApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm2 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm3 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApN requis par la preuve de (?)OoBApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApN requis par la preuve de (?)OoBApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNm2 : rk(Oo :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApNm3 : rk(Oo :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoABApNeq HOoABApNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNmtmp;try rewrite HT2 in HOoABApNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApNm4 : rk(Oo :: B :: Ap :: N :: nil) >= 4).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HOoBApNVeq : rk(Oo :: B :: Ap :: N :: V :: nil) = 4) by (apply LOoBApNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNVmtmp : rk(Oo :: B :: Ap :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApNVeq HOoBApNVm4).
	try assert(HBNeq : rk(B :: N :: nil) = 2) by (apply LBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNmtmp : rk(B :: N :: nil) >= 2) by (solve_hyps_min HBNeq HBNm2).
	assert(Hincl : incl (B :: N :: nil) (list_inter (Oo :: B :: Ap :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: N :: V :: nil) (Oo :: B :: Ap :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: N :: B :: N :: V :: nil) ((Oo :: B :: Ap :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApNVmtmp;try rewrite HT2 in HOoBApNVmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: N :: nil) (B :: N :: V :: nil) (B :: N :: nil) 4 2 2 HOoBApNVmtmp HBNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HOoBApNM : rk(Oo :: B :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApNm : rk(Oo :: B :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoBApNeq HOoBApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABApN *)
(* dans la couche 0 *)
Lemma LOoBApMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApMNSp requis par la preuve de (?)OoBApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApMNSp requis par la preuve de (?)OoBApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApMNSp requis par la preuve de (?)OoBApMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNSpm2 : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNSpm3 : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNSpm4 : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoBApMeq : rk(Oo :: B :: Ap :: M :: nil) = 4) by (apply LOoBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMmtmp : rk(Oo :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoBApMeq HOoBApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil) 4 4 HOoBApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApMNSpM : rk(Oo :: B :: Ap :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMNSpm : rk(Oo :: B :: Ap :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApMNSpeq HOoBApMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm2 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm3 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABApNm4 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4).
{
	try assert(HOoBApMNSpeq : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoBApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNSpMtmp : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoBApMNSpeq HOoBApMNSpM4).
	try assert(HOoABApMNSpeq : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoABApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMNSpmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMNSpeq HOoABApMNSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: A :: B :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Sp :: nil) (Oo :: A :: B :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Sp :: nil) ((Oo :: A :: B :: Ap :: N :: nil) ++ (Oo :: B :: Ap :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNSpmtmp;try rewrite HT2 in HOoABApMNSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoABApMNSpmtmp HOoBApNmtmp HOoBApMNSpMtmp Hincl);apply HT.
}


assert(HOoABApNM : rk(Oo :: A :: B :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApNm : rk(Oo :: A :: B :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoABApNeq HOoABApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApN *)
(* dans la couche 0 *)
Lemma LOoBCApNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNV requis par la preuve de (?)OoBCApNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNV requis par la preuve de (?)OoBCApNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNV requis par la preuve de (?)OoBCApNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNVm2 : rk(Oo :: B :: C :: Ap :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNVm3 : rk(Oo :: B :: C :: Ap :: N :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNVm4 : rk(Oo :: B :: C :: Ap :: N :: V :: nil) >= 4).
{
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: V :: nil) 4 4 HOoBApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCApNVM : rk(Oo :: B :: C :: Ap :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNVm : rk(Oo :: B :: C :: Ap :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBCApNVeq HOoBCApNVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApN *)
(* dans la couche 0 *)
Lemma LOoBCNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCNV requis par la preuve de (?)OoBCNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCNV requis par la preuve de (?)OoBCNV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCNV requis par la preuve de (?)OoBCNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCNVm2 : rk(Oo :: B :: C :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBCNVM3 : rk(Oo :: B :: C :: N :: V :: nil) <= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: N :: V :: nil) (Oo :: B :: C :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: N :: V :: nil) ((Oo :: B :: C :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: nil) (B :: N :: V :: nil) (B :: nil) 2 2 1 HOoBCMtmp HBNVMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCNVm3 : rk(Oo :: B :: C :: N :: V :: nil) >= 3).
{
	try assert(HOoBNeq : rk(Oo :: B :: N :: nil) = 3) by (apply LOoBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBNmtmp : rk(Oo :: B :: N :: nil) >= 3) by (solve_hyps_min HOoBNeq HOoBNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: N :: nil) (Oo :: B :: C :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: N :: nil) (Oo :: B :: C :: N :: V :: nil) 3 3 HOoBNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCNVM : rk(Oo :: B :: C :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCNVm : rk(Oo :: B :: C :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBCNVeq HOoBCNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApN requis par la preuve de (?)OoCApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm2 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm3 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApN requis par la preuve de (?)OoCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApN requis par la preuve de (?)OoCApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNm2 : rk(Oo :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: N ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApNm3 : rk(Oo :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApNmtmp : rk(Oo :: A :: C :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoACApNeq HOoACApNm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: N :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApNmtmp;try rewrite HT2 in HOoACApNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApNmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApNm4 : rk(Oo :: C :: Ap :: N :: nil) >= 4).
{
	try assert(HOoBCNVeq : rk(Oo :: B :: C :: N :: V :: nil) = 3) by (apply LOoBCNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCNVMtmp : rk(Oo :: B :: C :: N :: V :: nil) <= 3) by (solve_hyps_max HOoBCNVeq HOoBCNVM3).
	try assert(HOoBCApNVeq : rk(Oo :: B :: C :: Ap :: N :: V :: nil) = 4) by (apply LOoBCApNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNVmtmp : rk(Oo :: B :: C :: Ap :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBCApNVeq HOoBCApNVm4).
	try assert(HOoCNeq : rk(Oo :: C :: N :: nil) = 3) by (apply LOoCN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCNmtmp : rk(Oo :: C :: N :: nil) >= 3) by (solve_hyps_min HOoCNeq HOoCNm3).
	assert(Hincl : incl (Oo :: C :: N :: nil) (list_inter (Oo :: C :: Ap :: N :: nil) (Oo :: B :: C :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: N :: V :: nil) (Oo :: C :: Ap :: N :: Oo :: B :: C :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: N :: Oo :: B :: C :: N :: V :: nil) ((Oo :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApNVmtmp;try rewrite HT2 in HOoBCApNVmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: N :: nil) (Oo :: B :: C :: N :: V :: nil) (Oo :: C :: N :: nil) 4 3 3 HOoBCApNVmtmp HOoCNmtmp HOoBCNVMtmp Hincl);apply HT.
}


assert(HOoCApNM : rk(Oo :: C :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApNm : rk(Oo :: C :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoCApNeq HOoCApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACApN *)
(* dans la couche 0 *)
Lemma LOoACApMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMNSp requis par la preuve de (?)OoACApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMNSp requis par la preuve de (?)OoACApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMNSp requis par la preuve de (?)OoACApMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNSpm2 : rk(Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNSpm3 : rk(Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNSpm4 : rk(Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApMNSpM : rk(Oo :: A :: C :: Ap :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMNSpm : rk(Oo :: A :: C :: Ap :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACApMNSpeq HOoACApMNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACApN *)
(* dans la couche 0 *)
Lemma LOoCApMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMNSp requis par la preuve de (?)OoCApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMNSp requis par la preuve de (?)OoCApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMNSp requis par la preuve de (?)OoCApMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNSpm2 : rk(Oo :: C :: Ap :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNSpm3 : rk(Oo :: C :: Ap :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNSpm4 : rk(Oo :: C :: Ap :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApMNSpM : rk(Oo :: C :: Ap :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMNSpm : rk(Oo :: C :: Ap :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApMNSpeq HOoCApMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm2 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm3 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACApNm4 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 4).
{
	try assert(HOoCApMNSpeq : rk(Oo :: C :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoCApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMNSpMtmp : rk(Oo :: C :: Ap :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoCApMNSpeq HOoCApMNSpM4).
	try assert(HOoACApMNSpeq : rk(Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoACApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMNSpmtmp : rk(Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMNSpeq HOoACApMNSpm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: N :: Sp :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: C :: Ap :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: C :: Ap :: M :: N :: Sp :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: C :: Ap :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMNSpmtmp;try rewrite HT2 in HOoACApMNSpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: M :: N :: Sp :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoACApMNSpmtmp HOoCApNmtmp HOoCApMNSpMtmp Hincl);apply HT.
}


assert(HOoACApNM : rk(Oo :: A :: C :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApNm : rk(Oo :: A :: C :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoACApNeq HOoACApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApN *)
(* dans la couche 0 *)
Lemma LOoBCApMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMNSp requis par la preuve de (?)OoBCApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApMNSp requis par la preuve de (?)OoBCApMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMNSp requis par la preuve de (?)OoBCApMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMNSpm2 : rk(Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMNSpm3 : rk(Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMNSpm4 : rk(Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoBApMeq : rk(Oo :: B :: Ap :: M :: nil) = 4) by (apply LOoBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMmtmp : rk(Oo :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoBApMeq HOoBApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) 4 4 HOoBApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCApMNSpM : rk(Oo :: B :: C :: Ap :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApMNSpm : rk(Oo :: B :: C :: Ap :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBCApMNSpeq HOoBCApMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApN requis par la preuve de (?)OoBCApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApN requis par la preuve de (?)OoBCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApN requis par la preuve de (?)OoABCApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApN requis par la preuve de (?)OoABCApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNm2 : rk(Oo :: A :: B :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNm3 : rk(Oo :: A :: B :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApN requis par la preuve de (?)OoBCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApN requis par la preuve de (?)OoBCApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNm2 : rk(Oo :: B :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApNm3 : rk(Oo :: B :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApNmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoABCApNeq HOoABCApNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNmtmp;try rewrite HT2 in HOoABCApNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApNM1. try clear HOoABCApNM2. try clear HOoABCApNM3. try clear HOoABCApNm4. try clear HOoABCApNm3. try clear HOoABCApNm2. try clear HOoABCApNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBCApNm4 : rk(Oo :: B :: C :: Ap :: N :: nil) >= 4).
{
	try assert(HOoBApMNSpeq : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoBApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNSpMtmp : rk(Oo :: B :: Ap :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoBApMNSpeq HOoBApMNSpM4).
	try assert(HOoBCApMNSpeq : rk(Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoBCApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMNSpmtmp : rk(Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMNSpeq HOoBCApMNSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: N :: Sp :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Sp :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: B :: Ap :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMNSpmtmp;try rewrite HT2 in HOoBCApMNSpmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoBCApMNSpmtmp HOoBApNmtmp HOoBApMNSpMtmp Hincl);apply HT.
}


assert(HOoBCApNM : rk(Oo :: B :: C :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNm : rk(Oo :: B :: C :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoBCApNeq HOoBCApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpN *)
(* dans constructLemma(), requis par LBBpNV *)
(* dans la couche 0 *)
Lemma LOoBBpCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpNV requis par la preuve de (?)OoBBpCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpNV requis par la preuve de (?)OoBBpCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpNV requis par la preuve de (?)OoBBpCpNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNVm2 : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoBBpCpNVm3 : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: B :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Ap :: Oo :: B :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: B :: Bp :: Cp :: N :: V :: nil) ((Ap :: nil) ++ (Oo :: B :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: B :: Bp :: Cp :: N :: V :: nil) (nil) 4 0 1 HOoBApBpCpNVmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBBpCpNVm4 : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Bp :: Cp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: V :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBApBpCpNVmtmp HOoBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoBBpCpNVM : rk(Oo :: B :: Bp :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpNVm : rk(Oo :: B :: Bp :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBBpCpNVeq HOoBBpCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpNV requis par la preuve de (?)BBpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpNV requis par la preuve de (?)BBpNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpNV requis par la preuve de (?)BBpNV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBBpNVM3 : rk(B :: Bp :: N :: V :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: V :: nil) (Bp :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: N :: V :: nil) ((Bp :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (B :: N :: V :: nil) (nil) 1 2 0 HBpMtmp HBNVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpNVm2 : rk(B :: Bp :: N :: V :: nil) >= 2).
{
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: N :: V :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpNVm3 : rk(B :: Bp :: N :: V :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoBBpCpNVeq : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpNVmtmp : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBBpCpNVeq HOoBBpCpNVm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: V :: nil) (Oo :: Bp :: Cp :: B :: Bp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: N :: V :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNVmtmp;try rewrite HT2 in HOoBBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: N :: V :: nil) (Bp :: nil) 4 1 2 HOoBBpCpNVmtmp HBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HBBpNVM : rk(B :: Bp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpNVm : rk(B :: Bp :: N :: V ::  nil) >= 1) by (solve_hyps_min HBBpNVeq HBBpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpN requis par la preuve de (?)BpN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpNm2 : rk(Bp :: N :: nil) >= 2).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBBpNVeq : rk(B :: Bp :: N :: V :: nil) = 3) by (apply LBBpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpNVmtmp : rk(B :: Bp :: N :: V :: nil) >= 3) by (solve_hyps_min HBBpNVeq HBBpNVm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: V :: nil) (Bp :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: B :: N :: V :: nil) ((Bp :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpNVmtmp;try rewrite HT2 in HBBpNVmtmp.
	assert(HT := rule_2 (Bp :: N :: nil) (B :: N :: V :: nil) (N :: nil) 3 1 2 HBBpNVmtmp HNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HBpNM : rk(Bp :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpNeq HBpNM2).
assert(HBpNm : rk(Bp :: N ::  nil) >= 1) by (solve_hyps_min HBpNeq HBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpN *)
(* dans la couche 0 *)
Lemma LOoBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpNT requis par la preuve de (?)OoBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpNT requis par la preuve de (?)OoBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCBpNTm3 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: Oo :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNTmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpNT requis par la preuve de (?)OoCBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNTm2 : rk(Oo :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCBpNTmtmp : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: Oo :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Bp :: N :: T :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNTmtmp;try rewrite HT2 in HOoBCBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil) (Oo :: nil) 3 1 2 HOoBCBpNTmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNTm3 : rk(Oo :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: Oo :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNTmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpNT requis par la preuve de (?)OoBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpNT requis par la preuve de (?)OoBpNT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBpNTM3 : rk(Oo :: Bp :: N :: T :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: N :: T :: nil) (Oo :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: N :: T :: nil) ((Oo :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Bp :: N :: T :: nil) (nil) 1 2 0 HOoMtmp HBpNTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBpNTm2 : rk(Oo :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoCBpNTmtmp : rk(Oo :: C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HOoCBpNTeq HOoCBpNTm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: N :: T :: nil) (C :: Oo :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Bp :: N :: T :: nil) ((C :: nil) ++ (Oo :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpNTmtmp;try rewrite HT2 in HOoCBpNTmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: Bp :: N :: T :: nil) (nil) 3 0 1 HOoCBpNTmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HOoCBpNTM1. try clear HOoCBpNTM2. try clear HOoCBpNTM3. try clear HOoCBpNTm4. try clear HOoCBpNTm3. try clear HOoCBpNTm2. try clear HOoCBpNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoBpNTm3 : rk(Oo :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNTeq : rk(Oo :: A :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoACBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNTmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: Oo :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Bp :: N :: T :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTmtmp;try rewrite HT2 in HOoACBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: Bp :: N :: T :: nil) (Oo :: nil) 4 1 2 HOoACBpNTmtmp HOomtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoBpNTM : rk(Oo :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpNTm : rk(Oo :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBpNTeq HOoBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpN requis par la preuve de (?)OoBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpN requis par la preuve de (?)OoBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpNm2 : rk(Oo :: Bp :: N :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: N :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpNm3 : rk(Oo :: Bp :: N :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoBpNTeq : rk(Oo :: Bp :: N :: T :: nil) = 3) by (apply LOoBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpNTmtmp : rk(Oo :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HOoBpNTeq HOoBpNTm3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: Bp :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: N :: T :: nil) (Oo :: Bp :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: N :: Bp :: N :: T :: nil) ((Oo :: Bp :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpNTmtmp;try rewrite HT2 in HOoBpNTmtmp.
	assert(HT := rule_2 (Oo :: Bp :: N :: nil) (Bp :: N :: T :: nil) (Bp :: N :: nil) 3 2 2 HOoBpNTmtmp HBpNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoBpNM : rk(Oo :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpNeq HOoBpNM3).
assert(HOoBpNm : rk(Oo :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBpNeq HOoBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpN requis par la preuve de (?)OoABpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpN requis par la preuve de (?)OoABpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpN requis par la preuve de (?)OoABpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNm2 : rk(Oo :: A :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNm3 : rk(Oo :: A :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpNm4 : rk(Oo :: A :: Bp :: N :: nil) >= 4).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoABpNTeq : rk(Oo :: A :: Bp :: N :: T :: nil) = 4) by (apply LOoABpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNTmtmp : rk(Oo :: A :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABpNTeq HOoABpNTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: Bp :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: T :: nil) (Oo :: A :: Bp :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: N :: Bp :: N :: T :: nil) ((Oo :: A :: Bp :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNTmtmp;try rewrite HT2 in HOoABpNTmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: N :: nil) (Bp :: N :: T :: nil) (Bp :: N :: nil) 4 2 2 HOoABpNTmtmp HBpNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoABpNM : rk(Oo :: A :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNm : rk(Oo :: A :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABpNeq HOoABpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpN requis par la preuve de (?)OoBBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpN requis par la preuve de (?)OoBBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpN requis par la preuve de (?)OoBBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNm2 : rk(Oo :: B :: Bp :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNm3 : rk(Oo :: B :: Bp :: N :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: N :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBBpNm4 : rk(Oo :: B :: Bp :: N :: nil) >= 4).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoBBpNTeq : rk(Oo :: B :: Bp :: N :: T :: nil) = 4) by (apply LOoBBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNTmtmp : rk(Oo :: B :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBBpNTeq HOoBBpNTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: B :: Bp :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: N :: T :: nil) (Oo :: B :: Bp :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: N :: Bp :: N :: T :: nil) ((Oo :: B :: Bp :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpNTmtmp;try rewrite HT2 in HOoBBpNTmtmp.
	assert(HT := rule_2 (Oo :: B :: Bp :: N :: nil) (Bp :: N :: T :: nil) (Bp :: N :: nil) 4 2 2 HOoBBpNTmtmp HBpNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoBBpNM : rk(Oo :: B :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpNm : rk(Oo :: B :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBBpNeq HOoBBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABBpN *)
(* dans la couche 0 *)
Lemma LOoABBpMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNSp requis par la preuve de (?)OoABBpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNSp requis par la preuve de (?)OoABBpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNSp requis par la preuve de (?)OoABBpMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNSpm2 : rk(Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNSpm3 : rk(Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNSpm4 : rk(Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpMNSpM : rk(Oo :: A :: B :: Bp :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpMNSpm : rk(Oo :: A :: B :: Bp :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABBpMNSpeq HOoABBpMNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABBpN *)
(* dans la couche 0 *)
Lemma LOoABpMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMNSp requis par la preuve de (?)OoABpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMNSp requis par la preuve de (?)OoABpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMNSp requis par la preuve de (?)OoABpMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNSpm2 : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNSpm3 : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNSpm4 : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpMNSpM : rk(Oo :: A :: Bp :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMNSpm : rk(Oo :: A :: Bp :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpMNSpeq HOoABpMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm2 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm3 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpNm4 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4).
{
	try assert(HOoABpMNSpeq : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LOoABpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNSpMtmp : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMNSpeq HOoABpMNSpM4).
	try assert(HOoABBpMNSpeq : rk(Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LOoABBpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMNSpmtmp : rk(Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoABBpMNSpeq HOoABBpMNSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: N :: Sp :: nil) (Oo :: A :: B :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Sp :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Oo :: A :: Bp :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMNSpmtmp;try rewrite HT2 in HOoABBpMNSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABBpMNSpmtmp HOoABpNmtmp HOoABpMNSpMtmp Hincl);apply HT.
}


assert(HOoABBpNM : rk(Oo :: A :: B :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNm : rk(Oo :: A :: B :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABBpNeq HOoABBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpN *)
(* dans la couche 0 *)
Lemma LCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpNT requis par la preuve de (?)CBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNT requis par la preuve de (?)CBpNT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNT requis par la preuve de (?)CBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HCBpNTm2 : rk(C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: B :: nil) ++ (C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (C :: Bp :: N :: T :: nil) (nil) 4 0 2 HOoABCBpNTmtmp Hmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCBpNTM3 : rk(C :: Bp :: N :: T :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: T :: nil) (C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: T :: nil) ((C :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Bp :: N :: T :: nil) (nil) 1 2 0 HCMtmp HBpNTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HCBpNTm3 : rk(C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNTeq : rk(Oo :: A :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoACBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNTmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNTeq HOoACBpNTm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Bp :: N :: T :: nil) ((Oo :: A :: C :: nil) ++ (C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTmtmp;try rewrite HT2 in HOoACBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (C :: Bp :: N :: T :: nil) (C :: nil) 4 1 2 HOoACBpNTmtmp HCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HCBpNTM : rk(C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNTm : rk(C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HCBpNTeq HCBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpN requis par la preuve de (?)CBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpN requis par la preuve de (?)CBpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNm2 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNm3 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpN requis par la preuve de (?)CBpN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNm2 : rk(C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNmtmp : rk(Oo :: A :: C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoACBpNeq HOoACBpNm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNmtmp;try rewrite HT2 in HOoACBpNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpNM1. try clear HOoACBpNM2. try clear HOoACBpNM3. try clear HOoACBpNm4. try clear HOoACBpNm3. try clear HOoACBpNm2. try clear HOoACBpNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpNm3 : rk(C :: Bp :: N :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HCBpNTeq : rk(C :: Bp :: N :: T :: nil) = 3) by (apply LCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNTmtmp : rk(C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HCBpNTeq HCBpNTm3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (C :: Bp :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: T :: nil) (C :: Bp :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: Bp :: N :: T :: nil) ((C :: Bp :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpNTmtmp;try rewrite HT2 in HCBpNTmtmp.
	assert(HT := rule_2 (C :: Bp :: N :: nil) (Bp :: N :: T :: nil) (Bp :: N :: nil) 3 2 2 HCBpNTmtmp HBpNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HCBpNM : rk(C :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpNeq HCBpNM3).
assert(HCBpNm : rk(C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HCBpNeq HCBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpN *)
(* dans constructLemma(), requis par LBApBpNV *)
(* dans la couche 0 *)
Lemma LBApBpCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApBpCpNV requis par la preuve de (?)BApBpCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpCpNV requis par la preuve de (?)BApBpCpNV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HBApBpCpNVm3 : rk(B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: nil) (B :: Ap :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: B :: B :: Ap :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: B :: Ap :: Bp :: Cp :: N :: V :: nil) ((Oo :: B :: nil) ++ (B :: Ap :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (B :: Ap :: Bp :: Cp :: N :: V :: nil) (B :: nil) 4 1 2 HOoBApBpCpNVmtmp HBmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBApBpCpNVm4 : rk(B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: Bp :: B :: Ap :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Ap :: Bp :: Cp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Ap :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: Cp :: N :: V :: nil) (Ap :: Bp :: nil) 4 2 2 HOoBApBpCpNVmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HBApBpCpNVM : rk(B :: Ap :: Bp :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpCpNVm : rk(B :: Ap :: Bp :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HBApBpCpNVeq HBApBpCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApBpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: Bp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApBpNV requis par la preuve de (?)BApBpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpNV requis par la preuve de (?)BApBpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpNV requis par la preuve de (?)OoBApBpNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpNV requis par la preuve de (?)OoBApBpNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNVm2 : rk(Oo :: B :: Ap :: Bp :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNVm3 : rk(Oo :: B :: Ap :: Bp :: N :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: N :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApBpNV requis par la preuve de (?)BApBpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpNV requis par la preuve de (?)BApBpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpNV requis par la preuve de (?)OoABApBpNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpNV requis par la preuve de (?)OoABApBpNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNVm2 : rk(Oo :: A :: B :: Ap :: Bp :: N :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNVm3 : rk(Oo :: A :: B :: Ap :: Bp :: N :: V :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: V :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpNV requis par la preuve de (?)BApBpNV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: N :: V ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApBpNVm2 : rk(B :: Ap :: Bp :: N :: V :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpNVmtmp : rk(Oo :: A :: B :: Ap :: Bp :: N :: V :: nil) >= 3) by (solve_hyps_min HOoABApBpNVeq HOoABApBpNVm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: Bp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: N :: V :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: Bp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: Bp :: N :: V :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: Bp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpNVmtmp;try rewrite HT2 in HOoABApBpNVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: Bp :: N :: V :: nil) (B :: Ap :: nil) 3 2 3 HOoABApBpNVmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HBApM1. try clear HBApM2. try clear HBApM3. try clear HBApm4. try clear HBApm3. try clear HBApm2. try clear HBApm1. try clear HOoABApBpNVM1. try clear HOoABApBpNVM2. try clear HOoABApBpNVM3. try clear HOoABApBpNVm4. try clear HOoABApBpNVm3. try clear HOoABApBpNVm2. try clear HOoABApBpNVm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: N :: V ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBApBpNVm3 : rk(B :: Ap :: Bp :: N :: V :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoBApBpNVmtmp : rk(Oo :: B :: Ap :: Bp :: N :: V :: nil) >= 3) by (solve_hyps_min HOoBApBpNVeq HOoBApBpNVm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: N :: V :: nil) (Oo :: Ap :: Bp :: B :: Ap :: Bp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Ap :: Bp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Ap :: Bp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpNVmtmp;try rewrite HT2 in HOoBApBpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: N :: V :: nil) (Ap :: Bp :: nil) 3 2 2 HOoBApBpNVmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoBApBpNVM1. try clear HOoBApBpNVM2. try clear HOoBApBpNVM3. try clear HOoBApBpNVm4. try clear HOoBApBpNVm3. try clear HOoBApBpNVm2. try clear HOoBApBpNVm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBApBpNVm4 : rk(B :: Ap :: Bp :: N :: V :: nil) >= 4).
{
	try assert(HApBpCpeq : rk(Ap :: Bp :: Cp :: nil) = 2) by (apply LApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpCpMtmp : rk(Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HApBpCpeq HApBpCpM2).
	try assert(HBApBpCpNVeq : rk(B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApBpCpNVmtmp : rk(B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HBApBpCpNVeq HBApBpCpNVm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: Cp :: nil) (B :: Ap :: Bp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: Cp :: N :: V :: nil) (Ap :: Bp :: Cp :: B :: Ap :: Bp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: B :: Ap :: Bp :: N :: V :: nil) ((Ap :: Bp :: Cp :: nil) ++ (B :: Ap :: Bp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpCpNVmtmp;try rewrite HT2 in HBApBpCpNVmtmp.
	assert(HT := rule_4 (Ap :: Bp :: Cp :: nil) (B :: Ap :: Bp :: N :: V :: nil) (Ap :: Bp :: nil) 4 2 2 HBApBpCpNVmtmp HApBpmtmp HApBpCpMtmp Hincl); apply HT.
}


assert(HBApBpNVM : rk(B :: Ap :: Bp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpNVm : rk(B :: Ap :: Bp :: N :: V ::  nil) >= 1) by (solve_hyps_min HBApBpNVeq HBApBpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNm2 : rk(Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpNm3 : rk(Ap :: Bp :: N :: nil) >= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBApBpNVeq : rk(B :: Ap :: Bp :: N :: V :: nil) = 4) by (apply LBApBpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApBpNVmtmp : rk(B :: Ap :: Bp :: N :: V :: nil) >= 4) by (solve_hyps_min HBApBpNVeq HBApBpNVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Ap :: Bp :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: N :: V :: nil) (Ap :: Bp :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: N :: B :: N :: V :: nil) ((Ap :: Bp :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpNVmtmp;try rewrite HT2 in HBApBpNVmtmp.
	assert(HT := rule_2 (Ap :: Bp :: N :: nil) (B :: N :: V :: nil) (N :: nil) 4 1 2 HBApBpNVmtmp HNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HApBpNM : rk(Ap :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpNeq HApBpNM3).
assert(HApBpNm : rk(Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HApBpNeq HApBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpN *)
(* dans la couche 0 *)
Lemma LOoAApBpMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMNSp requis par la preuve de (?)OoAApBpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMNSp requis par la preuve de (?)OoAApBpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMNSp requis par la preuve de (?)OoAApBpMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNSpm2 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNSpm3 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNSpm4 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpMNSpM : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpMNSpm : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApBpMNSpeq HOoAApBpMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNm2 : rk(Oo :: Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpNM3 : rk(Oo :: Ap :: Bp :: N :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: nil) (Oo :: Ap :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (N :: nil) (nil) 2 1 0 HOoApBpMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpNm3 : rk(Oo :: Ap :: Bp :: N :: nil) >= 3).
{
	try assert(HOoAApMNSpeq : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) = 4) by (apply LOoAApMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMNSpMtmp : rk(Oo :: A :: Ap :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMNSpeq HOoAApMNSpM4).
	try assert(HOoAApBpMNSpeq : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LOoAApBpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMNSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMNSpeq HOoAApBpMNSpm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) (Oo :: Ap :: Bp :: N :: Oo :: A :: Ap :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: Oo :: A :: Ap :: M :: N :: Sp :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (Oo :: A :: Ap :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMNSpmtmp;try rewrite HT2 in HOoAApBpMNSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: N :: nil) (Oo :: A :: Ap :: M :: N :: Sp :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoAApBpMNSpmtmp HOoApNmtmp HOoAApMNSpMtmp Hincl);apply HT.
}


assert(HOoApBpNM : rk(Oo :: Ap :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpNm : rk(Oo :: Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoApBpNeq HOoApBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpN *)
(* dans la couche 0 *)
Lemma LBCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpNV requis par la preuve de (?)BCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpNV requis par la preuve de (?)BCpNV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpNV requis par la preuve de (?)BCpNV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBCpNVm2 : rk(B :: Cp :: N :: V :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: Bp :: B :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Cp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Cp :: N :: V :: nil) (nil) 4 0 2 HOoBApBpCpNVmtmp Hmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCpNVM3 : rk(B :: Cp :: N :: V :: nil) <= 3).
{
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: N :: V :: nil) (Cp :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: B :: N :: V :: nil) ((Cp :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (B :: N :: V :: nil) (nil) 1 2 0 HCpMtmp HBNVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HBCpNVm3 : rk(B :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNVeq : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) = 4) by (apply LOoBApCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNVeq HOoBApCpNVm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (B :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: V :: nil) (Oo :: Ap :: Cp :: B :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: B :: Cp :: N :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (B :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNVmtmp;try rewrite HT2 in HOoBApCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (B :: Cp :: N :: V :: nil) (Cp :: nil) 4 1 2 HOoBApCpNVmtmp HCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HBCpNVM : rk(B :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpNVm : rk(B :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HBCpNVeq HBCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpN requis par la preuve de (?)CpN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpNm2 : rk(Cp :: N :: nil) >= 2).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBCpNVeq : rk(B :: Cp :: N :: V :: nil) = 3) by (apply LBCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNVmtmp : rk(B :: Cp :: N :: V :: nil) >= 3) by (solve_hyps_min HBCpNVeq HBCpNVm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Cp :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: N :: V :: nil) (Cp :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: N :: B :: N :: V :: nil) ((Cp :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpNVmtmp;try rewrite HT2 in HBCpNVmtmp.
	assert(HT := rule_2 (Cp :: N :: nil) (B :: N :: V :: nil) (N :: nil) 3 1 2 HBCpNVmtmp HNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HCpNM : rk(Cp :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpNeq HCpNM2).
assert(HCpNm : rk(Cp :: N ::  nil) >= 1) by (solve_hyps_min HCpNeq HCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpN *)
(* dans la couche 0 *)
Lemma LOoBCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpNV requis par la preuve de (?)OoBCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpNV requis par la preuve de (?)OoBCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpNV requis par la preuve de (?)OoBCpNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpNVm2 : rk(Oo :: B :: Cp :: N :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Cp :: N :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBCpNVm3 : rk(Oo :: B :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Cp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Cp :: N :: V :: nil) (Oo :: nil) 4 1 2 HOoBApBpCpNVmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoBCpNVm4 : rk(Oo :: B :: Cp :: N :: V :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNVeq : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) = 4) by (apply LOoBApCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNVeq HOoBApCpNVm4).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: B :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: V :: nil) (Oo :: Ap :: Cp :: Oo :: B :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: B :: Cp :: N :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: B :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNVmtmp;try rewrite HT2 in HOoBApCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: B :: Cp :: N :: V :: nil) (Oo :: Cp :: nil) 4 2 2 HOoBApCpNVmtmp HOoCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoBCpNVM : rk(Oo :: B :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpNVm : rk(Oo :: B :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoBCpNVeq HOoBCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpN requis par la preuve de (?)OoCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpN requis par la preuve de (?)OoCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpNm2 : rk(Oo :: Cp :: N :: nil) >= 2).
{
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: N :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpNm3 : rk(Oo :: Cp :: N :: nil) >= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HOoBCpNVeq : rk(Oo :: B :: Cp :: N :: V :: nil) = 4) by (apply LOoBCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCpNVmtmp : rk(Oo :: B :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBCpNVeq HOoBCpNVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: Cp :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: N :: V :: nil) (Oo :: Cp :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: N :: B :: N :: V :: nil) ((Oo :: Cp :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpNVmtmp;try rewrite HT2 in HOoBCpNVmtmp.
	assert(HT := rule_2 (Oo :: Cp :: N :: nil) (B :: N :: V :: nil) (N :: nil) 4 1 2 HOoBCpNVmtmp HNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HOoCpNM : rk(Oo :: Cp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpNeq HOoCpNM3).
assert(HOoCpNm : rk(Oo :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HOoCpNeq HOoCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpN *)
(* dans la couche 0 *)
Lemma LOoABpCpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: Cp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpNT requis par la preuve de (?)OoABpCpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpNT requis par la preuve de (?)OoABpCpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpNT requis par la preuve de (?)OoABpCpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpNTm2 : rk(Oo :: A :: Bp :: Cp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpNTm3 : rk(Oo :: A :: Bp :: Cp :: N :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: N :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpNTm4 : rk(Oo :: A :: Bp :: Cp :: N :: T :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: Bp :: Cp :: N :: T :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpCpNTM : rk(Oo :: A :: Bp :: Cp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpNTm : rk(Oo :: A :: Bp :: Cp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABpCpNTeq HOoABpCpNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpN *)
(* dans la couche 0 *)
Lemma LOoBpCpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: Cp :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCpNT requis par la preuve de (?)OoBpCpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpCpNT requis par la preuve de (?)OoBpCpNT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpCpNT requis par la preuve de (?)OoBpCpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpNTm2 : rk(Oo :: Bp :: Cp :: N :: T :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: T :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBpCpNTM3 : rk(Oo :: Bp :: Cp :: N :: T :: nil) <= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: N :: T :: nil) (Oo :: Bp :: Cp :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: Bp :: N :: T :: nil) ((Oo :: Bp :: Cp :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Bp :: Cp :: nil) (Bp :: N :: T :: nil) (Bp :: nil) 2 2 1 HOoBpCpMtmp HBpNTMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpNTm3 : rk(Oo :: Bp :: Cp :: N :: T :: nil) >= 3).
{
	try assert(HOoBpNeq : rk(Oo :: Bp :: N :: nil) = 3) by (apply LOoBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpNmtmp : rk(Oo :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoBpNeq HOoBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: N :: nil) (Oo :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: N :: nil) (Oo :: Bp :: Cp :: N :: T :: nil) 3 3 HOoBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBpCpNTM : rk(Oo :: Bp :: Cp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpCpNTm : rk(Oo :: Bp :: Cp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBpCpNTeq HOoBpCpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpN requis par la preuve de (?)OoACpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpN requis par la preuve de (?)OoACpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpN requis par la preuve de (?)OoACpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpNm2 : rk(Oo :: A :: Cp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpNm3 : rk(Oo :: A :: Cp :: N :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: N :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpNm4 : rk(Oo :: A :: Cp :: N :: nil) >= 4).
{
	try assert(HOoBpCpNTeq : rk(Oo :: Bp :: Cp :: N :: T :: nil) = 3) by (apply LOoBpCpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpNTMtmp : rk(Oo :: Bp :: Cp :: N :: T :: nil) <= 3) by (solve_hyps_max HOoBpCpNTeq HOoBpCpNTM3).
	try assert(HOoABpCpNTeq : rk(Oo :: A :: Bp :: Cp :: N :: T :: nil) = 4) by (apply LOoABpCpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpNTmtmp : rk(Oo :: A :: Bp :: Cp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABpCpNTeq HOoABpCpNTm4).
	try assert(HOoCpNeq : rk(Oo :: Cp :: N :: nil) = 3) by (apply LOoCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpNmtmp : rk(Oo :: Cp :: N :: nil) >= 3) by (solve_hyps_min HOoCpNeq HOoCpNm3).
	assert(Hincl : incl (Oo :: Cp :: N :: nil) (list_inter (Oo :: A :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: N :: T :: nil) (Oo :: A :: Cp :: N :: Oo :: Bp :: Cp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: N :: Oo :: Bp :: Cp :: N :: T :: nil) ((Oo :: A :: Cp :: N :: nil) ++ (Oo :: Bp :: Cp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpNTmtmp;try rewrite HT2 in HOoABpCpNTmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: T :: nil) (Oo :: Cp :: N :: nil) 4 3 3 HOoABpCpNTmtmp HOoCpNmtmp HOoBpCpNTMtmp Hincl);apply HT.
}


assert(HOoACpNM : rk(Oo :: A :: Cp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpNm : rk(Oo :: A :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HOoACpNeq HOoACpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCpN *)
(* dans la couche 0 *)
Lemma LOoBBpCpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: Cp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpNT requis par la preuve de (?)OoBBpCpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpNT requis par la preuve de (?)OoBBpCpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpNT requis par la preuve de (?)OoBBpCpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNTm2 : rk(Oo :: B :: Bp :: Cp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNTm3 : rk(Oo :: B :: Bp :: Cp :: N :: T :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: T :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNTm4 : rk(Oo :: B :: Bp :: Cp :: N :: T :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: N :: T :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBBpCpNTM : rk(Oo :: B :: Bp :: Cp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpNTm : rk(Oo :: B :: Bp :: Cp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBBpCpNTeq HOoBBpCpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpN requis par la preuve de (?)BCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpN requis par la preuve de (?)BCpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm2 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm3 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCpN requis par la preuve de (?)BCpN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: N ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpNm2 : rk(B :: Cp :: N :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpNmtmp : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HOoABCpNeq HOoABCpNm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: N :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpNmtmp;try rewrite HT2 in HOoABCpNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: N :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpNmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCpNm3 : rk(B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoBpCpNTeq : rk(Oo :: Bp :: Cp :: N :: T :: nil) = 3) by (apply LOoBpCpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpNTMtmp : rk(Oo :: Bp :: Cp :: N :: T :: nil) <= 3) by (solve_hyps_max HOoBpCpNTeq HOoBpCpNTM3).
	try assert(HOoBBpCpNTeq : rk(Oo :: B :: Bp :: Cp :: N :: T :: nil) = 4) by (apply LOoBBpCpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpNTmtmp : rk(Oo :: B :: Bp :: Cp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBBpCpNTeq HOoBBpCpNTm4).
	try assert(HCpNeq : rk(Cp :: N :: nil) = 2) by (apply LCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpNmtmp : rk(Cp :: N :: nil) >= 2) by (solve_hyps_min HCpNeq HCpNm2).
	assert(Hincl : incl (Cp :: N :: nil) (list_inter (B :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: T :: nil) (B :: Cp :: N :: Oo :: Bp :: Cp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: N :: Oo :: Bp :: Cp :: N :: T :: nil) ((B :: Cp :: N :: nil) ++ (Oo :: Bp :: Cp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNTmtmp;try rewrite HT2 in HOoBBpCpNTmtmp.
	assert(HT := rule_2 (B :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: T :: nil) (Cp :: N :: nil) 4 2 3 HOoBBpCpNTmtmp HCpNmtmp HOoBpCpNTMtmp Hincl);apply HT.
}


assert(HBCpNM : rk(B :: Cp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCpNeq HBCpNM3).
assert(HBCpNm : rk(B :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HBCpNeq HBCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCpN *)
(* dans la couche 0 *)
Lemma LOoABCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpNV requis par la preuve de (?)OoABCpNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpNV requis par la preuve de (?)OoABCpNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpNV requis par la preuve de (?)OoABCpNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNVm2 : rk(Oo :: A :: B :: Cp :: N :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNVm3 : rk(Oo :: A :: B :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNVm4 : rk(Oo :: A :: B :: Cp :: N :: V :: nil) >= 4).
{
	try assert(HOoACpNeq : rk(Oo :: A :: Cp :: N :: nil) = 4) by (apply LOoACpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpNmtmp : rk(Oo :: A :: Cp :: N :: nil) >= 4) by (solve_hyps_min HOoACpNeq HOoACpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: N :: V :: nil) 4 4 HOoACpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCpNVM : rk(Oo :: A :: B :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpNVm : rk(Oo :: A :: B :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoABCpNVeq HOoABCpNVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCpN *)
(* dans la couche 0 *)
Lemma LOoABNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABNV requis par la preuve de (?)OoABNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABNV requis par la preuve de (?)OoABNV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABNV requis par la preuve de (?)OoABNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNVm2 : rk(Oo :: A :: B :: N :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABNVM3 : rk(Oo :: A :: B :: N :: V :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: V :: nil) (Oo :: A :: B :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: N :: V :: nil) ((Oo :: A :: B :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: N :: V :: nil) (B :: nil) 2 2 1 HOoABMtmp HBNVMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNVm3 : rk(Oo :: A :: B :: N :: V :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: V :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


assert(HOoABNVM : rk(Oo :: A :: B :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABNVm : rk(Oo :: A :: B :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoABNVeq HOoABNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCpN requis par la preuve de (?)ABCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpN requis par la preuve de (?)ABCpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm2 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm3 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpN requis par la preuve de (?)ABCpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpN requis par la preuve de (?)ABCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpNm2 : rk(A :: B :: Cp :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: N ::  de rang :  3 et 4 	 AiB : A :: B :: Cp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HABCpNm3 : rk(A :: B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpNmtmp : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HOoABCpNeq HOoABCpNm3).
	try assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: B :: Cp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: A :: B :: Cp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: B :: Cp :: N :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: B :: Cp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpNmtmp;try rewrite HT2 in HOoABCpNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: B :: Cp :: N :: nil) (A :: B :: Cp :: nil) 3 3 3 HOoABCpNmtmp HABCpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCpNm4 : rk(A :: B :: Cp :: N :: nil) >= 4).
{
	try assert(HOoABNVeq : rk(Oo :: A :: B :: N :: V :: nil) = 3) by (apply LOoABNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNVMtmp : rk(Oo :: A :: B :: N :: V :: nil) <= 3) by (solve_hyps_max HOoABNVeq HOoABNVM3).
	try assert(HOoABCpNVeq : rk(Oo :: A :: B :: Cp :: N :: V :: nil) = 4) by (apply LOoABCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpNVmtmp : rk(Oo :: A :: B :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoABCpNVeq HOoABCpNVm4).
	try assert(HABNeq : rk(A :: B :: N :: nil) = 3) by (apply LABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABNmtmp : rk(A :: B :: N :: nil) >= 3) by (solve_hyps_min HABNeq HABNm3).
	assert(Hincl : incl (A :: B :: N :: nil) (list_inter (A :: B :: Cp :: N :: nil) (Oo :: A :: B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: N :: V :: nil) (A :: B :: Cp :: N :: Oo :: A :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: N :: Oo :: A :: B :: N :: V :: nil) ((A :: B :: Cp :: N :: nil) ++ (Oo :: A :: B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpNVmtmp;try rewrite HT2 in HOoABCpNVmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: N :: nil) (Oo :: A :: B :: N :: V :: nil) (A :: B :: N :: nil) 4 3 3 HOoABCpNVmtmp HABNmtmp HOoABNVMtmp Hincl);apply HT.
}


assert(HABCpNM : rk(A :: B :: Cp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpNm : rk(A :: B :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HABCpNeq HABCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpCpN *)
(* dans la couche 0 *)
Lemma LBBpCpNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: Cp :: N :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpNV requis par la preuve de (?)BBpCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpNV requis par la preuve de (?)BBpCpNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpNV requis par la preuve de (?)BBpCpNV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HBBpCpNVm2 : rk(B :: Bp :: Cp :: N :: V :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (B :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: B :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: B :: Bp :: Cp :: N :: V :: nil) ((Oo :: Ap :: nil) ++ (B :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (B :: Bp :: Cp :: N :: V :: nil) (nil) 4 0 2 HOoBApBpCpNVmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBBpCpNVm3 : rk(B :: Bp :: Cp :: N :: V :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBApBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNVeq HOoBApBpCpNVm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: V :: nil) (Oo :: Ap :: Bp :: B :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Bp :: Cp :: N :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNVmtmp;try rewrite HT2 in HOoBApBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Bp :: Cp :: N :: V :: nil) (Bp :: nil) 4 1 2 HOoBApBpCpNVmtmp HBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: N :: V ::  de rang :  4 et 4 	 AiB : Bp :: Cp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpCpNVm4 : rk(B :: Bp :: Cp :: N :: V :: nil) >= 4).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoBBpCpNVeq : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LOoBBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpNVmtmp : rk(Oo :: B :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HOoBBpCpNVeq HOoBBpCpNVm4).
	try assert(HBpCpeq : rk(Bp :: Cp :: nil) = 2) by (apply LBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpmtmp : rk(Bp :: Cp :: nil) >= 2) by (solve_hyps_min HBpCpeq HBpCpm2).
	assert(Hincl : incl (Bp :: Cp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: V :: nil) (Oo :: Bp :: Cp :: B :: Bp :: Cp :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: Cp :: N :: V :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: Cp :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNVmtmp;try rewrite HT2 in HOoBBpCpNVmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: N :: V :: nil) (Bp :: Cp :: nil) 4 2 2 HOoBBpCpNVmtmp HBpCpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HBBpCpNVM : rk(B :: Bp :: Cp :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpNVm : rk(B :: Bp :: Cp :: N :: V ::  nil) >= 1) by (solve_hyps_min HBBpCpNVeq HBBpCpNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpCpN requis par la preuve de (?)BpCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpCpN requis par la preuve de (?)BpCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpCpNm2 : rk(Bp :: Cp :: N :: nil) >= 2).
{
	try assert(HBpCpeq : rk(Bp :: Cp :: nil) = 2) by (apply LBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpmtmp : rk(Bp :: Cp :: nil) >= 2) by (solve_hyps_min HBpCpeq HBpCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Cp :: nil) (Bp :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Cp :: nil) (Bp :: Cp :: N :: nil) 2 2 HBpCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpCpNm3 : rk(Bp :: Cp :: N :: nil) >= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBBpCpNVeq : rk(B :: Bp :: Cp :: N :: V :: nil) = 4) by (apply LBBpCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpCpNVmtmp : rk(B :: Bp :: Cp :: N :: V :: nil) >= 4) by (solve_hyps_min HBBpCpNVeq HBBpCpNVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: Cp :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: N :: V :: nil) (Bp :: Cp :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: N :: B :: N :: V :: nil) ((Bp :: Cp :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpNVmtmp;try rewrite HT2 in HBBpCpNVmtmp.
	assert(HT := rule_2 (Bp :: Cp :: N :: nil) (B :: N :: V :: nil) (N :: nil) 4 1 2 HBBpCpNVmtmp HNmtmp HBNVMtmp Hincl);apply HT.
}


assert(HBpCpNM : rk(Bp :: Cp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpCpNeq HBpCpNM3).
assert(HBpCpNm : rk(Bp :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HBpCpNeq HBpCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpCpN *)
(* dans la couche 0 *)
Lemma LOoABpCpMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpMNSp requis par la preuve de (?)OoABpCpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpMNSp requis par la preuve de (?)OoABpCpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpMNSp requis par la preuve de (?)OoABpCpMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMNSpm2 : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMNSpm3 : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMNSpm4 : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpCpMNSpM : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpMNSpm : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpCpMNSpeq HOoABpCpMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpCpN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCpN requis par la preuve de (?)OoBpCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpCpN requis par la preuve de (?)OoBpCpN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpCpN requis par la preuve de (?)OoBpCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpNm2 : rk(Oo :: Bp :: Cp :: N :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBpCpNM3 : rk(Oo :: Bp :: Cp :: N :: nil) <= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Bp :: Cp :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: N :: nil) ((Oo :: Bp :: Cp :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Bp :: Cp :: nil) (N :: nil) (nil) 2 1 0 HOoBpCpMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpCpNm3 : rk(Oo :: Bp :: Cp :: N :: nil) >= 3).
{
	try assert(HOoABpMNSpeq : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LOoABpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNSpMtmp : rk(Oo :: A :: Bp :: M :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMNSpeq HOoABpMNSpM4).
	try assert(HOoABpCpMNSpeq : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) = 4) by (apply LOoABpCpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpMNSpmtmp : rk(Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoABpCpMNSpeq HOoABpCpMNSpm4).
	try assert(HOoBpNeq : rk(Oo :: Bp :: N :: nil) = 3) by (apply LOoBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpNmtmp : rk(Oo :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoBpNeq HOoBpNm3).
	assert(Hincl : incl (Oo :: Bp :: N :: nil) (list_inter (Oo :: Bp :: Cp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: N :: Sp :: nil) (Oo :: Bp :: Cp :: N :: Oo :: A :: Bp :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: N :: Oo :: A :: Bp :: M :: N :: Sp :: nil) ((Oo :: Bp :: Cp :: N :: nil) ++ (Oo :: A :: Bp :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMNSpmtmp;try rewrite HT2 in HOoABpCpMNSpmtmp.
	assert(HT := rule_2 (Oo :: Bp :: Cp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Sp :: nil) (Oo :: Bp :: N :: nil) 4 3 4 HOoABpCpMNSpmtmp HOoBpNmtmp HOoABpMNSpMtmp Hincl);apply HT.
}


assert(HOoBpCpNM : rk(Oo :: Bp :: Cp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpCpNm : rk(Oo :: Bp :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HOoBpCpNeq HOoBpCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApBpMN *)
(* dans la couche 0 *)
Lemma LAApBpMNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Bp :: M :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpMNSp requis par la preuve de (?)AApBpMNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMNSp requis par la preuve de (?)AApBpMNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMNSp requis par la preuve de (?)OoAApBpMNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMNSp requis par la preuve de (?)OoAApBpMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNSpm2 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNSpm3 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpMNSp requis par la preuve de (?)AApBpMNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpMNSp requis par la preuve de (?)AApBpMNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpMNSpm2 : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: M :: N :: Sp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: N :: Sp ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpMNSpm3 : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpMNSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoAApBpMNSpeq HOoAApBpMNSpm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: N :: Sp :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMNSpmtmp;try rewrite HT2 in HOoAApBpMNSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: N :: Sp :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpMNSpmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: N :: Sp ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HAApBpMNSpm4 : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 4).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	try assert(HOoAApBpMNSpeq : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LOoAApBpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMNSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMNSpeq HOoAApBpMNSpm4).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (A :: Ap :: Bp :: M :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: N :: Sp :: nil) (Oo :: Ap :: Bp :: M :: A :: Ap :: Bp :: M :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: A :: Ap :: Bp :: M :: N :: Sp :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (A :: Ap :: Bp :: M :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMNSpmtmp;try rewrite HT2 in HOoAApBpMNSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (A :: Ap :: Bp :: M :: N :: Sp :: nil) (Ap :: Bp :: M :: nil) 4 3 3 HOoAApBpMNSpmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoAApBpMNSpM1. try clear HOoAApBpMNSpM2. try clear HOoAApBpMNSpM3. try clear HOoAApBpMNSpm4. try clear HOoAApBpMNSpm3. try clear HOoAApBpMNSpm2. try clear HOoAApBpMNSpm1. 

assert(HAApBpMNSpM : rk(A :: Ap :: Bp :: M :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpMNSpm : rk(A :: Ap :: Bp :: M :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HAApBpMNSpeq HAApBpMNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpMN : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Bp :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpMN requis par la preuve de (?)AApBpMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMN requis par la preuve de (?)AApBpMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMN requis par la preuve de (?)OoAApBpMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMN requis par la preuve de (?)OoAApBpMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNm2 : rk(Oo :: A :: Ap :: Bp :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNm3 : rk(Oo :: A :: Ap :: Bp :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpMN requis par la preuve de (?)AApBpMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpMN requis par la preuve de (?)AApBpMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpMNm2 : rk(A :: Ap :: Bp :: M :: N :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: M :: N :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: N ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpMNm3 : rk(A :: Ap :: Bp :: M :: N :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpMNmtmp : rk(Oo :: A :: Ap :: Bp :: M :: N :: nil) >= 3) by (solve_hyps_min HOoAApBpMNeq HOoAApBpMNm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: N :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMNmtmp;try rewrite HT2 in HOoAApBpMNmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: N :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpMNmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpMNM1. try clear HOoAApBpMNM2. try clear HOoAApBpMNM3. try clear HOoAApBpMNm4. try clear HOoAApBpMNm3. try clear HOoAApBpMNm2. try clear HOoAApBpMNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApBpMNm4 : rk(A :: Ap :: Bp :: M :: N :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HAApBpMNSpeq : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LAApBpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpMNSpmtmp : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HAApBpMNSpeq HAApBpMNSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (A :: Ap :: Bp :: M :: N :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: M :: N :: Sp :: nil) (A :: Ap :: Bp :: M :: N :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: M :: N :: Ap :: M :: Sp :: nil) ((A :: Ap :: Bp :: M :: N :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpMNSpmtmp;try rewrite HT2 in HAApBpMNSpmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: M :: N :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HAApBpMNSpmtmp HApMmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HAApBpMNM : rk(A :: Ap :: Bp :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpMNm : rk(A :: Ap :: Bp :: M :: N ::  nil) >= 1) by (solve_hyps_min HAApBpMNeq HAApBpMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Sp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HSpM : rk(Sp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HSpeq HSpM1).
assert(HSpm : rk(Sp ::  nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoASp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoASp requis par la preuve de (?)OoASp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoASp requis par la preuve de (?)OoASp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoASpm2 : rk(Oo :: A :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoASpm3 : rk(Oo :: A :: Sp :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoAApMSpeq : rk(Oo :: A :: Ap :: M :: Sp :: nil) = 4) by (apply LOoAApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMSpmtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMSpeq HOoAApMSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Oo :: A :: Sp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: Sp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Sp :: Ap :: M :: Sp :: nil) ((Oo :: A :: Sp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMSpmtmp;try rewrite HT2 in HOoAApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Sp :: nil) (Ap :: M :: Sp :: nil) (Sp :: nil) 4 1 2 HOoAApMSpmtmp HSpmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoASpM : rk(Oo :: A :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoASpeq HOoASpM3).
assert(HOoASpm : rk(Oo :: A :: Sp ::  nil) >= 1) by (solve_hyps_min HOoASpeq HOoASpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CSp requis par la preuve de (?)CSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCSpm2 : rk(C :: Sp :: nil) >= 2).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCApMSpeq : rk(C :: Ap :: M :: Sp :: nil) = 3) by (apply LCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpmtmp : rk(C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HCApMSpeq HCApMSpm3).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (C :: Sp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: nil) (C :: Sp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: Ap :: M :: Sp :: nil) ((C :: Sp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMSpmtmp;try rewrite HT2 in HCApMSpmtmp.
	assert(HT := rule_2 (C :: Sp :: nil) (Ap :: M :: Sp :: nil) (Sp :: nil) 3 1 2 HCApMSpmtmp HSpmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HCSpM : rk(C :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCSpeq HCSpM2).
assert(HCSpm : rk(C :: Sp ::  nil) >= 1) by (solve_hyps_min HCSpeq HCSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACSp requis par la preuve de (?)OoACSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACSp requis par la preuve de (?)OoACSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACSp requis par la preuve de (?)OoACSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACSpm2 : rk(Oo :: A :: C :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACSpM3 : rk(Oo :: A :: C :: Sp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpMtmp : rk(Sp :: nil) <= 1) by (solve_hyps_max HSpeq HSpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Sp :: nil) (Oo :: A :: C :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Sp :: nil) (nil) 2 1 0 HOoACMtmp HSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACSpm3 : rk(Oo :: A :: C :: Sp :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Oo :: A :: C :: Sp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: Sp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Sp :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: Sp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Sp :: nil) (Ap :: M :: Sp :: nil) (Sp :: nil) 4 1 2 HOoACApMSpmtmp HSpmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HOoACSpM : rk(Oo :: A :: C :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACSpm : rk(Oo :: A :: C :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACSpeq HOoACSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApSp *)
(* dans constructLemma(), requis par LCApSpT *)
(* dans constructLemma(), requis par LOoCApCpSpT *)
(* dans la couche 0 *)
Lemma LOoCApBpCpSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HOoCApBpCpSpTM : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpSpTm : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpSpTeq HOoCApBpCpSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApCpSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Cp :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpSpT requis par la preuve de (?)OoCApCpSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpSpT requis par la preuve de (?)OoCApCpSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpSpT requis par la preuve de (?)OoCApCpSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpSpTm2 : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpSpTm3 : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoCApCpSpTm4 : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoCApBpCpSpTeq : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T :: nil) = 4) by (apply LOoCApBpCpSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpSpTmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApBpCpSpTeq HOoCApBpCpSpTm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: Sp :: T :: nil) (Oo :: Ap :: Bp :: Oo :: C :: Ap :: Cp :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: C :: Ap :: Cp :: Sp :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Cp :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpSpTmtmp;try rewrite HT2 in HOoCApBpCpSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) (Oo :: Ap :: nil) 4 2 2 HOoCApBpCpSpTmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoCApBpCpSpTM1. try clear HOoCApBpCpSpTM2. try clear HOoCApBpCpSpTM3. try clear HOoCApBpCpSpTm4. try clear HOoCApBpCpSpTm3. try clear HOoCApBpCpSpTm2. try clear HOoCApBpCpSpTm1. 

assert(HOoCApCpSpTM : rk(Oo :: C :: Ap :: Cp :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpSpTm : rk(Oo :: C :: Ap :: Cp :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoCApCpSpTeq HOoCApCpSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApSpT requis par la preuve de (?)CApSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApSpT requis par la preuve de (?)CApSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CSpT requis par la preuve de (?)CApSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApSpT requis par la preuve de (?)CApSpT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HCApSpTM3 : rk(C :: Ap :: Sp :: T :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Sp :: T :: nil) (Ap :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: C :: Sp :: T :: nil) ((Ap :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (C :: Sp :: T :: nil) (nil) 1 2 0 HApMtmp HCSpTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApSpTm2 : rk(C :: Ap :: Sp :: T :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: nil) (C :: Ap :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: nil) (C :: Ap :: Sp :: T :: nil) 2 2 HCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HCApSpTm3 : rk(C :: Ap :: Sp :: T :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoCApCpSpTeq : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) = 4) by (apply LOoCApCpSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApCpSpTmtmp : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApCpSpTeq HOoCApCpSpTm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (C :: Ap :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) (Oo :: Ap :: Cp :: C :: Ap :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: C :: Ap :: Sp :: T :: nil) ((Oo :: Ap :: Cp :: nil) ++ (C :: Ap :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpSpTmtmp;try rewrite HT2 in HOoCApCpSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (C :: Ap :: Sp :: T :: nil) (Ap :: nil) 4 1 2 HOoCApCpSpTmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HCApSpTM : rk(C :: Ap :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApSpTm : rk(C :: Ap :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCApSpTeq HCApSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApSp *)
(* dans la couche 0 *)
Lemma LCSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Sp :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HCSpTM : rk(C :: Sp :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCSpTeq HCSpTM3).
assert(HCSpTm : rk(C :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCSpTeq HCSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApSp requis par la preuve de (?)ApSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApSpm2 : rk(Ap :: Sp :: nil) >= 2).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HCApSpTeq : rk(C :: Ap :: Sp :: T :: nil) = 3) by (apply LCApSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApSpTmtmp : rk(C :: Ap :: Sp :: T :: nil) >= 3) by (solve_hyps_min HCApSpTeq HCApSpTm3).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Ap :: Sp :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Sp :: T :: nil) (Ap :: Sp :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Sp :: C :: Sp :: T :: nil) ((Ap :: Sp :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApSpTmtmp;try rewrite HT2 in HCApSpTmtmp.
	assert(HT := rule_2 (Ap :: Sp :: nil) (C :: Sp :: T :: nil) (Sp :: nil) 3 1 2 HCApSpTmtmp HSpmtmp HCSpTMtmp Hincl);apply HT.
}


assert(HApSpM : rk(Ap :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApSpeq HApSpM2).
assert(HApSpm : rk(Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HApSpeq HApSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApSp requis par la preuve de (?)OoACApSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApSp requis par la preuve de (?)OoACApSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpm2 : rk(Oo :: A :: C :: Ap :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpm3 : rk(Oo :: A :: C :: Ap :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Sp ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApSpm2 : rk(C :: Ap :: Sp :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApSpmtmp : rk(Oo :: A :: C :: Ap :: Sp :: nil) >= 3) by (solve_hyps_min HOoACApSpeq HOoACApSpm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Sp :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApSpmtmp;try rewrite HT2 in HOoACApSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: nil) (C :: Ap :: nil) 3 2 3 HOoACApSpmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApSpM1. try clear HOoACApSpM2. try clear HOoACApSpM3. try clear HOoACApSpm4. try clear HOoACApSpm3. try clear HOoACApSpm2. try clear HOoACApSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApSpm3 : rk(C :: Ap :: Sp :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCApMSpeq : rk(C :: Ap :: M :: Sp :: nil) = 3) by (apply LCApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpmtmp : rk(C :: Ap :: M :: Sp :: nil) >= 3) by (solve_hyps_min HCApMSpeq HCApMSpm3).
	try assert(HApSpeq : rk(Ap :: Sp :: nil) = 2) by (apply LApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApSpmtmp : rk(Ap :: Sp :: nil) >= 2) by (solve_hyps_min HApSpeq HApSpm2).
	assert(Hincl : incl (Ap :: Sp :: nil) (list_inter (C :: Ap :: Sp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: nil) (C :: Ap :: Sp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Sp :: Ap :: M :: Sp :: nil) ((C :: Ap :: Sp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMSpmtmp;try rewrite HT2 in HCApMSpmtmp.
	assert(HT := rule_2 (C :: Ap :: Sp :: nil) (Ap :: M :: Sp :: nil) (Ap :: Sp :: nil) 3 2 2 HCApMSpmtmp HApSpmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HCApSpM : rk(C :: Ap :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApSpeq HCApSpM3).
assert(HCApSpm : rk(C :: Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HCApSpeq HCApSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCCpSp *)
(* dans constructLemma(), requis par LCApCpMSp *)
(* dans la couche 0 *)
Lemma LOoCApCpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Cp :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpMSp requis par la preuve de (?)OoCApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpMSp requis par la preuve de (?)OoCApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpMSp requis par la preuve de (?)OoCApCpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMSpm2 : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMSpm3 : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMSpm4 : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApCpMSpM : rk(Oo :: C :: Ap :: Cp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpMSpm : rk(Oo :: C :: Ap :: Cp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApCpMSpeq HOoCApCpMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApCpMSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Cp :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApCpMSp requis par la preuve de (?)CApCpMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpMSp requis par la preuve de (?)CApCpMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpMSp requis par la preuve de (?)OoCApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpMSp requis par la preuve de (?)OoCApCpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMSpm2 : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMSpm3 : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApCpMSp requis par la preuve de (?)CApCpMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApCpMSp requis par la preuve de (?)CApCpMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCpMSp requis par la preuve de (?)OoACApCpMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCpMSp requis par la preuve de (?)OoACApCpMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpMSpm2 : rk(Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpMSpm3 : rk(Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApCpMSp requis par la preuve de (?)CApCpMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M :: Sp ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApCpMSpm2 : rk(C :: Ap :: Cp :: M :: Sp :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApCpMSpmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoACApCpMSpeq HOoACApCpMSpm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Cp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: Sp :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Cp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Cp :: M :: Sp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Cp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMSpmtmp;try rewrite HT2 in HOoACApCpMSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Cp :: M :: Sp :: nil) (C :: Ap :: nil) 3 2 3 HOoACApCpMSpmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApCpMSpM1. try clear HOoACApCpMSpM2. try clear HOoACApCpMSpM3. try clear HOoACApCpMSpm4. try clear HOoACApCpMSpm3. try clear HOoACApCpMSpm2. try clear HOoACApCpMSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: M :: Sp ::  de rang :  3 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HCApCpMSpm3 : rk(C :: Ap :: Cp :: M :: Sp :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	assert(HOoCApCpMSpmtmp : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 3) by (solve_hyps_min HOoCApCpMSpeq HOoCApCpMSpm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (C :: Ap :: Cp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) (Oo :: Ap :: Cp :: C :: Ap :: Cp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: C :: Ap :: Cp :: M :: Sp :: nil) ((Oo :: Ap :: Cp :: nil) ++ (C :: Ap :: Cp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpMSpmtmp;try rewrite HT2 in HOoCApCpMSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (C :: Ap :: Cp :: M :: Sp :: nil) (Ap :: Cp :: nil) 3 2 2 HOoCApCpMSpmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: M :: Sp ::  de rang :  4 et 4 	 AiB : Ap :: Cp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Cp :: M ::   de rang : 3 et 3 *)
assert(HCApCpMSpm4 : rk(C :: Ap :: Cp :: M :: Sp :: nil) >= 4).
{
	try assert(HOoApCpMeq : rk(Oo :: Ap :: Cp :: M :: nil) = 3) by (apply LOoApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMMtmp : rk(Oo :: Ap :: Cp :: M :: nil) <= 3) by (solve_hyps_max HOoApCpMeq HOoApCpMM3).
	try assert(HOoCApCpMSpeq : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) = 4) by (apply LOoCApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApCpMSpmtmp : rk(Oo :: C :: Ap :: Cp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApCpMSpeq HOoCApCpMSpm4).
	try assert(HApCpMeq : rk(Ap :: Cp :: M :: nil) = 3) by (apply LApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpMmtmp : rk(Ap :: Cp :: M :: nil) >= 3) by (solve_hyps_min HApCpMeq HApCpMm3).
	assert(Hincl : incl (Ap :: Cp :: M :: nil) (list_inter (Oo :: Ap :: Cp :: M :: nil) (C :: Ap :: Cp :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: M :: Sp :: nil) (Oo :: Ap :: Cp :: M :: C :: Ap :: Cp :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: C :: Ap :: Cp :: M :: Sp :: nil) ((Oo :: Ap :: Cp :: M :: nil) ++ (C :: Ap :: Cp :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpMSpmtmp;try rewrite HT2 in HOoCApCpMSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: M :: nil) (C :: Ap :: Cp :: M :: Sp :: nil) (Ap :: Cp :: M :: nil) 4 3 3 HOoCApCpMSpmtmp HApCpMmtmp HOoApCpMMtmp Hincl); apply HT.
}
try clear HOoCApCpMSpM1. try clear HOoCApCpMSpM2. try clear HOoCApCpMSpM3. try clear HOoCApCpMSpm4. try clear HOoCApCpMSpm3. try clear HOoCApCpMSpm2. try clear HOoCApCpMSpm1. 

assert(HCApCpMSpM : rk(C :: Ap :: Cp :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApCpMSpm : rk(C :: Ap :: Cp :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HCApCpMSpeq HCApCpMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CCpSp requis par la preuve de (?)CCpSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSp requis par la preuve de (?)CCpSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSp requis par la preuve de (?)OoACCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSp requis par la preuve de (?)OoACCpSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpm2 : rk(Oo :: A :: C :: Cp :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpm3 : rk(Oo :: A :: C :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CCpSp requis par la preuve de (?)CCpSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpm2 : rk(C :: Cp :: Sp :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpmtmp : rk(Oo :: A :: C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HOoACCpSpeq HOoACCpSpm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpmtmp;try rewrite HT2 in HOoACCpSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpM1. try clear HOoACCpSpM2. try clear HOoACCpSpM3. try clear HOoACCpSpm4. try clear HOoACCpSpm3. try clear HOoACCpSpm2. try clear HOoACCpSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCCpSpm3 : rk(C :: Cp :: Sp :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCApCpMSpeq : rk(C :: Ap :: Cp :: M :: Sp :: nil) = 4) by (apply LCApCpMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApCpMSpmtmp : rk(C :: Ap :: Cp :: M :: Sp :: nil) >= 4) by (solve_hyps_min HCApCpMSpeq HCApCpMSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (C :: Cp :: Sp :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: M :: Sp :: nil) (C :: Cp :: Sp :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Sp :: Ap :: M :: Sp :: nil) ((C :: Cp :: Sp :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApCpMSpmtmp;try rewrite HT2 in HCApCpMSpmtmp.
	assert(HT := rule_2 (C :: Cp :: Sp :: nil) (Ap :: M :: Sp :: nil) (Sp :: nil) 4 1 2 HCApCpMSpmtmp HSpmtmp HApMSpMtmp Hincl);apply HT.
}


assert(HCCpSpM : rk(C :: Cp :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCCpSpeq HCCpSpM3).
assert(HCCpSpm : rk(C :: Cp :: Sp ::  nil) >= 1) by (solve_hyps_min HCCpSpeq HCCpSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpNSp *)
(* dans constructLemma(), requis par LApBpNSpT *)
(* dans la couche 0 *)
Lemma LApBpMNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HApBpMNSpTM : rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpMNSpTm : rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HApBpMNSpTeq HApBpMNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpNSpT requis par la preuve de (?)ApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpNSpT requis par la preuve de (?)ApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpNSpT requis par la preuve de (?)ApBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNSpTm2 : rk(Ap :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: Sp :: T :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : M ::   de rang : 1 et 1 *)
assert(HApBpNSpTm3 : rk(Ap :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HApBpMNSpTeq : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) = 4) by (apply LApBpMNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNSpTmtmp : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNSpTeq HApBpMNSpTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (Ap :: Bp :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: Sp :: T :: nil) (M :: Ap :: Bp :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Ap :: Bp :: N :: Sp :: T :: nil) ((M :: nil) ++ (Ap :: Bp :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNSpTmtmp;try rewrite HT2 in HApBpMNSpTmtmp.
	assert(HT := rule_4 (M :: nil) (Ap :: Bp :: N :: Sp :: T :: nil) (nil) 4 0 1 HApBpMNSpTmtmp Hmtmp HMMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: Sp ::  de rang :  2 et 2 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HApBpNSpTm4 : rk(Ap :: Bp :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApBpMNSpTeq : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) = 4) by (apply LApBpMNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNSpTmtmp : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNSpTeq HApBpMNSpTm4).
	try assert(HApSpeq : rk(Ap :: Sp :: nil) = 2) by (apply LApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApSpmtmp : rk(Ap :: Sp :: nil) >= 2) by (solve_hyps_min HApSpeq HApSpm2).
	assert(Hincl : incl (Ap :: Sp :: nil) (list_inter (Ap :: M :: Sp :: nil) (Ap :: Bp :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: Sp :: T :: nil) (Ap :: M :: Sp :: Ap :: Bp :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: Ap :: Bp :: N :: Sp :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (Ap :: Bp :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNSpTmtmp;try rewrite HT2 in HApBpMNSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (Ap :: Bp :: N :: Sp :: T :: nil) (Ap :: Sp :: nil) 4 2 2 HApBpMNSpTmtmp HApSpmtmp HApMSpMtmp Hincl); apply HT.
}
try clear HApSpM1. try clear HApSpM2. try clear HApSpM3. try clear HApSpm4. try clear HApSpm3. try clear HApSpm2. try clear HApSpm1. 

assert(HApBpNSpTM : rk(Ap :: Bp :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpNSpTm : rk(Ap :: Bp :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HApBpNSpTeq HApBpNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpNSp : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpNSp requis par la preuve de (?)ApBpNSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpNSp requis par la preuve de (?)ApBpNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpNSp requis par la preuve de (?)ApBpNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNSpm2 : rk(Ap :: Bp :: N :: Sp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: Sp :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: M :: N :: Sp ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : A :: Ap :: Bp :: M :: N ::   de rang : 4 et 4 *)
assert(HApBpNSpm3 : rk(Ap :: Bp :: N :: Sp :: nil) >= 3).
{
	try assert(HAApBpMNeq : rk(A :: Ap :: Bp :: M :: N :: nil) = 4) by (apply LAApBpMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpMNMtmp : rk(A :: Ap :: Bp :: M :: N :: nil) <= 4) by (solve_hyps_max HAApBpMNeq HAApBpMNM4).
	try assert(HAApBpMNSpeq : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) = 4) by (apply LAApBpMNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpMNSpmtmp : rk(A :: Ap :: Bp :: M :: N :: Sp :: nil) >= 4) by (solve_hyps_min HAApBpMNSpeq HAApBpMNSpm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (A :: Ap :: Bp :: M :: N :: nil) (Ap :: Bp :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: M :: N :: Sp :: nil) (A :: Ap :: Bp :: M :: N :: Ap :: Bp :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: M :: N :: Ap :: Bp :: N :: Sp :: nil) ((A :: Ap :: Bp :: M :: N :: nil) ++ (Ap :: Bp :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpMNSpmtmp;try rewrite HT2 in HAApBpMNSpmtmp.
	assert(HT := rule_4 (A :: Ap :: Bp :: M :: N :: nil) (Ap :: Bp :: N :: Sp :: nil) (Ap :: Bp :: N :: nil) 4 3 4 HAApBpMNSpmtmp HApBpNmtmp HAApBpMNMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpNSpm4 : rk(Ap :: Bp :: N :: Sp :: nil) >= 4).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HApBpNSpTeq : rk(Ap :: Bp :: N :: Sp :: T :: nil) = 4) by (apply LApBpNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNSpTmtmp : rk(Ap :: Bp :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpNSpTeq HApBpNSpTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Ap :: Bp :: N :: Sp :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: N :: Sp :: T :: nil) (Ap :: Bp :: N :: Sp :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: N :: Sp :: Bp :: N :: T :: nil) ((Ap :: Bp :: N :: Sp :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpNSpTmtmp;try rewrite HT2 in HApBpNSpTmtmp.
	assert(HT := rule_2 (Ap :: Bp :: N :: Sp :: nil) (Bp :: N :: T :: nil) (Bp :: N :: nil) 4 2 2 HApBpNSpTmtmp HBpNmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HApBpNSpM : rk(Ap :: Bp :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpNSpm : rk(Ap :: Bp :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HApBpNSpeq HApBpNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(T ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HTM : rk(T ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HTeq HTM1).
assert(HTm : rk(T ::  nil) >= 1) by (solve_hyps_min HTeq HTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAT requis par la preuve de (?)OoAT pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAT requis par la preuve de (?)OoAT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoATm2 : rk(Oo :: A :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoATm3 : rk(Oo :: A :: T :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HOoABpNTeq : rk(Oo :: A :: Bp :: N :: T :: nil) = 4) by (apply LOoABpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNTmtmp : rk(Oo :: A :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABpNTeq HOoABpNTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (Oo :: A :: T :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: T :: nil) (Oo :: A :: T :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: T :: Bp :: N :: T :: nil) ((Oo :: A :: T :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNTmtmp;try rewrite HT2 in HOoABpNTmtmp.
	assert(HT := rule_2 (Oo :: A :: T :: nil) (Bp :: N :: T :: nil) (T :: nil) 4 1 2 HOoABpNTmtmp HTmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HOoATM : rk(Oo :: A :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoATeq HOoATM3).
assert(HOoATm : rk(Oo :: A :: T ::  nil) >= 1) by (solve_hyps_min HOoATeq HOoATm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CT requis par la preuve de (?)CT pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCTm2 : rk(C :: T :: nil) >= 2).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HCBpNTeq : rk(C :: Bp :: N :: T :: nil) = 3) by (apply LCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNTmtmp : rk(C :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HCBpNTeq HCBpNTm3).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (C :: T :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: T :: nil) (C :: T :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: T :: Bp :: N :: T :: nil) ((C :: T :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpNTmtmp;try rewrite HT2 in HCBpNTmtmp.
	assert(HT := rule_2 (C :: T :: nil) (Bp :: N :: T :: nil) (T :: nil) 3 1 2 HCBpNTmtmp HTmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HCTM : rk(C :: T ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCTeq HCTM2).
assert(HCTm : rk(C :: T ::  nil) >= 1) by (solve_hyps_min HCTeq HCTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACT *)
(* dans la couche 0 *)
Lemma LOoACApMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm2 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm3 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm4 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApMTM : rk(Oo :: A :: C :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMTm : rk(Oo :: A :: C :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HOoACApMTeq HOoACApMTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACT *)
(* dans la couche 0 *)
Lemma LOoAApMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMT requis par la preuve de (?)OoAApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMT requis par la preuve de (?)OoAApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMT requis par la preuve de (?)OoAApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMTm2 : rk(Oo :: A :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMTm3 : rk(Oo :: A :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMTm4 : rk(Oo :: A :: Ap :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMTM : rk(Oo :: A :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMTm : rk(Oo :: A :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HOoAApMTeq HOoAApMTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACT requis par la preuve de (?)OoACT pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACT requis par la preuve de (?)OoACT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACT requis par la preuve de (?)OoACT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACTm2 : rk(Oo :: A :: C :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACTM3 : rk(Oo :: A :: C :: T :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTMtmp : rk(T :: nil) <= 1) by (solve_hyps_max HTeq HTM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: T :: nil) (Oo :: A :: C :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: T :: nil) ((Oo :: A :: C :: nil) ++ (T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (T :: nil) (nil) 2 1 0 HOoACMtmp HTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACTm3 : rk(Oo :: A :: C :: T :: nil) >= 3).
{
	try assert(HOoAApMTeq : rk(Oo :: A :: Ap :: M :: T :: nil) = 4) by (apply LOoAApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMTMtmp : rk(Oo :: A :: Ap :: M :: T :: nil) <= 4) by (solve_hyps_max HOoAApMTeq HOoAApMTM4).
	try assert(HOoACApMTeq : rk(Oo :: A :: C :: Ap :: M :: T :: nil) = 4) by (apply LOoACApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMTmtmp : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 4) by (solve_hyps_min HOoACApMTeq HOoACApMTm4).
	try assert(HOoATeq : rk(Oo :: A :: T :: nil) = 3) by (apply LOoAT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoATmtmp : rk(Oo :: A :: T :: nil) >= 3) by (solve_hyps_min HOoATeq HOoATm3).
	assert(Hincl : incl (Oo :: A :: T :: nil) (list_inter (Oo :: A :: C :: T :: nil) (Oo :: A :: Ap :: M :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: T :: nil) (Oo :: A :: C :: T :: Oo :: A :: Ap :: M :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: T :: Oo :: A :: Ap :: M :: T :: nil) ((Oo :: A :: C :: T :: nil) ++ (Oo :: A :: Ap :: M :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMTmtmp;try rewrite HT2 in HOoACApMTmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: T :: nil) (Oo :: A :: Ap :: M :: T :: nil) (Oo :: A :: T :: nil) 4 3 4 HOoACApMTmtmp HOoATmtmp HOoAApMTMtmp Hincl);apply HT.
}


assert(HOoACTM : rk(Oo :: A :: C :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACTm : rk(Oo :: A :: C :: T ::  nil) >= 1) by (solve_hyps_min HOoACTeq HOoACTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApT *)
(* dans la couche 0 *)
Lemma LOoCApSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApSpT requis par la preuve de (?)OoCApSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApSpT requis par la preuve de (?)OoCApSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApSpT requis par la preuve de (?)OoCApSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApSpTm2 : rk(Oo :: C :: Ap :: Sp :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Sp :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApSpTm3 : rk(Oo :: C :: Ap :: Sp :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Sp :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoCApSpTm4 : rk(Oo :: C :: Ap :: Sp :: T :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoCApCpSpTeq : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) = 4) by (apply LOoCApCpSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApCpSpTmtmp : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApCpSpTeq HOoCApCpSpTm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) (Oo :: Ap :: Cp :: Oo :: C :: Ap :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: C :: Ap :: Sp :: T :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpSpTmtmp;try rewrite HT2 in HOoCApCpSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Sp :: T :: nil) (Oo :: Ap :: nil) 4 2 2 HOoCApCpSpTmtmp HOoApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoCApSpTM : rk(Oo :: C :: Ap :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApSpTm : rk(Oo :: C :: Ap :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoCApSpTeq HOoCApSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApT requis par la preuve de (?)OoApT pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApT requis par la preuve de (?)OoApT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApTm2 : rk(Oo :: Ap :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApTm3 : rk(Oo :: Ap :: T :: nil) >= 3).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HOoCApSpTeq : rk(Oo :: C :: Ap :: Sp :: T :: nil) = 4) by (apply LOoCApSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApSpTmtmp : rk(Oo :: C :: Ap :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApSpTeq HOoCApSpTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (Oo :: Ap :: T :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Sp :: T :: nil) (Oo :: Ap :: T :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: T :: C :: Sp :: T :: nil) ((Oo :: Ap :: T :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApSpTmtmp;try rewrite HT2 in HOoCApSpTmtmp.
	assert(HT := rule_2 (Oo :: Ap :: T :: nil) (C :: Sp :: T :: nil) (T :: nil) 4 1 2 HOoCApSpTmtmp HTmtmp HCSpTMtmp Hincl);apply HT.
}


assert(HOoApTM : rk(Oo :: Ap :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApTeq HOoApTM3).
assert(HOoApTm : rk(Oo :: Ap :: T ::  nil) >= 1) by (solve_hyps_min HOoApTeq HOoApTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApT *)
(* dans constructLemma(), requis par LCApBpNT *)
(* dans constructLemma(), requis par LOoCApBpNT *)
(* dans constructLemma(), requis par LOoBCApBpNT *)
(* dans la couche 0 *)
Lemma LOoABCApBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApBpNT requis par la preuve de (?)OoABCApBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApBpNT requis par la preuve de (?)OoABCApBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpNT requis par la preuve de (?)OoABCApBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNTm2 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNTm3 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNTm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpNTM : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpNTm : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApBpNTeq HOoABCApBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpNT requis par la preuve de (?)OoBCApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpNT requis par la preuve de (?)OoBCApBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpNT requis par la preuve de (?)OoBCApBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNTm2 : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNTm3 : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApBpNTm4 : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApBpNTeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) = 4) by (apply LOoABCApBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApBpNTmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCApBpNTeq HOoABCApBpNTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpNTmtmp;try rewrite HT2 in HOoABCApBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApBpNTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApBpNTM : rk(Oo :: B :: C :: Ap :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpNTm : rk(Oo :: B :: C :: Ap :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApBpNTeq HOoBCApBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNT requis par la preuve de (?)OoCApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNT requis par la preuve de (?)OoCApBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNT requis par la preuve de (?)OoCApBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTm2 : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTm3 : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoCApBpNTm4 : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	try assert(HOoBCApBpNTeq : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) = 4) by (apply LOoBCApBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApBpNTmtmp : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCApBpNTeq HOoBCApBpNTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: C :: Ap :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: C :: Ap :: Bp :: N :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: C :: Ap :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpNTmtmp;try rewrite HT2 in HOoBCApBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoBCApBpNTmtmp HOoCApNmtmp HOoBCApNMtmp Hincl); apply HT.
}


assert(HOoCApBpNTM : rk(Oo :: C :: Ap :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpNTm : rk(Oo :: C :: Ap :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoCApBpNTeq HOoCApBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpNT requis par la preuve de (?)CApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNT requis par la preuve de (?)CApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNT requis par la preuve de (?)OoCApBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNT requis par la preuve de (?)OoCApBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTm2 : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTm3 : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpNT requis par la preuve de (?)CApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpNT requis par la preuve de (?)CApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpNT requis par la preuve de (?)OoACApBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpNT requis par la preuve de (?)OoACApBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNTm2 : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNTm3 : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpNT requis par la preuve de (?)CApBpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpNTm2 : rk(C :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpNTmtmp : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HOoACApBpNTeq HOoACApBpNTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpNTmtmp;try rewrite HT2 in HOoACApBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpNTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpNTM1. try clear HOoACApBpNTM2. try clear HOoACApBpNTM3. try clear HOoACApBpNTm4. try clear HOoACApBpNTm3. try clear HOoACApBpNTm2. try clear HOoACApBpNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: T ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpNTm3 : rk(C :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpNTmtmp : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 3) by (solve_hyps_min HOoCApBpNTeq HOoCApBpNTm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNTmtmp;try rewrite HT2 in HOoCApBpNTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: T :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpNTmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HCApBpNTm4 : rk(C :: Ap :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	try assert(HOoCApBpNTeq : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) = 4) by (apply LOoCApBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpNTmtmp : rk(Oo :: C :: Ap :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoCApBpNTeq HOoCApBpNTm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: T :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (C :: Ap :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNTmtmp;try rewrite HT2 in HOoCApBpNTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: T :: nil) (Ap :: Bp :: N :: nil) 4 3 3 HOoCApBpNTmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoCApBpNTM1. try clear HOoCApBpNTM2. try clear HOoCApBpNTM3. try clear HOoCApBpNTm4. try clear HOoCApBpNTm3. try clear HOoCApBpNTm2. try clear HOoCApBpNTm1. 

assert(HCApBpNTM : rk(C :: Ap :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpNTm : rk(C :: Ap :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HCApBpNTeq HCApBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApT requis par la preuve de (?)CApT pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApT requis par la preuve de (?)CApT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApT requis par la preuve de (?)OoACApT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApT requis par la preuve de (?)OoACApT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTm2 : rk(Oo :: A :: C :: Ap :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTm3 : rk(Oo :: A :: C :: Ap :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApT requis par la preuve de (?)CApT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApTm2 : rk(C :: Ap :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApTmtmp : rk(Oo :: A :: C :: Ap :: T :: nil) >= 3) by (solve_hyps_min HOoACApTeq HOoACApTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApTmtmp;try rewrite HT2 in HOoACApTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApTM1. try clear HOoACApTM2. try clear HOoACApTM3. try clear HOoACApTm4. try clear HOoACApTm3. try clear HOoACApTm2. try clear HOoACApTm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApTm3 : rk(C :: Ap :: T :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HCApBpNTeq : rk(C :: Ap :: Bp :: N :: T :: nil) = 4) by (apply LCApBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpNTmtmp : rk(C :: Ap :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HCApBpNTeq HCApBpNTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (C :: Ap :: T :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: N :: T :: nil) (C :: Ap :: T :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: T :: Bp :: N :: T :: nil) ((C :: Ap :: T :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpNTmtmp;try rewrite HT2 in HCApBpNTmtmp.
	assert(HT := rule_2 (C :: Ap :: T :: nil) (Bp :: N :: T :: nil) (T :: nil) 4 1 2 HCApBpNTmtmp HTmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HCApTM : rk(C :: Ap :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApTeq HCApTM3).
assert(HCApTm : rk(C :: Ap :: T ::  nil) >= 1) by (solve_hyps_min HCApTeq HCApTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpT *)
(* dans la couche 0 *)
Lemma LOoAApBpMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: M :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMT requis par la preuve de (?)OoAApBpMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMT requis par la preuve de (?)OoAApBpMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMT requis par la preuve de (?)OoAApBpMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMTm2 : rk(Oo :: A :: Ap :: Bp :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMTm3 : rk(Oo :: A :: Ap :: Bp :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMTm4 : rk(Oo :: A :: Ap :: Bp :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpMTM : rk(Oo :: A :: Ap :: Bp :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpMTm : rk(Oo :: A :: Ap :: Bp :: M :: T ::  nil) >= 1) by (solve_hyps_min HOoAApBpMTeq HOoAApBpMTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpT requis par la preuve de (?)OoApBpT pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpT requis par la preuve de (?)OoApBpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpT requis par la preuve de (?)OoApBpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpTm2 : rk(Oo :: Ap :: Bp :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpTM3 : rk(Oo :: Ap :: Bp :: T :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTMtmp : rk(T :: nil) <= 1) by (solve_hyps_max HTeq HTM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: T :: nil) (Oo :: Ap :: Bp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (T :: nil) (nil) 2 1 0 HOoApBpMtmp HTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpTm3 : rk(Oo :: Ap :: Bp :: T :: nil) >= 3).
{
	try assert(HOoAApMTeq : rk(Oo :: A :: Ap :: M :: T :: nil) = 4) by (apply LOoAApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMTMtmp : rk(Oo :: A :: Ap :: M :: T :: nil) <= 4) by (solve_hyps_max HOoAApMTeq HOoAApMTM4).
	try assert(HOoAApBpMTeq : rk(Oo :: A :: Ap :: Bp :: M :: T :: nil) = 4) by (apply LOoAApBpMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMTmtmp : rk(Oo :: A :: Ap :: Bp :: M :: T :: nil) >= 4) by (solve_hyps_min HOoAApBpMTeq HOoAApBpMTm4).
	try assert(HOoApTeq : rk(Oo :: Ap :: T :: nil) = 3) by (apply LOoApT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApTmtmp : rk(Oo :: Ap :: T :: nil) >= 3) by (solve_hyps_min HOoApTeq HOoApTm3).
	assert(Hincl : incl (Oo :: Ap :: T :: nil) (list_inter (Oo :: Ap :: Bp :: T :: nil) (Oo :: A :: Ap :: M :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: T :: nil) (Oo :: Ap :: Bp :: T :: Oo :: A :: Ap :: M :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: T :: Oo :: A :: Ap :: M :: T :: nil) ((Oo :: Ap :: Bp :: T :: nil) ++ (Oo :: A :: Ap :: M :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMTmtmp;try rewrite HT2 in HOoAApBpMTmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: T :: nil) (Oo :: A :: Ap :: M :: T :: nil) (Oo :: Ap :: T :: nil) 4 3 4 HOoAApBpMTmtmp HOoApTmtmp HOoAApMTMtmp Hincl);apply HT.
}


assert(HOoApBpTM : rk(Oo :: Ap :: Bp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpTm : rk(Oo :: Ap :: Bp :: T ::  nil) >= 1) by (solve_hyps_min HOoApBpTeq HOoApBpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMT *)
(* dans la couche 0 *)
Lemma LBpMNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: M :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpMNT requis par la preuve de (?)BpMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)BpMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)OoABBpMNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)OoABBpMNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)OoABBpMNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNTm2 : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNTm3 : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNTm4 : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpMNT requis par la preuve de (?)BpMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpMNT requis par la preuve de (?)BpMNT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpMNTM3 : rk(Bp :: M :: N :: T :: nil) <= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: M :: N :: T :: nil) (M :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Bp :: N :: T :: nil) ((M :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (M :: nil) (Bp :: N :: T :: nil) (nil) 1 2 0 HMMtmp HBpNTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: M :: N :: T ::  de rang :  4 et 4 	 AiB : Bp :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: M ::   de rang : 4 et 4 *)
assert(HBpMNTm2 : rk(Bp :: M :: N :: T :: nil) >= 2).
{
	try assert(HOoABBpMeq : rk(Oo :: A :: B :: Bp :: M :: nil) = 4) by (apply LOoABBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMMtmp : rk(Oo :: A :: B :: Bp :: M :: nil) <= 4) by (solve_hyps_max HOoABBpMeq HOoABBpMM4).
	assert(HOoABBpMNTmtmp : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABBpMNTeq HOoABBpMNTm4).
	try assert(HBpMeq : rk(Bp :: M :: nil) = 2) by (apply LBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMmtmp : rk(Bp :: M :: nil) >= 2) by (solve_hyps_min HBpMeq HBpMm2).
	assert(Hincl : incl (Bp :: M :: nil) (list_inter (Oo :: A :: B :: Bp :: M :: nil) (Bp :: M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: N :: T :: nil) (Oo :: A :: B :: Bp :: M :: Bp :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: M :: Bp :: M :: N :: T :: nil) ((Oo :: A :: B :: Bp :: M :: nil) ++ (Bp :: M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMNTmtmp;try rewrite HT2 in HOoABBpMNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: M :: nil) (Bp :: M :: N :: T :: nil) (Bp :: M :: nil) 4 2 4 HOoABBpMNTmtmp HBpMmtmp HOoABBpMMtmp Hincl); apply HT.
}
try clear HBpMM1. try clear HBpMM2. try clear HBpMM3. try clear HBpMm4. try clear HBpMm3. try clear HBpMm2. try clear HBpMm1. try clear HOoABBpMNTM1. try clear HOoABBpMNTM2. try clear HOoABBpMNTM3. try clear HOoABBpMNTm4. try clear HOoABBpMNTm3. try clear HOoABBpMNTm2. try clear HOoABBpMNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HBpMNTm3 : rk(Bp :: M :: N :: T :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApBpMNSpTeq : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) = 4) by (apply LApBpMNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNSpTmtmp : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNSpTeq HApBpMNSpTm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: Sp :: nil) (Bp :: M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: Sp :: T :: nil) (Ap :: M :: Sp :: Bp :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: Bp :: M :: N :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (Bp :: M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNSpTmtmp;try rewrite HT2 in HApBpMNSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (Bp :: M :: N :: T :: nil) (M :: nil) 4 1 2 HApBpMNSpTmtmp HMmtmp HApMSpMtmp Hincl); apply HT.
}


assert(HBpMNTM : rk(Bp :: M :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpMNTm : rk(Bp :: M :: N :: T ::  nil) >= 1) by (solve_hyps_min HBpMNTeq HBpMNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MT requis par la preuve de (?)MT pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HMTm2 : rk(M :: T :: nil) >= 2).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HBpMNTeq : rk(Bp :: M :: N :: T :: nil) = 3) by (apply LBpMNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMNTmtmp : rk(Bp :: M :: N :: T :: nil) >= 3) by (solve_hyps_min HBpMNTeq HBpMNTm3).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (M :: T :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: M :: N :: T :: nil) (M :: T :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: T :: Bp :: N :: T :: nil) ((M :: T :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpMNTmtmp;try rewrite HT2 in HBpMNTmtmp.
	assert(HT := rule_2 (M :: T :: nil) (Bp :: N :: T :: nil) (T :: nil) 3 1 2 HBpMNTmtmp HTmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HMTM : rk(M :: T ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HMTeq HMTM2).
assert(HMTm : rk(M :: T ::  nil) >= 1) by (solve_hyps_min HMTeq HMTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApMT *)
(* dans la couche 0 *)
Lemma LApBpMNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: M :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpMNT requis par la preuve de (?)ApBpMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApBpMNT requis par la preuve de (?)ApBpMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpMNT requis par la preuve de (?)OoApBpMNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpMNT requis par la preuve de (?)OoApBpMNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMNTm2 : rk(Oo :: Ap :: Bp :: M :: N :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: N :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMNTm3 : rk(Oo :: Ap :: Bp :: M :: N :: T :: nil) >= 3).
{
	try assert(HOoApMeq : rk(Oo :: Ap :: M :: nil) = 3) by (apply LOoApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMmtmp : rk(Oo :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoApMeq HOoApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: N :: T :: nil) 3 3 HOoApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpMNT requis par la preuve de (?)ApBpMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpMNT requis par la preuve de (?)ApBpMNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpMNTm2 : rk(Ap :: Bp :: M :: N :: T :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: M :: N :: T :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: M :: N :: T ::  de rang :  3 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HApBpMNTm3 : rk(Ap :: Bp :: M :: N :: T :: nil) >= 3).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	assert(HOoApBpMNTmtmp : rk(Oo :: Ap :: Bp :: M :: N :: T :: nil) >= 3) by (solve_hyps_min HOoApBpMNTeq HOoApBpMNTm3).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (Ap :: Bp :: M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: N :: T :: nil) (Oo :: Ap :: Bp :: M :: Ap :: Bp :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: Ap :: Bp :: M :: N :: T :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (Ap :: Bp :: M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpMNTmtmp;try rewrite HT2 in HOoApBpMNTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (Ap :: Bp :: M :: N :: T :: nil) (Ap :: Bp :: M :: nil) 3 3 3 HOoApBpMNTmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoApBpMNTM1. try clear HOoApBpMNTM2. try clear HOoApBpMNTM3. try clear HOoApBpMNTm4. try clear HOoApBpMNTm3. try clear HOoApBpMNTm2. try clear HOoApBpMNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HApBpMNTm4 : rk(Ap :: Bp :: M :: N :: T :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApBpMNSpTeq : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) = 4) by (apply LApBpMNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNSpTmtmp : rk(Ap :: Bp :: M :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNSpTeq HApBpMNSpTm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Ap :: M :: Sp :: nil) (Ap :: Bp :: M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: Sp :: T :: nil) (Ap :: M :: Sp :: Ap :: Bp :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: Ap :: Bp :: M :: N :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (Ap :: Bp :: M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNSpTmtmp;try rewrite HT2 in HApBpMNSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (Ap :: Bp :: M :: N :: T :: nil) (Ap :: M :: nil) 4 2 2 HApBpMNSpTmtmp HApMmtmp HApMSpMtmp Hincl); apply HT.
}


assert(HApBpMNTM : rk(Ap :: Bp :: M :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpMNTm : rk(Ap :: Bp :: M :: N :: T ::  nil) >= 1) by (solve_hyps_min HApBpMNTeq HApBpMNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMT requis par la preuve de (?)ApMT pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMT requis par la preuve de (?)ApMT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMT requis par la preuve de (?)OoABApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMT requis par la preuve de (?)OoABApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMT requis par la preuve de (?)OoABApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMTm2 : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMTm3 : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMTm4 : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApMT requis par la preuve de (?)ApMT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: T ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMTm2 : rk(Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMTmtmp : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 4) by (solve_hyps_min HOoABApMTeq HOoABApMTm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: T :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: T :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMTmtmp;try rewrite HT2 in HOoABApMTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: T :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMTmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMTM1. try clear HOoABApMTM2. try clear HOoABApMTM3. try clear HOoABApMTm4. try clear HOoABApMTm3. try clear HOoABApMTm2. try clear HOoABApMTm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApMTm3 : rk(Ap :: M :: T :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HApBpMNTeq : rk(Ap :: Bp :: M :: N :: T :: nil) = 4) by (apply LApBpMNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNTmtmp : rk(Ap :: Bp :: M :: N :: T :: nil) >= 4) by (solve_hyps_min HApBpMNTeq HApBpMNTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (Ap :: M :: T :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: T :: nil) (Ap :: M :: T :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: T :: Bp :: N :: T :: nil) ((Ap :: M :: T :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNTmtmp;try rewrite HT2 in HApBpMNTmtmp.
	assert(HT := rule_2 (Ap :: M :: T :: nil) (Bp :: N :: T :: nil) (T :: nil) 4 1 2 HApBpMNTmtmp HTmtmp HBpNTMtmp Hincl);apply HT.
}


assert(HApMTM : rk(Ap :: M :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMTeq HApMTM3).
assert(HApMTm : rk(Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HApMTeq HApMTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMT requis par la preuve de (?)OoABApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMT requis par la preuve de (?)OoABApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMT requis par la preuve de (?)OoABApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMTm2 : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMTm3 : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMTm4 : rk(Oo :: A :: B :: Ap :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMTM : rk(Oo :: A :: B :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMTm : rk(Oo :: A :: B :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HOoABApMTeq HOoABApMTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApMT *)
(* dans la couche 0 *)
Lemma LCApMSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMSpT requis par la preuve de (?)CApMSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMSpT requis par la preuve de (?)CApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMSpT requis par la preuve de (?)CApMSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMSpT requis par la preuve de (?)OoACApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMSpT requis par la preuve de (?)OoACApMSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpTm2 : rk(Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpTm3 : rk(Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMSpT requis par la preuve de (?)CApMSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMSpTm2 : rk(C :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMSpTmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) >= 3) by (solve_hyps_min HOoACApMSpTeq HOoACApMSpTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpTmtmp;try rewrite HT2 in HOoACApMSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMSpTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMSpTM1. try clear HOoACApMSpTM2. try clear HOoACApMSpTM3. try clear HOoACApMSpTm4. try clear HOoACApMSpTm3. try clear HOoACApMSpTm2. try clear HOoACApMSpTm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMSpTm3 : rk(C :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: T :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCApMSpTM3 : rk(C :: Ap :: M :: Sp :: T :: nil) <= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Ap :: M :: Sp :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: T :: nil) (Ap :: M :: Sp :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: C :: Sp :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Sp :: nil) (C :: Sp :: T :: nil) (Sp :: nil) 2 2 1 HApMSpMtmp HCSpTMtmp HSpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCApMSpTM : rk(C :: Ap :: M :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMSpTm : rk(C :: Ap :: M :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCApMSpTeq HCApMSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMT requis par la preuve de (?)CApMT pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMT requis par la preuve de (?)CApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMT requis par la preuve de (?)CApMT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm2 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm3 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMT requis par la preuve de (?)CApMT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMTm2 : rk(C :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMTmtmp : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 3) by (solve_hyps_min HOoACApMTeq HOoACApMTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMTmtmp;try rewrite HT2 in HOoACApMTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMTM1. try clear HOoACApMTM2. try clear HOoACApMTM3. try clear HOoACApMTm4. try clear HOoACApMTm3. try clear HOoACApMTm2. try clear HOoACApMTm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMTm3 : rk(C :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: T :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMTM3 : rk(C :: Ap :: M :: T :: nil) <= 3).
{
	try assert(HCApMSpTeq : rk(C :: Ap :: M :: Sp :: T :: nil) = 3) by (apply LCApMSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpTMtmp : rk(C :: Ap :: M :: Sp :: T :: nil) <= 3) by (solve_hyps_max HCApMSpTeq HCApMSpTM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: T :: nil) (C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: M :: T :: nil) (C :: Ap :: M :: Sp :: T :: nil) 3 3 HCApMSpTMtmp Hcomp Hincl);apply HT.
}


assert(HCApMTM : rk(C :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMTm : rk(C :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HCApMTeq HCApMTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApNT *)
(* dans la couche 0 *)
Lemma LOoApBpNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpNT requis par la preuve de (?)OoApBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpNT requis par la preuve de (?)OoApBpNT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpNT requis par la preuve de (?)OoApBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNTm2 : rk(Oo :: Ap :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApBpNTM3 : rk(Oo :: Ap :: Bp :: N :: T :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: T :: nil) (Oo :: Ap :: Bp :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Bp :: N :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (Bp :: N :: T :: nil) (Bp :: nil) 2 2 1 HOoApBpMtmp HBpNTMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: N ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoApBpNTm3 : rk(Oo :: Ap :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	try assert(HOoBCApBpNTeq : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) = 4) by (apply LOoBCApBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApBpNTmtmp : rk(Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCApBpNTeq HOoBCApBpNTm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: N :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: Bp :: N :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: Ap :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpNTmtmp;try rewrite HT2 in HOoBCApBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: Bp :: N :: T :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoBCApBpNTmtmp HOoApNmtmp HOoBCApNMtmp Hincl); apply HT.
}


assert(HOoApBpNTM : rk(Oo :: Ap :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpNTm : rk(Oo :: Ap :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoApBpNTeq HOoApBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApNT requis par la preuve de (?)OoApNT pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoApNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoBCApNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoABCApNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoABCApNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoABCApNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNTm2 : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNTm3 : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNTm4 : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoBCApNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoBCApNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoBCApNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNTm2 : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNTm3 : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApNTm4 : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	assert(HOoABCApNTmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCApNTeq HOoABCApNTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNTmtmp;try rewrite HT2 in HOoABCApNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApNTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}
try clear HOoABCApNTM1. try clear HOoABCApNTM2. try clear HOoABCApNTM3. try clear HOoABCApNTm4. try clear HOoABCApNTm3. try clear HOoABCApNTm2. try clear HOoABCApNTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApNT requis par la preuve de (?)OoApNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApNT requis par la preuve de (?)OoApNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApNTm2 : rk(Oo :: Ap :: N :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: N :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: N ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoApNTm3 : rk(Oo :: Ap :: N :: T :: nil) >= 3).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	assert(HOoBCApNTmtmp : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCApNTeq HOoBCApNTm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: N :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: N :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: Ap :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApNTmtmp;try rewrite HT2 in HOoBCApNTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: N :: T :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoBCApNTmtmp HOoApNmtmp HOoBCApNMtmp Hincl); apply HT.
}
try clear HOoBCApNTM1. try clear HOoBCApNTM2. try clear HOoBCApNTM3. try clear HOoBCApNTm4. try clear HOoBCApNTm3. try clear HOoBCApNTm2. try clear HOoBCApNTm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApNTM3 : rk(Oo :: Ap :: N :: T :: nil) <= 3).
{
	try assert(HOoApBpNTeq : rk(Oo :: Ap :: Bp :: N :: T :: nil) = 3) by (apply LOoApBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNTMtmp : rk(Oo :: Ap :: Bp :: N :: T :: nil) <= 3) by (solve_hyps_max HOoApBpNTeq HOoApBpNTM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: N :: T :: nil) (Oo :: Ap :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: N :: T :: nil) (Oo :: Ap :: Bp :: N :: T :: nil) 3 3 HOoApBpNTMtmp Hcomp Hincl);apply HT.
}


assert(HOoApNTM : rk(Oo :: Ap :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApNTm : rk(Oo :: Ap :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoApNTeq HOoApNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApNT *)
(* dans la couche 0 *)
Lemma LOoABCApNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoABCApNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoABCApNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApNT requis par la preuve de (?)OoABCApNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNTm2 : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNTm3 : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNTm4 : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApNTM : rk(Oo :: A :: B :: C :: Ap :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApNTm : rk(Oo :: A :: B :: C :: Ap :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApNTeq HOoABCApNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoBCApNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoBCApNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNT requis par la preuve de (?)OoBCApNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNTm2 : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNTm3 : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApNTm4 : rk(Oo :: B :: C :: Ap :: N :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApNTeq : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) = 4) by (apply LOoABCApNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApNTmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCApNTeq HOoABCApNTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNTmtmp;try rewrite HT2 in HOoABCApNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApNTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApNTM : rk(Oo :: B :: C :: Ap :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNTm : rk(Oo :: B :: C :: Ap :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApNTeq HOoBCApNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpMNT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: M :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)OoABBpMNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)OoABBpMNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNT requis par la preuve de (?)OoABBpMNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNTm2 : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNTm3 : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNTm4 : rk(Oo :: A :: B :: Bp :: M :: N :: T :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: T :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpMNTM : rk(Oo :: A :: B :: Bp :: M :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpMNTm : rk(Oo :: A :: B :: Bp :: M :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABBpMNTeq HOoABBpMNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LSpT *)
(* dans constructLemma(), requis par LOoApNSpT *)
(* dans la couche 0 *)
Lemma LOoApBpNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApBpNSpT requis par la preuve de (?)OoApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoABCApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoABCApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoABCApBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNSpTm2 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNSpTm3 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNSpTm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNSpTm2 : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNSpTm3 : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApBpNSpTm4 : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	assert(HOoABCApBpNSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApBpNSpTeq HOoABCApBpNSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpNSpTmtmp;try rewrite HT2 in HOoABCApBpNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApBpNSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}
try clear HOoABCApBpNSpTM1. try clear HOoABCApBpNSpTM2. try clear HOoABCApBpNSpTM3. try clear HOoABCApBpNSpTm4. try clear HOoABCApBpNSpTm3. try clear HOoABCApBpNSpTm2. try clear HOoABCApBpNSpTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpNSpT requis par la preuve de (?)OoApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpNSpT requis par la preuve de (?)OoApBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNSpTm2 : rk(Oo :: Ap :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: Sp :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: N ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoApBpNSpTm3 : rk(Oo :: Ap :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	assert(HOoBCApBpNSpTmtmp : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoBCApBpNSpTeq HOoBCApBpNSpTm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: Bp :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: Bp :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: Bp :: N :: Sp :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: Ap :: Bp :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpNSpTmtmp;try rewrite HT2 in HOoBCApBpNSpTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoBCApBpNSpTmtmp HOoApNmtmp HOoBCApNMtmp Hincl); apply HT.
}
try clear HOoBCApBpNSpTM1. try clear HOoBCApBpNSpTM2. try clear HOoBCApBpNSpTM3. try clear HOoBCApBpNSpTm4. try clear HOoBCApBpNSpTm3. try clear HOoBCApBpNSpTm2. try clear HOoBCApBpNSpTm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNSpTm4 : rk(Oo :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HApBpNSpeq : rk(Ap :: Bp :: N :: Sp :: nil) = 4) by (apply LApBpNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNSpmtmp : rk(Ap :: Bp :: N :: Sp :: nil) >= 4) by (solve_hyps_min HApBpNSpeq HApBpNSpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: N :: Sp :: nil) (Oo :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: N :: Sp :: nil) (Oo :: Ap :: Bp :: N :: Sp :: T :: nil) 4 4 HApBpNSpmtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpNSpTM : rk(Oo :: Ap :: Bp :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpNSpTm : rk(Oo :: Ap :: Bp :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoApBpNSpTeq HOoApBpNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApNSpT requis par la preuve de (?)OoApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm2 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm3 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm4 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNSpTm2 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNSpTm3 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApNSpTm4 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	assert(HOoABCApNSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApNSpTeq HOoABCApNSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNSpTmtmp;try rewrite HT2 in HOoABCApNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApNSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}
try clear HOoABCApNSpTM1. try clear HOoABCApNSpTM2. try clear HOoABCApNSpTM3. try clear HOoABCApNSpTm4. try clear HOoABCApNSpTm3. try clear HOoABCApNSpTm2. try clear HOoABCApNSpTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApNSpT requis par la preuve de (?)OoApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApNSpT requis par la preuve de (?)OoApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApNSpTm2 : rk(Oo :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: N :: Sp :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: N ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoApNSpTm3 : rk(Oo :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	assert(HOoBCApNSpTmtmp : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoBCApNSpTeq HOoBCApNSpTm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: N :: Sp :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: Ap :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApNSpTmtmp;try rewrite HT2 in HOoBCApNSpTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: N :: Sp :: T :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoBCApNSpTmtmp HOoApNmtmp HOoBCApNMtmp Hincl); apply HT.
}
try clear HOoBCApNSpTM1. try clear HOoBCApNSpTM2. try clear HOoBCApNSpTM3. try clear HOoBCApNSpTm4. try clear HOoBCApNSpTm3. try clear HOoBCApNSpTm2. try clear HOoBCApNSpTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: T ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: T ::   de rang : 3 et 3 *)
assert(HOoApNSpTm4 : rk(Oo :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoApBpTeq : rk(Oo :: Ap :: Bp :: T :: nil) = 3) by (apply LOoApBpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpTMtmp : rk(Oo :: Ap :: Bp :: T :: nil) <= 3) by (solve_hyps_max HOoApBpTeq HOoApBpTM3).
	try assert(HOoApBpNSpTeq : rk(Oo :: Ap :: Bp :: N :: Sp :: T :: nil) = 4) by (apply LOoApBpNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNSpTmtmp : rk(Oo :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoApBpNSpTeq HOoApBpNSpTm4).
	try assert(HOoApTeq : rk(Oo :: Ap :: T :: nil) = 3) by (apply LOoApT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApTmtmp : rk(Oo :: Ap :: T :: nil) >= 3) by (solve_hyps_min HOoApTeq HOoApTm3).
	assert(Hincl : incl (Oo :: Ap :: T :: nil) (list_inter (Oo :: Ap :: Bp :: T :: nil) (Oo :: Ap :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: Ap :: Bp :: T :: Oo :: Ap :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: T :: Oo :: Ap :: N :: Sp :: T :: nil) ((Oo :: Ap :: Bp :: T :: nil) ++ (Oo :: Ap :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpNSpTmtmp;try rewrite HT2 in HOoApBpNSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: T :: nil) (Oo :: Ap :: N :: Sp :: T :: nil) (Oo :: Ap :: T :: nil) 4 3 3 HOoApBpNSpTmtmp HOoApTmtmp HOoApBpTMtmp Hincl); apply HT.
}


assert(HOoApNSpTM : rk(Oo :: Ap :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApNSpTm : rk(Oo :: Ap :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoApNSpTeq HOoApNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Sp :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour SpT requis par la preuve de (?)SpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : T ::  de rang :  1 et 1 	 A : Oo :: Ap :: N :: T ::   de rang : 3 et 3 *)
assert(HSpTm2 : rk(Sp :: T :: nil) >= 2).
{
	try assert(HOoApNTeq : rk(Oo :: Ap :: N :: T :: nil) = 3) by (apply LOoApNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNTMtmp : rk(Oo :: Ap :: N :: T :: nil) <= 3) by (solve_hyps_max HOoApNTeq HOoApNTM3).
	try assert(HOoApNSpTeq : rk(Oo :: Ap :: N :: Sp :: T :: nil) = 4) by (apply LOoApNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNSpTmtmp : rk(Oo :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoApNSpTeq HOoApNSpTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (Oo :: Ap :: N :: T :: nil) (Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: N :: Sp :: T :: nil) (Oo :: Ap :: N :: T :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: N :: T :: Sp :: T :: nil) ((Oo :: Ap :: N :: T :: nil) ++ (Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApNSpTmtmp;try rewrite HT2 in HOoApNSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: N :: T :: nil) (Sp :: T :: nil) (T :: nil) 4 1 3 HOoApNSpTmtmp HTmtmp HOoApNTMtmp Hincl); apply HT.
}


assert(HSpTM : rk(Sp :: T ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HSpTeq HSpTM2).
assert(HSpTm : rk(Sp :: T ::  nil) >= 1) by (solve_hyps_min HSpTeq HSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMSpT *)
(* dans constructLemma(), requis par LAMSpTU *)
(* dans la couche 0 *)
Lemma LACMSpTU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HACMSpTUM : rk(A :: C :: M :: Sp :: T :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACMSpTUm : rk(A :: C :: M :: Sp :: T :: U ::  nil) >= 1) by (solve_hyps_min HACMSpTUeq HACMSpTUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAMSpTU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M :: Sp :: T :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AMSpTU requis par la preuve de (?)AMSpTU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AMSpTU requis par la preuve de (?)AMSpTU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: M :: Sp :: T :: U ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C ::   de rang : 2 et 2 *)
assert(HAMSpTUm3 : rk(A :: M :: Sp :: T :: U :: nil) >= 3).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACMtmp : rk(A :: C :: nil) <= 2) by (solve_hyps_max HACeq HACM2).
	try assert(HACMSpTUeq : rk(A :: C :: M :: Sp :: T :: U :: nil) = 4) by (apply LACMSpTU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACMSpTUmtmp : rk(A :: C :: M :: Sp :: T :: U :: nil) >= 4) by (solve_hyps_min HACMSpTUeq HACMSpTUm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (A :: M :: Sp :: T :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: M :: Sp :: T :: U :: nil) (A :: C :: A :: M :: Sp :: T :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A :: M :: Sp :: T :: U :: nil) ((A :: C :: nil) ++ (A :: M :: Sp :: T :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACMSpTUmtmp;try rewrite HT2 in HACMSpTUmtmp.
	assert(HT := rule_4 (A :: C :: nil) (A :: M :: Sp :: T :: U :: nil) (A :: nil) 4 1 2 HACMSpTUmtmp HAmtmp HACMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: M :: Sp :: T :: U ::  de rang :  4 et 4 	 AiB : Sp :: T ::  de rang :  2 et 2 	 A : C :: Sp :: T ::   de rang : 2 et 2 *)
assert(HAMSpTUm4 : rk(A :: M :: Sp :: T :: U :: nil) >= 4).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HACMSpTUeq : rk(A :: C :: M :: Sp :: T :: U :: nil) = 4) by (apply LACMSpTU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACMSpTUmtmp : rk(A :: C :: M :: Sp :: T :: U :: nil) >= 4) by (solve_hyps_min HACMSpTUeq HACMSpTUm4).
	try assert(HSpTeq : rk(Sp :: T :: nil) = 2) by (apply LSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpTmtmp : rk(Sp :: T :: nil) >= 2) by (solve_hyps_min HSpTeq HSpTm2).
	assert(Hincl : incl (Sp :: T :: nil) (list_inter (C :: Sp :: T :: nil) (A :: M :: Sp :: T :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: M :: Sp :: T :: U :: nil) (C :: Sp :: T :: A :: M :: Sp :: T :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: T :: A :: M :: Sp :: T :: U :: nil) ((C :: Sp :: T :: nil) ++ (A :: M :: Sp :: T :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACMSpTUmtmp;try rewrite HT2 in HACMSpTUmtmp.
	assert(HT := rule_4 (C :: Sp :: T :: nil) (A :: M :: Sp :: T :: U :: nil) (Sp :: T :: nil) 4 2 2 HACMSpTUmtmp HSpTmtmp HCSpTMtmp Hincl); apply HT.
}
try clear HSpTM1. try clear HSpTM2. try clear HSpTM3. try clear HSpTm4. try clear HSpTm3. try clear HSpTm2. try clear HSpTm1. try clear HACMSpTUM1. try clear HACMSpTUM2. try clear HACMSpTUM3. try clear HACMSpTUm4. try clear HACMSpTUm3. try clear HACMSpTUm2. try clear HACMSpTUm1. 

assert(HAMSpTUM : rk(A :: M :: Sp :: T :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAMSpTUm : rk(A :: M :: Sp :: T :: U ::  nil) >= 1) by (solve_hyps_min HAMSpTUeq HAMSpTUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LMSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour MSpT requis par la preuve de (?)MSpT pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)MSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)OoAApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)OoAApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)OoAApMSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpTm2 : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpTm3 : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpTm4 : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour MSpT requis par la preuve de (?)MSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Sp :: T ::  de rang :  4 et 4 	 AiB : M :: T ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: M :: T ::   de rang : 4 et 4 *)
assert(HMSpTm2 : rk(M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAApMTeq : rk(Oo :: A :: Ap :: M :: T :: nil) = 4) by (apply LOoAApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMTMtmp : rk(Oo :: A :: Ap :: M :: T :: nil) <= 4) by (solve_hyps_max HOoAApMTeq HOoAApMTM4).
	assert(HOoAApMSpTmtmp : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoAApMSpTeq HOoAApMSpTm4).
	try assert(HMTeq : rk(M :: T :: nil) = 2) by (apply LMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMTmtmp : rk(M :: T :: nil) >= 2) by (solve_hyps_min HMTeq HMTm2).
	assert(Hincl : incl (M :: T :: nil) (list_inter (Oo :: A :: Ap :: M :: T :: nil) (M :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Sp :: T :: nil) (Oo :: A :: Ap :: M :: T :: M :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: T :: M :: Sp :: T :: nil) ((Oo :: A :: Ap :: M :: T :: nil) ++ (M :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMSpTmtmp;try rewrite HT2 in HOoAApMSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: M :: T :: nil) (M :: Sp :: T :: nil) (M :: T :: nil) 4 2 4 HOoAApMSpTmtmp HMTmtmp HOoAApMTMtmp Hincl); apply HT.
}
try clear HMTM1. try clear HMTM2. try clear HMTM3. try clear HMTm4. try clear HMTm3. try clear HMTm2. try clear HMTm1. try clear HOoAApMSpTM1. try clear HOoAApMSpTM2. try clear HOoAApMSpTM3. try clear HOoAApMSpTm4. try clear HOoAApMSpTm3. try clear HOoAApMSpTm2. try clear HOoAApMSpTm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HMSpTm3 : rk(M :: Sp :: T :: nil) >= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HAMSpTUeq : rk(A :: M :: Sp :: T :: U :: nil) = 4) by (apply LAMSpTU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMSpTUmtmp : rk(A :: M :: Sp :: T :: U :: nil) >= 4) by (solve_hyps_min HAMSpTUeq HAMSpTUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (M :: Sp :: T :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: M :: Sp :: T :: U :: nil) (M :: Sp :: T :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Sp :: T :: A :: M :: U :: nil) ((M :: Sp :: T :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAMSpTUmtmp;try rewrite HT2 in HAMSpTUmtmp.
	assert(HT := rule_2 (M :: Sp :: T :: nil) (A :: M :: U :: nil) (M :: nil) 4 1 2 HAMSpTUmtmp HMmtmp HAMUMtmp Hincl);apply HT.
}


assert(HMSpTM : rk(M :: Sp :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HMSpTeq HMSpTM3).
assert(HMSpTm : rk(M :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HMSpTeq HMSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMSpT requis par la preuve de (?)ApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMSpT requis par la preuve de (?)ApMSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)ApMSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)OoABApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)OoABApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)OoABApMSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpTm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpTm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpTm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMSpT requis par la preuve de (?)ApMSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMSpTm2 : rk(Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMSpTmtmp : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABApMSpTeq HOoABApMSpTm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: T :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMSpTmtmp;try rewrite HT2 in HOoABApMSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: T :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMSpTmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMSpTM1. try clear HOoABApMSpTM2. try clear HOoABApMSpTM3. try clear HOoABApMSpTm4. try clear HOoABApMSpTm3. try clear HOoABApMSpTm2. try clear HOoABApMSpTm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApMSpTM3 : rk(Ap :: M :: Sp :: T :: nil) <= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTMtmp : rk(T :: nil) <= 1) by (solve_hyps_max HTeq HTM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: M :: Sp :: nil) (T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: Sp :: T :: nil) (Ap :: M :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Sp :: nil) (T :: nil) (nil) 2 1 0 HApMSpMtmp HTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApMSpTm3 : rk(Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HApMTeq : rk(Ap :: M :: T :: nil) = 3) by (apply LApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMTmtmp : rk(Ap :: M :: T :: nil) >= 3) by (solve_hyps_min HApMTeq HApMTm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: M :: T :: nil) (Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: M :: T :: nil) (Ap :: M :: Sp :: T :: nil) 3 3 HApMTmtmp Hcomp Hincl);apply HT.
}


assert(HApMSpTM : rk(Ap :: M :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApMSpTm : rk(Ap :: M :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HApMSpTeq HApMSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApMSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)OoAApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)OoAApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMSpT requis par la preuve de (?)OoAApMSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpTm2 : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpTm3 : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpTm4 : rk(Oo :: A :: Ap :: M :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMSpTM : rk(Oo :: A :: Ap :: M :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMSpTm : rk(Oo :: A :: Ap :: M :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoAApMSpTeq HOoAApMSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)OoABApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)OoABApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSpT requis par la preuve de (?)OoABApMSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpTm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpTm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpTm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMSpTM : rk(Oo :: A :: B :: Ap :: M :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMSpTm : rk(Oo :: A :: B :: Ap :: M :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABApMSpTeq HOoABApMSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApNSpT *)
(* dans la couche 0 *)
Lemma LOoABCApNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm2 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm3 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm4 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApNSpTM : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApNSpTm : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApNSpTeq HOoABCApNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNSpTm2 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNSpTm3 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApNSpTm4 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApNSpTeq : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) = 4) by (apply LOoABCApNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApNSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApNSpTeq HOoABCApNSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNSpTmtmp;try rewrite HT2 in HOoABCApNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApNSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApNSpTM : rk(Oo :: B :: C :: Ap :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNSpTm : rk(Oo :: B :: C :: Ap :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApNSpTeq HOoBCApNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpNSpT requis par la preuve de (?)CBpNSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNSpT requis par la preuve de (?)CBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNSpT requis par la preuve de (?)CBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNSpT requis par la preuve de (?)OoACBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNSpT requis par la preuve de (?)OoACBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNSpTm2 : rk(Oo :: A :: C :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNSpTm3 : rk(Oo :: A :: C :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: Sp :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNSpT requis par la preuve de (?)CBpNSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: Sp :: T ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNSpTm2 : rk(C :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNSpTmtmp : rk(Oo :: A :: C :: Bp :: N :: Sp :: T :: nil) >= 3) by (solve_hyps_min HOoACBpNSpTeq HOoACBpNSpTm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: Sp :: T :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: Sp :: T :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNSpTmtmp;try rewrite HT2 in HOoACBpNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: Sp :: T :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNSpTmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpNSpTM1. try clear HOoACBpNSpTM2. try clear HOoACBpNSpTM3. try clear HOoACBpNSpTm4. try clear HOoACBpNSpTm3. try clear HOoACBpNSpTm2. try clear HOoACBpNSpTm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNSpTm3 : rk(C :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: N :: Sp :: T :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpNSpTM3 : rk(C :: Bp :: N :: Sp :: T :: nil) <= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (Bp :: N :: T :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: Sp :: T :: nil) (Bp :: N :: T :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: C :: Sp :: T :: nil) ((Bp :: N :: T :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: T :: nil) (C :: Sp :: T :: nil) (T :: nil) 2 2 1 HBpNTMtmp HCSpTMtmp HTmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpNSpTM : rk(C :: Bp :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNSpTm : rk(C :: Bp :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCBpNSpTeq HCBpNSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpNSpT *)
(* dans la couche 0 *)
Lemma LOoABCApBpNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoABCApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoABCApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpNSpT requis par la preuve de (?)OoABCApBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNSpTm2 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNSpTm3 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNSpTm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpNSpTM : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpNSpTm : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApBpNSpTeq HOoABCApBpNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpNSpT : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpNSpT requis par la preuve de (?)OoBCApBpNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNSpTm2 : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNSpTm3 : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApBpNSpTm4 : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApBpNSpTeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) = 4) by (apply LOoABCApBpNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApBpNSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApBpNSpTeq HOoABCApBpNSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpNSpTmtmp;try rewrite HT2 in HOoABCApBpNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApBpNSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApBpNSpTM : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpNSpTm : rk(Oo :: B :: C :: Ap :: Bp :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApBpNSpTeq HOoBCApBpNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(U ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HUM : rk(U ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HUeq HUM1).
assert(HUm : rk(U ::  nil) >= 1) by (solve_hyps_min HUeq HUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAU *)
(* dans la couche 0 *)
Lemma LACpUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpUV requis par la preuve de (?)ACpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm2 : rk(A :: C :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (nil) 4 0 2 HOoABCCpUVmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm3 : rk(A :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoABCCpUVmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpUV requis par la preuve de (?)ACpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpUV requis par la preuve de (?)ACpUV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACpUVM3 : rk(A :: Cp :: U :: V :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: U :: V :: nil) (A :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: U :: V :: nil) ((A :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Cp :: U :: V :: nil) (nil) 1 2 0 HAMtmp HCpUVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Cp :: U :: V ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HACpUVm2 : rk(A :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACCpUVmtmp : rk(A :: C :: Cp :: U :: V :: nil) >= 3) by (solve_hyps_min HACCpUVeq HACCpUVm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: U :: V :: nil) (C :: A :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Cp :: U :: V :: nil) ((C :: nil) ++ (A :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpUVmtmp;try rewrite HT2 in HACCpUVmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Cp :: U :: V :: nil) (nil) 3 0 1 HACCpUVmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HACCpUVM1. try clear HACCpUVM2. try clear HACCpUVM3. try clear HACCpUVm4. try clear HACCpUVm3. try clear HACCpUVm2. try clear HACCpUVm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACpUVm3 : rk(A :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACCpUVeq : rk(Oo :: A :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoACCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpUVmtmp : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoACCpUVeq HOoACCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: U :: V :: nil) (Oo :: A :: C :: A :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Cp :: U :: V :: nil) ((Oo :: A :: C :: nil) ++ (A :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpUVmtmp;try rewrite HT2 in HOoACCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoACCpUVmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACpUVM : rk(A :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpUVm : rk(A :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HACpUVeq HACpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AU requis par la preuve de (?)AU pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAUm2 : rk(A :: U :: nil) >= 2).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HACpUVeq : rk(A :: Cp :: U :: V :: nil) = 3) by (apply LACpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpUVmtmp : rk(A :: Cp :: U :: V :: nil) >= 3) by (solve_hyps_min HACpUVeq HACpUVm3).
	try assert(HUeq : rk(U :: nil) = 1) by (apply LU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: U :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: U :: V :: nil) (A :: U :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: U :: Cp :: U :: V :: nil) ((A :: U :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpUVmtmp;try rewrite HT2 in HACpUVmtmp.
	assert(HT := rule_2 (A :: U :: nil) (Cp :: U :: V :: nil) (U :: nil) 3 1 2 HACpUVmtmp HUmtmp HCpUVMtmp Hincl);apply HT.
}


assert(HAUM : rk(A :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAUeq HAUM2).
assert(HAUm : rk(A :: U ::  nil) >= 1) by (solve_hyps_min HAUeq HAUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpU requis par la preuve de (?)CpU pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpUm2 : rk(Cp :: U :: nil) >= 2).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HACpMUeq : rk(A :: Cp :: M :: U :: nil) = 3) by (apply LACpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMUmtmp : rk(A :: Cp :: M :: U :: nil) >= 3) by (solve_hyps_min HACpMUeq HACpMUm3).
	try assert(HUeq : rk(U :: nil) = 1) by (apply LU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (Cp :: U :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: U :: nil) (Cp :: U :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: U :: A :: M :: U :: nil) ((Cp :: U :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMUmtmp;try rewrite HT2 in HACpMUmtmp.
	assert(HT := rule_2 (Cp :: U :: nil) (A :: M :: U :: nil) (U :: nil) 3 1 2 HACpMUmtmp HUmtmp HAMUMtmp Hincl);apply HT.
}


assert(HCpUM : rk(Cp :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpUeq HCpUM2).
assert(HCpUm : rk(Cp :: U ::  nil) >= 1) by (solve_hyps_min HCpUeq HCpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpU requis par la preuve de (?)ACpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpU requis par la preuve de (?)ACpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm2 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm3 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpU requis par la preuve de (?)ACpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: U ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpUm2 : rk(A :: Cp :: U :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpUmtmp : rk(Oo :: A :: B :: Cp :: U :: nil) >= 3) by (solve_hyps_min HOoABCpUeq HOoABCpUm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: U :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpUmtmp;try rewrite HT2 in HOoABCpUmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpUmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpUm3 : rk(A :: Cp :: U :: nil) >= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HACpMUeq : rk(A :: Cp :: M :: U :: nil) = 3) by (apply LACpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMUmtmp : rk(A :: Cp :: M :: U :: nil) >= 3) by (solve_hyps_min HACpMUeq HACpMUm3).
	try assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: Cp :: U :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: U :: nil) (A :: Cp :: U :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: U :: A :: M :: U :: nil) ((A :: Cp :: U :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMUmtmp;try rewrite HT2 in HACpMUmtmp.
	assert(HT := rule_2 (A :: Cp :: U :: nil) (A :: M :: U :: nil) (A :: U :: nil) 3 2 2 HACpMUmtmp HAUmtmp HAMUMtmp Hincl);apply HT.
}


assert(HACpUM : rk(A :: Cp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpUeq HACpUM3).
assert(HACpUm : rk(A :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HACpUeq HACpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpU requis par la preuve de (?)OoACpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpU requis par la preuve de (?)OoACpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpU requis par la preuve de (?)OoACpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpUm2 : rk(Oo :: A :: Cp :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpUm3 : rk(Oo :: A :: Cp :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpUm4 : rk(Oo :: A :: Cp :: U :: nil) >= 4).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HOoACpMUeq : rk(Oo :: A :: Cp :: M :: U :: nil) = 4) by (apply LOoACpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMUmtmp : rk(Oo :: A :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoACpMUeq HOoACpMUm4).
	try assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (Oo :: A :: Cp :: U :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: M :: U :: nil) (Oo :: A :: Cp :: U :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: U :: A :: M :: U :: nil) ((Oo :: A :: Cp :: U :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpMUmtmp;try rewrite HT2 in HOoACpMUmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: U :: nil) (A :: M :: U :: nil) (A :: U :: nil) 4 2 2 HOoACpMUmtmp HAUmtmp HAMUMtmp Hincl);apply HT.
}


assert(HOoACpUM : rk(Oo :: A :: Cp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpUm : rk(Oo :: A :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HOoACpUeq HOoACpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCpU *)
(* dans la couche 0 *)
Lemma LOoABCpMU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMU requis par la preuve de (?)OoABCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMU requis par la preuve de (?)OoABCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMU requis par la preuve de (?)OoABCpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUm2 : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUm3 : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUm4 : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoACpMeq : rk(Oo :: A :: Cp :: M :: nil) = 4) by (apply LOoACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMmtmp : rk(Oo :: A :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACpMeq HOoACpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil) 4 4 HOoACpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCpMUM : rk(Oo :: A :: B :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpMUm : rk(Oo :: A :: B :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoABCpMUeq HOoABCpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCpU : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm2 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm3 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCpUm4 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 4).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HOoABCpMUeq : rk(Oo :: A :: B :: Cp :: M :: U :: nil) = 4) by (apply LOoABCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMUmtmp : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoABCpMUeq HOoABCpMUm4).
	try assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (Oo :: A :: B :: Cp :: U :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: U :: nil) (Oo :: A :: B :: Cp :: U :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: U :: A :: M :: U :: nil) ((Oo :: A :: B :: Cp :: U :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMUmtmp;try rewrite HT2 in HOoABCpMUmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: U :: nil) (A :: M :: U :: nil) (A :: U :: nil) 4 2 2 HOoABCpMUmtmp HAUmtmp HAMUMtmp Hincl);apply HT.
}
try clear HAUM1. try clear HAUM2. try clear HAUM3. try clear HAUm4. try clear HAUm3. try clear HAUm2. try clear HAUm1. 

assert(HOoABCpUM : rk(Oo :: A :: B :: Cp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpUm : rk(Oo :: A :: B :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HOoABCpUeq HOoABCpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(V ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HVM : rk(V ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HVeq HVM1).
assert(HVm : rk(V ::  nil) >= 1) by (solve_hyps_min HVeq HVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpV requis par la preuve de (?)CpV pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpVm2 : rk(Cp :: V :: nil) >= 2).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBCpNVeq : rk(B :: Cp :: N :: V :: nil) = 3) by (apply LBCpNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNVmtmp : rk(B :: Cp :: N :: V :: nil) >= 3) by (solve_hyps_min HBCpNVeq HBCpNVm3).
	try assert(HVeq : rk(V :: nil) = 1) by (apply LV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HVmtmp : rk(V :: nil) >= 1) by (solve_hyps_min HVeq HVm1).
	assert(Hincl : incl (V :: nil) (list_inter (Cp :: V :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: N :: V :: nil) (Cp :: V :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: V :: B :: N :: V :: nil) ((Cp :: V :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpNVmtmp;try rewrite HT2 in HBCpNVmtmp.
	assert(HT := rule_2 (Cp :: V :: nil) (B :: N :: V :: nil) (V :: nil) 3 1 2 HBCpNVmtmp HVmtmp HBNVMtmp Hincl);apply HT.
}


assert(HCpVM : rk(Cp :: V ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpVeq HCpVM2).
assert(HCpVm : rk(Cp :: V ::  nil) >= 1) by (solve_hyps_min HCpVeq HCpVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpMV *)
(* dans la couche 0 *)
Lemma LACpMUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMUV requis par la preuve de (?)ACpMUV pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMUV requis par la preuve de (?)ACpMUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMUV requis par la preuve de (?)ACpMUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMUV requis par la preuve de (?)OoABCpMUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMUV requis par la preuve de (?)OoABCpMUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUVm2 : rk(Oo :: A :: B :: Cp :: M :: U :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUVm3 : rk(Oo :: A :: B :: Cp :: M :: U :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMUV requis par la preuve de (?)ACpMUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: U :: V ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMUVm2 : rk(A :: Cp :: M :: U :: V :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMUVmtmp : rk(Oo :: A :: B :: Cp :: M :: U :: V :: nil) >= 3) by (solve_hyps_min HOoABCpMUVeq HOoABCpMUVm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: U :: V :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: U :: V :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMUVmtmp;try rewrite HT2 in HOoABCpMUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: U :: V :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMUVmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMUVM1. try clear HOoABCpMUVM2. try clear HOoABCpMUVM3. try clear HOoABCpMUVm4. try clear HOoABCpMUVm3. try clear HOoABCpMUVm2. try clear HOoABCpMUVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMUVm3 : rk(A :: Cp :: M :: U :: V :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: U :: V :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACpMUVM3 : rk(A :: Cp :: M :: U :: V :: nil) <= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HUeq : rk(U :: nil) = 1) by (apply LU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: M :: U :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: U :: V :: nil) (A :: M :: U :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: U :: Cp :: U :: V :: nil) ((A :: M :: U :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: M :: U :: nil) (Cp :: U :: V :: nil) (U :: nil) 2 2 1 HAMUMtmp HCpUVMtmp HUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HUM1. try clear HUM2. try clear HUM3. try clear HUm4. try clear HUm3. try clear HUm2. try clear HUm1. 

assert(HACpMUVM : rk(A :: Cp :: M :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMUVm : rk(A :: Cp :: M :: U :: V ::  nil) >= 1) by (solve_hyps_min HACpMUVeq HACpMUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpMV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMV requis par la preuve de (?)ACpMV pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMV requis par la preuve de (?)ACpMV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMV requis par la preuve de (?)ACpMV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMV requis par la preuve de (?)OoABCpMV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMV requis par la preuve de (?)OoABCpMV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMVm2 : rk(Oo :: A :: B :: Cp :: M :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMVm3 : rk(Oo :: A :: B :: Cp :: M :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMV requis par la preuve de (?)ACpMV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: V ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMVm2 : rk(A :: Cp :: M :: V :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMVmtmp : rk(Oo :: A :: B :: Cp :: M :: V :: nil) >= 3) by (solve_hyps_min HOoABCpMVeq HOoABCpMVm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: V :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: V :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMVmtmp;try rewrite HT2 in HOoABCpMVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: V :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMVmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMVM1. try clear HOoABCpMVM2. try clear HOoABCpMVM3. try clear HOoABCpMVm4. try clear HOoABCpMVm3. try clear HOoABCpMVm2. try clear HOoABCpMVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMVm3 : rk(A :: Cp :: M :: V :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: V :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMVM3 : rk(A :: Cp :: M :: V :: nil) <= 3).
{
	try assert(HACpMUVeq : rk(A :: Cp :: M :: U :: V :: nil) = 3) by (apply LACpMUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMUVMtmp : rk(A :: Cp :: M :: U :: V :: nil) <= 3) by (solve_hyps_max HACpMUVeq HACpMUVM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: V :: nil) (A :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Cp :: M :: V :: nil) (A :: Cp :: M :: U :: V :: nil) 3 3 HACpMUVMtmp Hcomp Hincl);apply HT.
}


assert(HACpMVM : rk(A :: Cp :: M :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMVm : rk(A :: Cp :: M :: V ::  nil) >= 1) by (solve_hyps_min HACpMVeq HACpMVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LNV *)
(* dans constructLemma(), requis par LCpNUV *)
(* dans la couche 0 *)
Lemma LBpCpNTUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HBpCpNTUVM : rk(Bp :: Cp :: N :: T :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpCpNTUVm : rk(Bp :: Cp :: N :: T :: U :: V ::  nil) >= 1) by (solve_hyps_min HBpCpNTUVeq HBpCpNTUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpNUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: N :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpNUV requis par la preuve de (?)CpNUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CpNUV requis par la preuve de (?)CpNUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpNUV requis par la preuve de (?)CpNUV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCpNUVM3 : rk(Cp :: N :: U :: V :: nil) <= 3).
{
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (N :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: N :: U :: V :: nil) (N :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: Cp :: U :: V :: nil) ((N :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (N :: nil) (Cp :: U :: V :: nil) (nil) 1 2 0 HNMtmp HCpUVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCpNUVm2 : rk(Cp :: N :: U :: V :: nil) >= 2).
{
	try assert(HCpNeq : rk(Cp :: N :: nil) = 2) by (apply LCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpNmtmp : rk(Cp :: N :: nil) >= 2) by (solve_hyps_min HCpNeq HCpNm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Cp :: N :: nil) (Cp :: N :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: N :: nil) (Cp :: N :: U :: V :: nil) 2 2 HCpNmtmp Hcomp Hincl);apply HT.
}
try clear HCpNM1. try clear HCpNM2. try clear HCpNM3. try clear HCpNm4. try clear HCpNm3. try clear HCpNm2. try clear HCpNm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Bp :: Cp :: N :: T :: U :: V ::  de rang :  4 et 4 	 AiB : N ::  de rang :  1 et 1 	 A : Bp :: N :: T ::   de rang : 2 et 2 *)
assert(HCpNUVm3 : rk(Cp :: N :: U :: V :: nil) >= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HBpCpNTUVeq : rk(Bp :: Cp :: N :: T :: U :: V :: nil) = 4) by (apply LBpCpNTUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpNTUVmtmp : rk(Bp :: Cp :: N :: T :: U :: V :: nil) >= 4) by (solve_hyps_min HBpCpNTUVeq HBpCpNTUVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: T :: nil) (Cp :: N :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Cp :: N :: T :: U :: V :: nil) (Bp :: N :: T :: Cp :: N :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: Cp :: N :: U :: V :: nil) ((Bp :: N :: T :: nil) ++ (Cp :: N :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpCpNTUVmtmp;try rewrite HT2 in HBpCpNTUVmtmp.
	assert(HT := rule_4 (Bp :: N :: T :: nil) (Cp :: N :: U :: V :: nil) (N :: nil) 4 1 2 HBpCpNTUVmtmp HNmtmp HBpNTMtmp Hincl); apply HT.
}
try clear HBpCpNTUVM1. try clear HBpCpNTUVM2. try clear HBpCpNTUVM3. try clear HBpCpNTUVm4. try clear HBpCpNTUVm3. try clear HBpCpNTUVm2. try clear HBpCpNTUVm1. 

assert(HCpNUVM : rk(Cp :: N :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpNUVm : rk(Cp :: N :: U :: V ::  nil) >= 1) by (solve_hyps_min HCpNUVeq HCpNUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NV requis par la preuve de (?)NV pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HNVm2 : rk(N :: V :: nil) >= 2).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HCpNUVeq : rk(Cp :: N :: U :: V :: nil) = 3) by (apply LCpNUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpNUVmtmp : rk(Cp :: N :: U :: V :: nil) >= 3) by (solve_hyps_min HCpNUVeq HCpNUVm3).
	try assert(HVeq : rk(V :: nil) = 1) by (apply LV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HVmtmp : rk(V :: nil) >= 1) by (solve_hyps_min HVeq HVm1).
	assert(Hincl : incl (V :: nil) (list_inter (N :: V :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: N :: U :: V :: nil) (N :: V :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: V :: Cp :: U :: V :: nil) ((N :: V :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCpNUVmtmp;try rewrite HT2 in HCpNUVmtmp.
	assert(HT := rule_2 (N :: V :: nil) (Cp :: U :: V :: nil) (V :: nil) 3 1 2 HCpNUVmtmp HVmtmp HCpUVMtmp Hincl);apply HT.
}
try clear HVM1. try clear HVM2. try clear HVM3. try clear HVm4. try clear HVm3. try clear HVm2. try clear HVm1. 

assert(HNVM : rk(N :: V ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNVeq HNVM2).
assert(HNVm : rk(N :: V ::  nil) >= 1) by (solve_hyps_min HNVeq HNVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LANV *)
(* dans la couche 0 *)
Lemma LABNV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABNV requis par la preuve de (?)ABNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABNV requis par la preuve de (?)ABNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABNV requis par la preuve de (?)ABNV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABNVM3 : rk(A :: B :: N :: V :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: N :: V :: nil) (A :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: N :: V :: nil) ((A :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: N :: V :: nil) (nil) 1 2 0 HAMtmp HBNVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNVm2 : rk(A :: B :: N :: V :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: N :: V :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNVm3 : rk(A :: B :: N :: V :: nil) >= 3).
{
	try assert(HABNeq : rk(A :: B :: N :: nil) = 3) by (apply LABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABNmtmp : rk(A :: B :: N :: nil) >= 3) by (solve_hyps_min HABNeq HABNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: N :: nil) (A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: N :: nil) (A :: B :: N :: V :: nil) 3 3 HABNmtmp Hcomp Hincl);apply HT.
}


assert(HABNVM : rk(A :: B :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABNVm : rk(A :: B :: N :: V ::  nil) >= 1) by (solve_hyps_min HABNVeq HABNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LANV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ANV requis par la preuve de (?)ANV pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ANV requis par la preuve de (?)ANV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: N :: V ::  de rang :  3 et 3 	 AiB : A :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: N ::   de rang : 3 et 3 *)
assert(HANVm2 : rk(A :: N :: V :: nil) >= 2).
{
	try assert(HOoABNeq : rk(Oo :: A :: B :: N :: nil) = 3) by (apply LOoABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNMtmp : rk(Oo :: A :: B :: N :: nil) <= 3) by (solve_hyps_max HOoABNeq HOoABNM3).
	try assert(HOoABNVeq : rk(Oo :: A :: B :: N :: V :: nil) = 3) by (apply LOoABNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNVmtmp : rk(Oo :: A :: B :: N :: V :: nil) >= 3) by (solve_hyps_min HOoABNVeq HOoABNVm3).
	try assert(HANeq : rk(A :: N :: nil) = 2) by (apply LAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HANmtmp : rk(A :: N :: nil) >= 2) by (solve_hyps_min HANeq HANm2).
	assert(Hincl : incl (A :: N :: nil) (list_inter (Oo :: A :: B :: N :: nil) (A :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: V :: nil) (Oo :: A :: B :: N :: A :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: A :: N :: V :: nil) ((Oo :: A :: B :: N :: nil) ++ (A :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABNVmtmp;try rewrite HT2 in HOoABNVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: N :: nil) (A :: N :: V :: nil) (A :: N :: nil) 3 2 3 HOoABNVmtmp HANmtmp HOoABNMtmp Hincl); apply HT.
}
try clear HANM1. try clear HANM2. try clear HANM3. try clear HANm4. try clear HANm3. try clear HANm2. try clear HANm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HANVm3 : rk(A :: N :: V :: nil) >= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HABNVeq : rk(A :: B :: N :: V :: nil) = 3) by (apply LABNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABNVmtmp : rk(A :: B :: N :: V :: nil) >= 3) by (solve_hyps_min HABNVeq HABNVm3).
	try assert(HNVeq : rk(N :: V :: nil) = 2) by (apply LNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNVmtmp : rk(N :: V :: nil) >= 2) by (solve_hyps_min HNVeq HNVm2).
	assert(Hincl : incl (N :: V :: nil) (list_inter (A :: N :: V :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: N :: V :: nil) (A :: N :: V :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: N :: V :: B :: N :: V :: nil) ((A :: N :: V :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABNVmtmp;try rewrite HT2 in HABNVmtmp.
	assert(HT := rule_2 (A :: N :: V :: nil) (B :: N :: V :: nil) (N :: V :: nil) 3 2 2 HABNVmtmp HNVmtmp HBNVMtmp Hincl);apply HT.
}
try clear HNVM1. try clear HNVM2. try clear HNVM3. try clear HNVm4. try clear HNVm3. try clear HNVm2. try clear HNVm1. 

assert(HANVM : rk(A :: N :: V ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HANVeq HANVM3).
assert(HANVm : rk(A :: N :: V ::  nil) >= 1) by (solve_hyps_min HANVeq HANVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoANV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: N :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoANV requis par la preuve de (?)OoANV pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoANV requis par la preuve de (?)OoANV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoANV requis par la preuve de (?)OoANV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANVm2 : rk(Oo :: A :: N :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANVm3 : rk(Oo :: A :: N :: V :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: N :: V :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANVM3 : rk(Oo :: A :: N :: V :: nil) <= 3).
{
	try assert(HOoABNVeq : rk(Oo :: A :: B :: N :: V :: nil) = 3) by (apply LOoABNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNVMtmp : rk(Oo :: A :: B :: N :: V :: nil) <= 3) by (solve_hyps_max HOoABNVeq HOoABNVM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: V :: nil) (Oo :: A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: N :: V :: nil) (Oo :: A :: B :: N :: V :: nil) 3 3 HOoABNVMtmp Hcomp Hincl);apply HT.
}


assert(HOoANVM : rk(Oo :: A :: N :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoANVm : rk(Oo :: A :: N :: V ::  nil) >= 1) by (solve_hyps_min HOoANVeq HOoANVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(R ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HRM : rk(R ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HReq HRM1).
assert(HRm : rk(R ::  nil) >= 1) by (solve_hyps_min HReq HRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCR *)
(* dans la couche 0 *)
Lemma LACCpYMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp :: Y :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpYMR requis par la preuve de (?)ACCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpYMR requis par la preuve de (?)ACCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpYMR requis par la preuve de (?)ACCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMRm2 : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: Y :: M :: R :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMRm3 : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HACCpeq : rk(A :: C :: Cp :: nil) = 3) by (apply LACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 3) by (solve_hyps_min HACCpeq HACCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: nil) (A :: C :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: nil) (A :: C :: Cp :: Y :: M :: R :: nil) 3 3 HACCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMRm4 : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 4).
{
	try assert(HACCpMeq : rk(A :: C :: Cp :: M :: nil) = 4) by (apply LACCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpMmtmp : rk(A :: C :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACCpMeq HACCpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: R :: nil) 4 4 HACCpMmtmp Hcomp Hincl);apply HT.
}


assert(HACCpYMRM : rk(A :: C :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpYMRm : rk(A :: C :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HACCpYMReq HACCpYMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCR *)
(* dans la couche 0 *)
Lemma LACpYMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpYMR requis par la preuve de (?)ACpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour YMR requis par la preuve de (?)ACpYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYMR requis par la preuve de (?)ACpYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYMR requis par la preuve de (?)ACpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYMR requis par la preuve de (?)OoABCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYMR requis par la preuve de (?)OoABCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMRm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMRm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYMR requis par la preuve de (?)ACpYMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMRm2 : rk(A :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMRmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: R :: nil) >= 3) by (solve_hyps_min HOoABCpYMReq HOoABCpYMRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMRmtmp;try rewrite HT2 in HOoABCpYMRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMRM1. try clear HOoABCpYMRM2. try clear HOoABCpYMRM3. try clear HOoABCpYMRm4. try clear HOoABCpYMRm3. try clear HOoABCpYMRm2. try clear HOoABCpYMRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HACpYMRM3 : rk(A :: Cp :: Y :: M :: R :: nil) <= 3).
{
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	assert(HYMRMtmp : rk(Y :: M :: R :: nil) <= 2) by (solve_hyps_max HYMReq HYMRM2).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (A :: Cp :: Y :: nil) (Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: R :: nil) (A :: Cp :: Y :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Y :: Y :: M :: R :: nil) ((A :: Cp :: Y :: nil) ++ (Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Cp :: Y :: nil) (Y :: M :: R :: nil) (Y :: nil) 2 2 1 HACpYMtmp HYMRMtmp HYmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HACpYM1. try clear HACpYM2. try clear HACpYM3. try clear HACpYm4. try clear HACpYm3. try clear HACpYm2. try clear HACpYm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMRm3 : rk(A :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


assert(HACpYMRM : rk(A :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMRm : rk(A :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HACpYMReq HACpYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CR requis par la preuve de (?)CR pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCRm2 : rk(C :: R :: nil) >= 2).
{
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	try assert(HACCpYMReq : rk(A :: C :: Cp :: Y :: M :: R :: nil) = 4) by (apply LACCpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpYMRmtmp : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 4) by (solve_hyps_min HACCpYMReq HACCpYMRm4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (C :: R :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: Y :: M :: R :: nil) (C :: R :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: R :: A :: Cp :: Y :: M :: R :: nil) ((C :: R :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpYMRmtmp;try rewrite HT2 in HACCpYMRmtmp.
	assert(HT := rule_2 (C :: R :: nil) (A :: Cp :: Y :: M :: R :: nil) (R :: nil) 4 1 3 HACCpYMRmtmp HRmtmp HACpYMRMtmp Hincl);apply HT.
}


assert(HCRM : rk(C :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCReq HCRM2).
assert(HCRm : rk(C :: R ::  nil) >= 1) by (solve_hyps_min HCReq HCRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMR *)
(* dans constructLemma(), requis par LCBpZMNR *)
(* dans constructLemma(), requis par LCBpZMNSpTR *)
(* dans constructLemma(), requis par LCApBpZMNSpTR *)
(* dans la couche 0 *)
Lemma LOoCApBpZMNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpZMNSpTR requis par la preuve de (?)OoCApBpZMNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpZMNSpTR requis par la preuve de (?)OoCApBpZMNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpZMNSpTR requis par la preuve de (?)OoCApBpZMNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZMNSpTRm2 : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZMNSpTRm3 : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZMNSpTRm4 : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpZMNSpTRM : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpZMNSpTRm : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoCApBpZMNSpTReq HOoCApBpZMNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpZMNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpZMNSpTR requis par la preuve de (?)CApBpZMNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpZMNSpTR requis par la preuve de (?)CApBpZMNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpZMNSpTR requis par la preuve de (?)OoCApBpZMNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpZMNSpTR requis par la preuve de (?)OoCApBpZMNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZMNSpTRm2 : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZMNSpTRm3 : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpZMNSpTR requis par la preuve de (?)CApBpZMNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpZMNSpTR requis par la preuve de (?)CApBpZMNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpZMNSpTR requis par la preuve de (?)OoACApBpZMNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpZMNSpTR requis par la preuve de (?)OoACApBpZMNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpZMNSpTRm2 : rk(Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpZMNSpTRm3 : rk(Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpZMNSpTR requis par la preuve de (?)CApBpZMNSpTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpZMNSpTRm2 : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpZMNSpTRmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApBpZMNSpTReq HOoACApBpZMNSpTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpZMNSpTRmtmp;try rewrite HT2 in HOoACApBpZMNSpTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpZMNSpTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpZMNSpTRM1. try clear HOoACApBpZMNSpTRM2. try clear HOoACApBpZMNSpTRM3. try clear HOoACApBpZMNSpTRm4. try clear HOoACApBpZMNSpTRm3. try clear HOoACApBpZMNSpTRm2. try clear HOoACApBpZMNSpTRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpZMNSpTRm3 : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpZMNSpTRmtmp : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoCApBpZMNSpTReq HOoCApBpZMNSpTRm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpZMNSpTRmtmp;try rewrite HT2 in HOoCApBpZMNSpTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpZMNSpTRmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HCApBpZMNSpTRm4 : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	try assert(HOoCApBpZMNSpTReq : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) = 4) by (apply LOoCApBpZMNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpZMNSpTRmtmp : rk(Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HOoCApBpZMNSpTReq HOoCApBpZMNSpTRm4).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpZMNSpTRmtmp;try rewrite HT2 in HOoCApBpZMNSpTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Ap :: Bp :: M :: nil) 4 3 3 HOoCApBpZMNSpTRmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoCApBpZMNSpTRM1. try clear HOoCApBpZMNSpTRM2. try clear HOoCApBpZMNSpTRM3. try clear HOoCApBpZMNSpTRm4. try clear HOoCApBpZMNSpTRm3. try clear HOoCApBpZMNSpTRm2. try clear HOoCApBpZMNSpTRm1. 

assert(HCApBpZMNSpTRM : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpZMNSpTRm : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApBpZMNSpTReq HCApBpZMNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZMNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZMNSpTR requis par la preuve de (?)CBpZMNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZMNSpTR requis par la preuve de (?)CBpZMNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZMNSpTR requis par la preuve de (?)CBpZMNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZMNSpTR requis par la preuve de (?)OoACBpZMNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZMNSpTR requis par la preuve de (?)OoACBpZMNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNSpTRm2 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNSpTRm3 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZMNSpTR requis par la preuve de (?)CBpZMNSpTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZMNSpTRm2 : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZMNSpTRmtmp : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZMNSpTReq HOoACBpZMNSpTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZMNSpTRmtmp;try rewrite HT2 in HOoACBpZMNSpTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZMNSpTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZMNSpTRM1. try clear HOoACBpZMNSpTRM2. try clear HOoACBpZMNSpTRM3. try clear HOoACBpZMNSpTRm4. try clear HOoACBpZMNSpTRm3. try clear HOoACBpZMNSpTRm2. try clear HOoACBpZMNSpTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZMNSpTRm3 : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HCBpMeq : rk(C :: Bp :: M :: nil) = 3) by (apply LCBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpMmtmp : rk(C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HCBpMeq HCBpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) 3 3 HCBpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R ::  de rang :  4 et 4 	 AiB : M :: Sp :: T ::  de rang :  3 et 3 	 A : Ap :: M :: Sp :: T ::   de rang : 3 et 3 *)
assert(HCBpZMNSpTRm4 : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HApMSpTeq : rk(Ap :: M :: Sp :: T :: nil) = 3) by (apply LApMSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpTMtmp : rk(Ap :: M :: Sp :: T :: nil) <= 3) by (solve_hyps_max HApMSpTeq HApMSpTM3).
	try assert(HCApBpZMNSpTReq : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) = 4) by (apply LCApBpZMNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpZMNSpTRmtmp : rk(C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HCApBpZMNSpTReq HCApBpZMNSpTRm4).
	try assert(HMSpTeq : rk(M :: Sp :: T :: nil) = 3) by (apply LMSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMSpTmtmp : rk(M :: Sp :: T :: nil) >= 3) by (solve_hyps_min HMSpTeq HMSpTm3).
	assert(Hincl : incl (M :: Sp :: T :: nil) (list_inter (Ap :: M :: Sp :: T :: nil) (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (Ap :: M :: Sp :: T :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: T :: C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) ((Ap :: M :: Sp :: T :: nil) ++ (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpZMNSpTRmtmp;try rewrite HT2 in HCApBpZMNSpTRmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: T :: nil) (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (M :: Sp :: T :: nil) 4 3 3 HCApBpZMNSpTRmtmp HMSpTmtmp HApMSpTMtmp Hincl); apply HT.
}


assert(HCBpZMNSpTRM : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZMNSpTRm : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpZMNSpTReq HCBpZMNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZMNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: M :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZMNR requis par la preuve de (?)OoACBpZMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZMNR requis par la preuve de (?)OoACBpZMNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNRm2 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNRm3 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: M :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZMNRm2 : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZMNRmtmp : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZMNReq HOoACBpZMNRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZMNRmtmp;try rewrite HT2 in HOoACBpZMNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZMNRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZMNRM1. try clear HOoACBpZMNRM2. try clear HOoACBpZMNRM3. try clear HOoACBpZMNRm4. try clear HOoACBpZMNRm3. try clear HOoACBpZMNRm2. try clear HOoACBpZMNRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZMNRm3 : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 3).
{
	try assert(HCBpMeq : rk(C :: Bp :: M :: nil) = 3) by (apply LCBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpMmtmp : rk(C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HCBpMeq HCBpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: R :: nil) 3 3 HCBpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: Z :: M :: N :: Sp :: T :: R ::  de rang :  4 et 4 	 AiB : C :: Bp :: N ::  de rang :  3 et 3 	 A : C :: Bp :: N :: Sp :: T ::   de rang : 3 et 3 *)
assert(HCBpZMNRm4 : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 4).
{
	try assert(HCBpNSpTeq : rk(C :: Bp :: N :: Sp :: T :: nil) = 3) by (apply LCBpNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNSpTMtmp : rk(C :: Bp :: N :: Sp :: T :: nil) <= 3) by (solve_hyps_max HCBpNSpTeq HCBpNSpTM3).
	try assert(HCBpZMNSpTReq : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) = 4) by (apply LCBpZMNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZMNSpTRmtmp : rk(C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HCBpZMNSpTReq HCBpZMNSpTRm4).
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hincl : incl (C :: Bp :: N :: nil) (list_inter (C :: Bp :: N :: Sp :: T :: nil) (C :: Bp :: Z :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: M :: N :: Sp :: T :: R :: nil) (C :: Bp :: N :: Sp :: T :: C :: Bp :: Z :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: Sp :: T :: C :: Bp :: Z :: M :: N :: R :: nil) ((C :: Bp :: N :: Sp :: T :: nil) ++ (C :: Bp :: Z :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpZMNSpTRmtmp;try rewrite HT2 in HCBpZMNSpTRmtmp.
	assert(HT := rule_4 (C :: Bp :: N :: Sp :: T :: nil) (C :: Bp :: Z :: M :: N :: R :: nil) (C :: Bp :: N :: nil) 4 3 3 HCBpZMNSpTRmtmp HCBpNmtmp HCBpNSpTMtmp Hincl); apply HT.
}


assert(HCBpZMNRM : rk(C :: Bp :: Z :: M :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZMNRm : rk(C :: Bp :: Z :: M :: N :: R ::  nil) >= 1) by (solve_hyps_min HCBpZMNReq HCBpZMNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMR *)
(* dans la couche 0 *)
Lemma LCBpZNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpZNR requis par la preuve de (?)CBpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ZNR requis par la preuve de (?)CBpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZNR requis par la preuve de (?)CBpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZNR requis par la preuve de (?)CBpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZNR requis par la preuve de (?)OoACBpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZNR requis par la preuve de (?)OoACBpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNRm2 : rk(Oo :: A :: C :: Bp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNRm3 : rk(Oo :: A :: C :: Bp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZNR requis par la preuve de (?)CBpZNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZNRm2 : rk(C :: Bp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZNRmtmp : rk(Oo :: A :: C :: Bp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZNReq HOoACBpZNRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: N :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZNRmtmp;try rewrite HT2 in HOoACBpZNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZNRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZNRM1. try clear HOoACBpZNRM2. try clear HOoACBpZNRM3. try clear HOoACBpZNRm4. try clear HOoACBpZNRm3. try clear HOoACBpZNRm2. try clear HOoACBpZNRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HCBpZNRM3 : rk(C :: Bp :: Z :: N :: R :: nil) <= 3).
{
	try assert(HCBpZeq : rk(C :: Bp :: Z :: nil) = 2) by (apply LCBpZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZMtmp : rk(C :: Bp :: Z :: nil) <= 2) by (solve_hyps_max HCBpZeq HCBpZM2).
	assert(HZNRMtmp : rk(Z :: N :: R :: nil) <= 2) by (solve_hyps_max HZNReq HZNRM2).
	try assert(HZeq : rk(Z :: nil) = 1) by (apply LZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HZmtmp : rk(Z :: nil) >= 1) by (solve_hyps_min HZeq HZm1).
	assert(Hincl : incl (Z :: nil) (list_inter (C :: Bp :: Z :: nil) (Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: N :: R :: nil) (C :: Bp :: Z :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Z :: Z :: N :: R :: nil) ((C :: Bp :: Z :: nil) ++ (Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Bp :: Z :: nil) (Z :: N :: R :: nil) (Z :: nil) 2 2 1 HCBpZMtmp HZNRMtmp HZmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCBpZM1. try clear HCBpZM2. try clear HCBpZM3. try clear HCBpZm4. try clear HCBpZm3. try clear HCBpZm2. try clear HCBpZm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZNRm3 : rk(C :: Bp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


assert(HCBpZNRM : rk(C :: Bp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZNRm : rk(C :: Bp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HCBpZNReq HCBpZNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MR requis par la preuve de (?)MR pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HMRm2 : rk(M :: R :: nil) >= 2).
{
	try assert(HCBpZNReq : rk(C :: Bp :: Z :: N :: R :: nil) = 3) by (apply LCBpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNRMtmp : rk(C :: Bp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpZNReq HCBpZNRM3).
	try assert(HCBpZMNReq : rk(C :: Bp :: Z :: M :: N :: R :: nil) = 4) by (apply LCBpZMNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZMNRmtmp : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 4) by (solve_hyps_min HCBpZMNReq HCBpZMNRm4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (M :: R :: nil) (C :: Bp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: M :: N :: R :: nil) (M :: R :: C :: Bp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: R :: C :: Bp :: Z :: N :: R :: nil) ((M :: R :: nil) ++ (C :: Bp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpZMNRmtmp;try rewrite HT2 in HCBpZMNRmtmp.
	assert(HT := rule_2 (M :: R :: nil) (C :: Bp :: Z :: N :: R :: nil) (R :: nil) 4 1 3 HCBpZMNRmtmp HRmtmp HCBpZNRMtmp Hincl);apply HT.
}


assert(HMRM : rk(M :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HMReq HMRM2).
assert(HMRm : rk(M :: R ::  nil) >= 1) by (solve_hyps_min HMReq HMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApMR *)
(* dans constructLemma(), requis par LAApCpYMR *)
(* dans la couche 0 *)
Lemma LOoAApCpYMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Cp :: Y :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm2 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm3 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm4 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApCpYMRM : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpYMRm : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HOoAApCpYMReq HOoAApCpYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpYMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Cp :: Y :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm2 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm3 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApCpYMRm2 : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: Y :: M :: R ::  de rang :  3 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApCpYMRm3 : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	assert(HOoAApCpYMRmtmp : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3) by (solve_hyps_min HOoAApCpYMReq HOoAApCpYMRm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) (Oo :: Ap :: Cp :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: Cp :: Y :: M :: R :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpYMRmtmp;try rewrite HT2 in HOoAApCpYMRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil) (Ap :: Cp :: nil) 3 2 2 HOoAApCpYMRmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: Y :: M :: R ::  de rang :  4 et 4 	 AiB : Ap :: Cp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Cp :: M ::   de rang : 3 et 3 *)
assert(HAApCpYMRm4 : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4).
{
	try assert(HOoApCpMeq : rk(Oo :: Ap :: Cp :: M :: nil) = 3) by (apply LOoApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMMtmp : rk(Oo :: Ap :: Cp :: M :: nil) <= 3) by (solve_hyps_max HOoApCpMeq HOoApCpMM3).
	try assert(HOoAApCpYMReq : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) = 4) by (apply LOoAApCpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpYMRmtmp : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4) by (solve_hyps_min HOoAApCpYMReq HOoAApCpYMRm4).
	try assert(HApCpMeq : rk(Ap :: Cp :: M :: nil) = 3) by (apply LApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpMmtmp : rk(Ap :: Cp :: M :: nil) >= 3) by (solve_hyps_min HApCpMeq HApCpMm3).
	assert(Hincl : incl (Ap :: Cp :: M :: nil) (list_inter (Oo :: Ap :: Cp :: M :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) (Oo :: Ap :: Cp :: M :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: A :: Ap :: Cp :: Y :: M :: R :: nil) ((Oo :: Ap :: Cp :: M :: nil) ++ (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpYMRmtmp;try rewrite HT2 in HOoAApCpYMRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: M :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil) (Ap :: Cp :: M :: nil) 4 3 3 HOoAApCpYMRmtmp HApCpMmtmp HOoApCpMMtmp Hincl); apply HT.
}
try clear HOoAApCpYMRM1. try clear HOoAApCpYMRM2. try clear HOoAApCpYMRM3. try clear HOoAApCpYMRm4. try clear HOoAApCpYMRm3. try clear HOoAApCpYMRm2. try clear HOoAApCpYMRm1. 

assert(HAApCpYMRM : rk(A :: Ap :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpYMRm : rk(A :: Ap :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HAApCpYMReq HAApCpYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMR requis par la preuve de (?)ApMR pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMR requis par la preuve de (?)ApMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm2 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm3 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm4 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApMR requis par la preuve de (?)ApMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: R ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMRm2 : rk(Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMRmtmp : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 4) by (solve_hyps_min HOoABApMReq HOoABApMRm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: R :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: R :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMRmtmp;try rewrite HT2 in HOoABApMRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: R :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMRmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMRM1. try clear HOoABApMRM2. try clear HOoABApMRM3. try clear HOoABApMRm4. try clear HOoABApMRm3. try clear HOoABApMRm2. try clear HOoABApMRm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApMRm3 : rk(Ap :: M :: R :: nil) >= 3).
{
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	try assert(HAApCpYMReq : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) = 4) by (apply LAApCpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApCpYMRmtmp : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4) by (solve_hyps_min HAApCpYMReq HAApCpYMRm4).
	try assert(HMReq : rk(M :: R :: nil) = 2) by (apply LMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMRmtmp : rk(M :: R :: nil) >= 2) by (solve_hyps_min HMReq HMRm2).
	assert(Hincl : incl (M :: R :: nil) (list_inter (Ap :: M :: R :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: Y :: M :: R :: nil) (Ap :: M :: R :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: R :: A :: Cp :: Y :: M :: R :: nil) ((Ap :: M :: R :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpYMRmtmp;try rewrite HT2 in HAApCpYMRmtmp.
	assert(HT := rule_2 (Ap :: M :: R :: nil) (A :: Cp :: Y :: M :: R :: nil) (M :: R :: nil) 4 2 3 HAApCpYMRmtmp HMRmtmp HACpYMRMtmp Hincl);apply HT.
}
try clear HMRM1. try clear HMRM2. try clear HMRM3. try clear HMRm4. try clear HMRm3. try clear HMRm2. try clear HMRm1. 

assert(HApMRM : rk(Ap :: M :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMReq HApMRM3).
assert(HApMRm : rk(Ap :: M :: R ::  nil) >= 1) by (solve_hyps_min HApMReq HApMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm2 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm3 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm4 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMRM : rk(Oo :: A :: B :: Ap :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMRm : rk(Oo :: A :: B :: Ap :: M :: R ::  nil) >= 1) by (solve_hyps_min HOoABApMReq HOoABApMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApMR *)
(* dans la couche 0 *)
Lemma LCApYMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Y :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApYMR requis par la preuve de (?)CApYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour YMR requis par la preuve de (?)CApYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApYMR requis par la preuve de (?)CApYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApYMR requis par la preuve de (?)CApYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApYMR requis par la preuve de (?)OoACApYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApYMR requis par la preuve de (?)OoACApYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMRm2 : rk(Oo :: A :: C :: Ap :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMRm3 : rk(Oo :: A :: C :: Ap :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApYMR requis par la preuve de (?)CApYMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Y :: M :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApYMRm2 : rk(C :: Ap :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApYMRmtmp : rk(Oo :: A :: C :: Ap :: Y :: M :: R :: nil) >= 3) by (solve_hyps_min HOoACApYMReq HOoACApYMRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: M :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApYMRmtmp;try rewrite HT2 in HOoACApYMRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApYMRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApYMRM1. try clear HOoACApYMRM2. try clear HOoACApYMRM3. try clear HOoACApYMRm4. try clear HOoACApYMRm3. try clear HOoACApYMRm2. try clear HOoACApYMRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HCApYMRM3 : rk(C :: Ap :: Y :: M :: R :: nil) <= 3).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	assert(HYMRMtmp : rk(Y :: M :: R :: nil) <= 2) by (solve_hyps_max HYMReq HYMRM2).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (C :: Ap :: Y :: nil) (Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Y :: M :: R :: nil) (C :: Ap :: Y :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: Y :: M :: R :: nil) ((C :: Ap :: Y :: nil) ++ (Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: Y :: nil) (Y :: M :: R :: nil) (Y :: nil) 2 2 1 HCApYMtmp HYMRMtmp HYmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCApYM1. try clear HCApYM2. try clear HCApYM3. try clear HCApYm4. try clear HCApYm3. try clear HCApYm2. try clear HCApYm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApYMRm3 : rk(C :: Ap :: Y :: M :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


assert(HCApYMRM : rk(C :: Ap :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApYMRm : rk(C :: Ap :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HCApYMReq HCApYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMR requis par la preuve de (?)CApMR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMR requis par la preuve de (?)CApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMR requis par la preuve de (?)CApMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMR requis par la preuve de (?)OoACApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMR requis par la preuve de (?)OoACApMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMRm2 : rk(Oo :: A :: C :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMRm3 : rk(Oo :: A :: C :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMR requis par la preuve de (?)CApMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMRm2 : rk(C :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMRmtmp : rk(Oo :: A :: C :: Ap :: M :: R :: nil) >= 3) by (solve_hyps_min HOoACApMReq HOoACApMRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMRmtmp;try rewrite HT2 in HOoACApMRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMRM1. try clear HOoACApMRM2. try clear HOoACApMRM3. try clear HOoACApMRm4. try clear HOoACApMRm3. try clear HOoACApMRm2. try clear HOoACApMRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMRm3 : rk(C :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMRM3 : rk(C :: Ap :: M :: R :: nil) <= 3).
{
	try assert(HCApYMReq : rk(C :: Ap :: Y :: M :: R :: nil) = 3) by (apply LCApYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMRMtmp : rk(C :: Ap :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HCApYMReq HCApYMRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: R :: nil) (C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: M :: R :: nil) (C :: Ap :: Y :: M :: R :: nil) 3 3 HCApYMRMtmp Hcomp Hincl);apply HT.
}


assert(HCApMRM : rk(C :: Ap :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMRm : rk(C :: Ap :: M :: R ::  nil) >= 1) by (solve_hyps_min HCApMReq HCApMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMR requis par la preuve de (?)ACpMR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMR requis par la preuve de (?)ACpMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMR requis par la preuve de (?)ACpMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMR requis par la preuve de (?)OoABCpMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMR requis par la preuve de (?)OoABCpMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMRm2 : rk(Oo :: A :: B :: Cp :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMRm3 : rk(Oo :: A :: B :: Cp :: M :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMR requis par la preuve de (?)ACpMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMRm2 : rk(A :: Cp :: M :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMRmtmp : rk(Oo :: A :: B :: Cp :: M :: R :: nil) >= 3) by (solve_hyps_min HOoABCpMReq HOoABCpMRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMRmtmp;try rewrite HT2 in HOoABCpMRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMRM1. try clear HOoABCpMRM2. try clear HOoABCpMRM3. try clear HOoABCpMRm4. try clear HOoABCpMRm3. try clear HOoABCpMRm2. try clear HOoABCpMRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMRm3 : rk(A :: Cp :: M :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMRM3 : rk(A :: Cp :: M :: R :: nil) <= 3).
{
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: R :: nil) (A :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Cp :: M :: R :: nil) (A :: Cp :: Y :: M :: R :: nil) 3 3 HACpYMRMtmp Hcomp Hincl);apply HT.
}


assert(HACpMRM : rk(A :: Cp :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMRm : rk(A :: Cp :: M :: R ::  nil) >= 1) by (solve_hyps_min HACpMReq HACpMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LYMR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Y :: M :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HYMRM : rk(Y :: M :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HYMReq HYMRM3).
assert(HYMRm : rk(Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HYMReq HYMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LNR *)
(* dans constructLemma(), requis par LACpMNR *)
(* dans constructLemma(), requis par LACpMNUVR *)
(* dans la couche 0 *)
Lemma LOoACpMNUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: M :: N :: U :: V :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpMNUVR requis par la preuve de (?)OoACpMNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpMNUVR requis par la preuve de (?)OoACpMNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpMNUVR requis par la preuve de (?)OoACpMNUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMNUVRm2 : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMNUVRm3 : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMNUVRm4 : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) >= 4).
{
	try assert(HOoACpMeq : rk(Oo :: A :: Cp :: M :: nil) = 4) by (apply LOoACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMmtmp : rk(Oo :: A :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACpMeq HOoACpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: M :: nil) (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: M :: nil) (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) 4 4 HOoACpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACpMNUVRM : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpMNUVRm : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HOoACpMNUVReq HOoACpMNUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpMNUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: N :: U :: V :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMNUVR requis par la preuve de (?)ACpMNUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMNUVR requis par la preuve de (?)ACpMNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMNUVR requis par la preuve de (?)ACpMNUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMNUVR requis par la preuve de (?)OoABCpMNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMNUVR requis par la preuve de (?)OoABCpMNUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMNUVRm2 : rk(Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMNUVRm3 : rk(Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMNUVR requis par la preuve de (?)ACpMNUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: N :: U :: V :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMNUVRm2 : rk(A :: Cp :: M :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMNUVRmtmp : rk(Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpMNUVReq HOoABCpMNUVRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: N :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: N :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: N :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: N :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: N :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMNUVRmtmp;try rewrite HT2 in HOoABCpMNUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: N :: U :: V :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMNUVRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMNUVRM1. try clear HOoABCpMNUVRM2. try clear HOoABCpMNUVRM3. try clear HOoABCpMNUVRm4. try clear HOoABCpMNUVRm3. try clear HOoABCpMNUVRm2. try clear HOoABCpMNUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMNUVRm3 : rk(A :: Cp :: M :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: N :: U :: V :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Cp :: M :: N :: U :: V :: R ::  de rang :  4 et 4 	 AiB : A :: N :: V ::  de rang :  3 et 3 	 A : Oo :: A :: N :: V ::   de rang : 3 et 3 *)
assert(HACpMNUVRm4 : rk(A :: Cp :: M :: N :: U :: V :: R :: nil) >= 4).
{
	try assert(HOoANVeq : rk(Oo :: A :: N :: V :: nil) = 3) by (apply LOoANV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANVMtmp : rk(Oo :: A :: N :: V :: nil) <= 3) by (solve_hyps_max HOoANVeq HOoANVM3).
	try assert(HOoACpMNUVReq : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) = 4) by (apply LOoACpMNUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMNUVRmtmp : rk(Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) >= 4) by (solve_hyps_min HOoACpMNUVReq HOoACpMNUVRm4).
	try assert(HANVeq : rk(A :: N :: V :: nil) = 3) by (apply LANV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HANVmtmp : rk(A :: N :: V :: nil) >= 3) by (solve_hyps_min HANVeq HANVm3).
	assert(Hincl : incl (A :: N :: V :: nil) (list_inter (Oo :: A :: N :: V :: nil) (A :: Cp :: M :: N :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: M :: N :: U :: V :: R :: nil) (Oo :: A :: N :: V :: A :: Cp :: M :: N :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: V :: A :: Cp :: M :: N :: U :: V :: R :: nil) ((Oo :: A :: N :: V :: nil) ++ (A :: Cp :: M :: N :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpMNUVRmtmp;try rewrite HT2 in HOoACpMNUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: N :: V :: nil) (A :: Cp :: M :: N :: U :: V :: R :: nil) (A :: N :: V :: nil) 4 3 3 HOoACpMNUVRmtmp HANVmtmp HOoANVMtmp Hincl); apply HT.
}


assert(HACpMNUVRM : rk(A :: Cp :: M :: N :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMNUVRm : rk(A :: Cp :: M :: N :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HACpMNUVReq HACpMNUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpMNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMNR requis par la preuve de (?)ACpMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMNR requis par la preuve de (?)ACpMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMNR requis par la preuve de (?)ACpMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMNR requis par la preuve de (?)OoABCpMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMNR requis par la preuve de (?)OoABCpMNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMNRm2 : rk(Oo :: A :: B :: Cp :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMNRm3 : rk(Oo :: A :: B :: Cp :: M :: N :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: N :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMNR requis par la preuve de (?)ACpMNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: N :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMNRm2 : rk(A :: Cp :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMNRmtmp : rk(Oo :: A :: B :: Cp :: M :: N :: R :: nil) >= 3) by (solve_hyps_min HOoABCpMNReq HOoABCpMNRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: N :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: N :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMNRmtmp;try rewrite HT2 in HOoABCpMNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: N :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMNRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMNRM1. try clear HOoABCpMNRM2. try clear HOoABCpMNRM3. try clear HOoABCpMNRm4. try clear HOoABCpMNRm3. try clear HOoABCpMNRm2. try clear HOoABCpMNRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMNRm3 : rk(A :: Cp :: M :: N :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: N :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Cp :: M :: N :: U :: V :: R ::  de rang :  4 et 4 	 AiB : A :: Cp :: M ::  de rang :  3 et 3 	 A : A :: Cp :: M :: U :: V ::   de rang : 3 et 3 *)
assert(HACpMNRm4 : rk(A :: Cp :: M :: N :: R :: nil) >= 4).
{
	try assert(HACpMUVeq : rk(A :: Cp :: M :: U :: V :: nil) = 3) by (apply LACpMUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMUVMtmp : rk(A :: Cp :: M :: U :: V :: nil) <= 3) by (solve_hyps_max HACpMUVeq HACpMUVM3).
	try assert(HACpMNUVReq : rk(A :: Cp :: M :: N :: U :: V :: R :: nil) = 4) by (apply LACpMNUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMNUVRmtmp : rk(A :: Cp :: M :: N :: U :: V :: R :: nil) >= 4) by (solve_hyps_min HACpMNUVReq HACpMNUVRm4).
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hincl : incl (A :: Cp :: M :: nil) (list_inter (A :: Cp :: M :: U :: V :: nil) (A :: Cp :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: N :: U :: V :: R :: nil) (A :: Cp :: M :: U :: V :: A :: Cp :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: M :: U :: V :: A :: Cp :: M :: N :: R :: nil) ((A :: Cp :: M :: U :: V :: nil) ++ (A :: Cp :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMNUVRmtmp;try rewrite HT2 in HACpMNUVRmtmp.
	assert(HT := rule_4 (A :: Cp :: M :: U :: V :: nil) (A :: Cp :: M :: N :: R :: nil) (A :: Cp :: M :: nil) 4 3 3 HACpMNUVRmtmp HACpMmtmp HACpMUVMtmp Hincl); apply HT.
}


assert(HACpMNRM : rk(A :: Cp :: M :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMNRm : rk(A :: Cp :: M :: N :: R ::  nil) >= 1) by (solve_hyps_min HACpMNReq HACpMNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NR requis par la preuve de (?)NR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Cp :: M :: N :: R ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : A :: Cp :: M :: R ::   de rang : 3 et 3 *)
assert(HNRm2 : rk(N :: R :: nil) >= 2).
{
	try assert(HACpMReq : rk(A :: Cp :: M :: R :: nil) = 3) by (apply LACpMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMRMtmp : rk(A :: Cp :: M :: R :: nil) <= 3) by (solve_hyps_max HACpMReq HACpMRM3).
	try assert(HACpMNReq : rk(A :: Cp :: M :: N :: R :: nil) = 4) by (apply LACpMNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMNRmtmp : rk(A :: Cp :: M :: N :: R :: nil) >= 4) by (solve_hyps_min HACpMNReq HACpMNRm4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (A :: Cp :: M :: R :: nil) (N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: N :: R :: nil) (A :: Cp :: M :: R :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: M :: R :: N :: R :: nil) ((A :: Cp :: M :: R :: nil) ++ (N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMNRmtmp;try rewrite HT2 in HACpMNRmtmp.
	assert(HT := rule_4 (A :: Cp :: M :: R :: nil) (N :: R :: nil) (R :: nil) 4 1 3 HACpMNRmtmp HRmtmp HACpMRMtmp Hincl); apply HT.
}


assert(HNRM : rk(N :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNReq HNRM2).
assert(HNRm : rk(N :: R ::  nil) >= 1) by (solve_hyps_min HNReq HNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpNR *)
(* dans constructLemma(), requis par LBBpCpZNR *)
(* dans la couche 0 *)
Lemma LOoBBpCpZNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: Cp :: Z :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm2 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm3 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm4 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBBpCpZNRM : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpZNRm : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HOoBBpCpZNReq HOoBBpCpZNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpCpZNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: Cp :: Z :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm2 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm3 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpCpZNR requis par la preuve de (?)OoABBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpCpZNR requis par la preuve de (?)OoABBpCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpZNRm2 : rk(Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpZNRm3 : rk(Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: Cp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HBBpCpZNRm2 : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpCpZNRmtmp : rk(Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoABBpCpZNReq HOoABBpCpZNRm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) (Oo :: A :: B :: Bp :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: B :: Bp :: Cp :: Z :: N :: R :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpCpZNRmtmp;try rewrite HT2 in HOoABBpCpZNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil) (B :: Bp :: nil) 3 2 3 HOoABBpCpZNRmtmp HBBpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpCpZNRM1. try clear HOoABBpCpZNRM2. try clear HOoABBpCpZNRM3. try clear HOoABBpCpZNRm4. try clear HOoABBpCpZNRm3. try clear HOoABBpCpZNRm2. try clear HOoABBpCpZNRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : Bp :: Cp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpCpZNRm3 : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	assert(HOoBBpCpZNRmtmp : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoBBpCpZNReq HOoBBpCpZNRm3).
	try assert(HBpCpeq : rk(Bp :: Cp :: nil) = 2) by (apply LBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpmtmp : rk(Bp :: Cp :: nil) >= 2) by (solve_hyps_min HBpCpeq HBpCpm2).
	assert(Hincl : incl (Bp :: Cp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) (Oo :: Bp :: Cp :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: Cp :: Z :: N :: R :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpZNRmtmp;try rewrite HT2 in HOoBBpCpZNRmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil) (Bp :: Cp :: nil) 3 2 2 HOoBBpCpZNRmtmp HBpCpmtmp HOoBpCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: Z :: N :: R ::  de rang :  4 et 4 	 AiB : Bp :: Cp :: N ::  de rang :  3 et 3 	 A : Oo :: Bp :: Cp :: N ::   de rang : 3 et 3 *)
assert(HBBpCpZNRm4 : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4).
{
	try assert(HOoBpCpNeq : rk(Oo :: Bp :: Cp :: N :: nil) = 3) by (apply LOoBpCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpNMtmp : rk(Oo :: Bp :: Cp :: N :: nil) <= 3) by (solve_hyps_max HOoBpCpNeq HOoBpCpNM3).
	try assert(HOoBBpCpZNReq : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) = 4) by (apply LOoBBpCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpZNRmtmp : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4) by (solve_hyps_min HOoBBpCpZNReq HOoBBpCpZNRm4).
	try assert(HBpCpNeq : rk(Bp :: Cp :: N :: nil) = 3) by (apply LBpCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpNmtmp : rk(Bp :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBpCpNeq HBpCpNm3).
	assert(Hincl : incl (Bp :: Cp :: N :: nil) (list_inter (Oo :: Bp :: Cp :: N :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) (Oo :: Bp :: Cp :: N :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: N :: B :: Bp :: Cp :: Z :: N :: R :: nil) ((Oo :: Bp :: Cp :: N :: nil) ++ (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpZNRmtmp;try rewrite HT2 in HOoBBpCpZNRmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: N :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil) (Bp :: Cp :: N :: nil) 4 3 3 HOoBBpCpZNRmtmp HBpCpNmtmp HOoBpCpNMtmp Hincl); apply HT.
}
try clear HOoBBpCpZNRM1. try clear HOoBBpCpZNRM2. try clear HOoBBpCpZNRM3. try clear HOoBBpCpZNRm4. try clear HOoBBpCpZNRm3. try clear HOoBBpCpZNRm2. try clear HOoBBpCpZNRm1. 

assert(HBBpCpZNRM : rk(B :: Bp :: Cp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpZNRm : rk(B :: Bp :: Cp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HBBpCpZNReq HBBpCpZNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpNR *)
(* dans la couche 0 *)
Lemma LBCpZNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpZNR requis par la preuve de (?)BCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ZNR requis par la preuve de (?)BCpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpZNR requis par la preuve de (?)BCpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpZNR requis par la preuve de (?)BCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpZNR requis par la preuve de (?)OoABCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpZNR requis par la preuve de (?)OoABCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNRm2 : rk(Oo :: A :: B :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNRm3 : rk(Oo :: A :: B :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpZNR requis par la preuve de (?)BCpZNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpZNRm2 : rk(B :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpZNRmtmp : rk(Oo :: A :: B :: Cp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoABCpZNReq HOoABCpZNRm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Z :: N :: R :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpZNRmtmp;try rewrite HT2 in HOoABCpZNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: R :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpZNRmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpZNRM1. try clear HOoABCpZNRM2. try clear HOoABCpZNRM3. try clear HOoABCpZNRm4. try clear HOoABCpZNRm3. try clear HOoABCpZNRm2. try clear HOoABCpZNRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HBCpZNRM3 : rk(B :: Cp :: Z :: N :: R :: nil) <= 3).
{
	try assert(HBCpZeq : rk(B :: Cp :: Z :: nil) = 2) by (apply LBCpZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZMtmp : rk(B :: Cp :: Z :: nil) <= 2) by (solve_hyps_max HBCpZeq HBCpZM2).
	assert(HZNRMtmp : rk(Z :: N :: R :: nil) <= 2) by (solve_hyps_max HZNReq HZNRM2).
	try assert(HZeq : rk(Z :: nil) = 1) by (apply LZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HZmtmp : rk(Z :: nil) >= 1) by (solve_hyps_min HZeq HZm1).
	assert(Hincl : incl (Z :: nil) (list_inter (B :: Cp :: Z :: nil) (Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: Z :: N :: R :: nil) (B :: Cp :: Z :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: Z :: Z :: N :: R :: nil) ((B :: Cp :: Z :: nil) ++ (Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Cp :: Z :: nil) (Z :: N :: R :: nil) (Z :: nil) 2 2 1 HBCpZMtmp HZNRMtmp HZmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HBCpZM1. try clear HBCpZM2. try clear HBCpZM3. try clear HBCpZm4. try clear HBCpZm3. try clear HBCpZm2. try clear HBCpZm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpZNRm3 : rk(B :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HBCpNeq : rk(B :: Cp :: N :: nil) = 3) by (apply LBCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNmtmp : rk(B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBCpNeq HBCpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: R :: nil) 3 3 HBCpNmtmp Hcomp Hincl);apply HT.
}


assert(HBCpZNRM : rk(B :: Cp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpZNRm : rk(B :: Cp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HBCpZNReq HBCpZNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNR requis par la preuve de (?)BpNR pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)BpNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm2 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm3 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm4 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpNR requis par la preuve de (?)BpNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: N :: R ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: N ::   de rang : 4 et 4 *)
assert(HBpNRm2 : rk(Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNMtmp : rk(Oo :: A :: B :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABBpNeq HOoABBpNM4).
	assert(HOoABBpNRmtmp : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 4) by (solve_hyps_min HOoABBpNReq HOoABBpNRm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: R :: nil) (Oo :: A :: B :: Bp :: N :: Bp :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Bp :: N :: R :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Bp :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNRmtmp;try rewrite HT2 in HOoABBpNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: R :: nil) (Bp :: N :: nil) 4 2 4 HOoABBpNRmtmp HBpNmtmp HOoABBpNMtmp Hincl); apply HT.
}
try clear HOoABBpNRM1. try clear HOoABBpNRM2. try clear HOoABBpNRM3. try clear HOoABBpNRm4. try clear HOoABBpNRm3. try clear HOoABBpNRm2. try clear HOoABBpNRm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpNRm3 : rk(Bp :: N :: R :: nil) >= 3).
{
	try assert(HBCpZNReq : rk(B :: Cp :: Z :: N :: R :: nil) = 3) by (apply LBCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNRMtmp : rk(B :: Cp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HBCpZNReq HBCpZNRM3).
	try assert(HBBpCpZNReq : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) = 4) by (apply LBBpCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpCpZNRmtmp : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4) by (solve_hyps_min HBBpCpZNReq HBBpCpZNRm4).
	try assert(HNReq : rk(N :: R :: nil) = 2) by (apply LNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNRmtmp : rk(N :: R :: nil) >= 2) by (solve_hyps_min HNReq HNRm2).
	assert(Hincl : incl (N :: R :: nil) (list_inter (Bp :: N :: R :: nil) (B :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: Z :: N :: R :: nil) (Bp :: N :: R :: B :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: R :: B :: Cp :: Z :: N :: R :: nil) ((Bp :: N :: R :: nil) ++ (B :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpZNRmtmp;try rewrite HT2 in HBBpCpZNRmtmp.
	assert(HT := rule_2 (Bp :: N :: R :: nil) (B :: Cp :: Z :: N :: R :: nil) (N :: R :: nil) 4 2 3 HBBpCpZNRmtmp HNRmtmp HBCpZNRMtmp Hincl);apply HT.
}
try clear HNRM1. try clear HNRM2. try clear HNRM3. try clear HNRm4. try clear HNRm3. try clear HNRm2. try clear HNRm1. 

assert(HBpNRM : rk(Bp :: N :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpNReq HBpNRM3).
assert(HBpNRm : rk(Bp :: N :: R ::  nil) >= 1) by (solve_hyps_min HBpNReq HBpNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm2 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm3 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm4 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpNRM : rk(Oo :: A :: B :: Bp :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNRm : rk(Oo :: A :: B :: Bp :: N :: R ::  nil) >= 1) by (solve_hyps_min HOoABBpNReq HOoABBpNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpNR requis par la preuve de (?)CBpNR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNR requis par la preuve de (?)CBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNR requis par la preuve de (?)CBpNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNR requis par la preuve de (?)OoACBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNR requis par la preuve de (?)OoACBpNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNRm2 : rk(Oo :: A :: C :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNRm3 : rk(Oo :: A :: C :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNR requis par la preuve de (?)CBpNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNRm2 : rk(C :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNRmtmp : rk(Oo :: A :: C :: Bp :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACBpNReq HOoACBpNRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNRmtmp;try rewrite HT2 in HOoACBpNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpNRM1. try clear HOoACBpNRM2. try clear HOoACBpNRM3. try clear HOoACBpNRm4. try clear HOoACBpNRm3. try clear HOoACBpNRm2. try clear HOoACBpNRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNRm3 : rk(C :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: N :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNRM3 : rk(C :: Bp :: N :: R :: nil) <= 3).
{
	try assert(HCBpZNReq : rk(C :: Bp :: Z :: N :: R :: nil) = 3) by (apply LCBpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNRMtmp : rk(C :: Bp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpZNReq HCBpZNRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: R :: nil) (C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Bp :: N :: R :: nil) (C :: Bp :: Z :: N :: R :: nil) 3 3 HCBpZNRMtmp Hcomp Hincl);apply HT.
}


assert(HCBpNRM : rk(C :: Bp :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNRm : rk(C :: Bp :: N :: R ::  nil) >= 1) by (solve_hyps_min HCBpNReq HCBpNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LZNR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Z :: N :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

assert(HZNRM : rk(Z :: N :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HZNReq HZNRM3).
assert(HZNRm : rk(Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HZNReq HZNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSpR *)
(* dans constructLemma(), requis par LCApSpR *)
(* dans constructLemma(), requis par LCApMSpR *)
(* dans la couche 0 *)
Lemma LApMSpR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Sp :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMSpR requis par la preuve de (?)ApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMSpR requis par la preuve de (?)ApMSpR pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)ApMSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMSpR requis par la preuve de (?)ApMSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: Sp :: R ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMSpRm2 : rk(Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMSpRmtmp : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 4) by (solve_hyps_min HOoABApMSpReq HOoABApMSpRm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: R :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMSpRmtmp;try rewrite HT2 in HOoABApMSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: R :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMSpRmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMSpRM1. try clear HOoABApMSpRM2. try clear HOoABApMSpRM3. try clear HOoABApMSpRm4. try clear HOoABApMSpRm3. try clear HOoABApMSpRm2. try clear HOoABApMSpRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApMSpRM3 : rk(Ap :: M :: Sp :: R :: nil) <= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: M :: Sp :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: Sp :: R :: nil) (Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: R :: nil) ((Ap :: M :: Sp :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Sp :: nil) (R :: nil) (nil) 2 1 0 HApMSpMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApMSpRm3 : rk(Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HApMReq : rk(Ap :: M :: R :: nil) = 3) by (apply LApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMRmtmp : rk(Ap :: M :: R :: nil) >= 3) by (solve_hyps_min HApMReq HApMRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil) 3 3 HApMRmtmp Hcomp Hincl);apply HT.
}


assert(HApMSpRM : rk(Ap :: M :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApMSpRm : rk(Ap :: M :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HApMSpReq HApMSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMSpR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: Sp :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMSpR requis par la preuve de (?)CApMSpR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMSpR requis par la preuve de (?)CApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMSpR requis par la preuve de (?)CApMSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMSpR requis par la preuve de (?)OoACApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMSpR requis par la preuve de (?)OoACApMSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpRm2 : rk(Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpRm3 : rk(Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMSpR requis par la preuve de (?)CApMSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMSpRm2 : rk(C :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMSpRmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACApMSpReq HOoACApMSpRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpRmtmp;try rewrite HT2 in HOoACApMSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMSpRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMSpRM1. try clear HOoACApMSpRM2. try clear HOoACApMSpRM3. try clear HOoACApMSpRm4. try clear HOoACApMSpRm3. try clear HOoACApMSpRm2. try clear HOoACApMSpRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMSpRm3 : rk(C :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCApMSpRM3 : rk(C :: Ap :: M :: Sp :: R :: nil) <= 3).
{
	try assert(HCApMReq : rk(C :: Ap :: M :: R :: nil) = 3) by (apply LCApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMRMtmp : rk(C :: Ap :: M :: R :: nil) <= 3) by (solve_hyps_max HCApMReq HCApMRM3).
	try assert(HApMSpReq : rk(Ap :: M :: Sp :: R :: nil) = 3) by (apply LApMSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpRMtmp : rk(Ap :: M :: Sp :: R :: nil) <= 3) by (solve_hyps_max HApMSpReq HApMSpRM3).
	try assert(HApMReq : rk(Ap :: M :: R :: nil) = 3) by (apply LApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMRmtmp : rk(Ap :: M :: R :: nil) >= 3) by (solve_hyps_min HApMReq HApMRm3).
	assert(Hincl : incl (Ap :: M :: R :: nil) (list_inter (C :: Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: R :: nil) (C :: Ap :: M :: R :: Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: R :: Ap :: M :: Sp :: R :: nil) ((C :: Ap :: M :: R :: nil) ++ (Ap :: M :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil) (Ap :: M :: R :: nil) 3 3 3 HCApMRMtmp HApMSpRMtmp HApMRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCApMSpRM : rk(C :: Ap :: M :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMSpRm : rk(C :: Ap :: M :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCApMSpReq HCApMSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApSpR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Sp :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApSpR requis par la preuve de (?)CApSpR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApSpR requis par la preuve de (?)CApSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApSpR requis par la preuve de (?)CApSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApSpR requis par la preuve de (?)OoACApSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApSpR requis par la preuve de (?)OoACApSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpRm2 : rk(Oo :: A :: C :: Ap :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpRm3 : rk(Oo :: A :: C :: Ap :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApSpR requis par la preuve de (?)CApSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApSpRm2 : rk(C :: Ap :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApSpRmtmp : rk(Oo :: A :: C :: Ap :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACApSpReq HOoACApSpRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Sp :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApSpRmtmp;try rewrite HT2 in HOoACApSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApSpRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApSpRM1. try clear HOoACApSpRM2. try clear HOoACApSpRM3. try clear HOoACApSpRm4. try clear HOoACApSpRm3. try clear HOoACApSpRm2. try clear HOoACApSpRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApSpRm3 : rk(C :: Ap :: Sp :: R :: nil) >= 3).
{
	try assert(HCApSpeq : rk(C :: Ap :: Sp :: nil) = 3) by (apply LCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApSpmtmp : rk(C :: Ap :: Sp :: nil) >= 3) by (solve_hyps_min HCApSpeq HCApSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Sp :: nil) (C :: Ap :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: Sp :: nil) (C :: Ap :: Sp :: R :: nil) 3 3 HCApSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApSpRM3 : rk(C :: Ap :: Sp :: R :: nil) <= 3).
{
	try assert(HCApMSpReq : rk(C :: Ap :: M :: Sp :: R :: nil) = 3) by (apply LCApMSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpRMtmp : rk(C :: Ap :: M :: Sp :: R :: nil) <= 3) by (solve_hyps_max HCApMSpReq HCApMSpRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Sp :: R :: nil) (C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: Sp :: R :: nil) (C :: Ap :: M :: Sp :: R :: nil) 3 3 HCApMSpRMtmp Hcomp Hincl);apply HT.
}


assert(HCApSpRM : rk(C :: Ap :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApSpRm : rk(C :: Ap :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCApSpReq HCApSpRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSpR *)
(* dans constructLemma(), requis par LCBpZNSpTR *)
(* dans la couche 0 *)
Lemma LCBpZNTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: N :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZNTR requis par la preuve de (?)OoACBpZNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZNTR requis par la preuve de (?)OoACBpZNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNTRm2 : rk(Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNTRm3 : rk(Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: N :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZNTRm2 : rk(C :: Bp :: Z :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZNTRmtmp : rk(Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZNTReq HOoACBpZNTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZNTRmtmp;try rewrite HT2 in HOoACBpZNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZNTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZNTRM1. try clear HOoACBpZNTRM2. try clear HOoACBpZNTRM3. try clear HOoACBpZNTRm4. try clear HOoACBpZNTRm3. try clear HOoACBpZNTRm2. try clear HOoACBpZNTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZNTRm3 : rk(C :: Bp :: Z :: N :: T :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: T :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpZNTRM3 : rk(C :: Bp :: Z :: N :: T :: R :: nil) <= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HCBpZNReq : rk(C :: Bp :: Z :: N :: R :: nil) = 3) by (apply LCBpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNRMtmp : rk(C :: Bp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpZNReq HCBpZNRM3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Bp :: N :: T :: nil) (C :: Bp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: N :: T :: R :: nil) (Bp :: N :: T :: C :: Bp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: C :: Bp :: Z :: N :: R :: nil) ((Bp :: N :: T :: nil) ++ (C :: Bp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: T :: nil) (C :: Bp :: Z :: N :: R :: nil) (Bp :: N :: nil) 2 3 2 HBpNTMtmp HCBpZNRMtmp HBpNmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpZNTRM : rk(C :: Bp :: Z :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZNTRm : rk(C :: Bp :: Z :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpZNTReq HCBpZNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: N :: Sp :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZNSpTR requis par la preuve de (?)OoACBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZNSpTR requis par la preuve de (?)OoACBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNSpTRm2 : rk(Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNSpTRm3 : rk(Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZNSpTRm2 : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZNSpTRmtmp : rk(Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZNSpTReq HOoACBpZNSpTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZNSpTRmtmp;try rewrite HT2 in HOoACBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZNSpTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZNSpTRM1. try clear HOoACBpZNSpTRM2. try clear HOoACBpZNSpTRM3. try clear HOoACBpZNSpTRm4. try clear HOoACBpZNSpTRm3. try clear HOoACBpZNSpTRm2. try clear HOoACBpZNSpTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZNSpTRm3 : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpZNSpTRM3 : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) <= 3).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HCBpZNTReq : rk(C :: Bp :: Z :: N :: T :: R :: nil) = 3) by (apply LCBpZNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNTRMtmp : rk(C :: Bp :: Z :: N :: T :: R :: nil) <= 3) by (solve_hyps_max HCBpZNTReq HCBpZNTRM3).
	try assert(HCTeq : rk(C :: T :: nil) = 2) by (apply LCT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCTmtmp : rk(C :: T :: nil) >= 2) by (solve_hyps_min HCTeq HCTm2).
	assert(Hincl : incl (C :: T :: nil) (list_inter (C :: Sp :: T :: nil) (C :: Bp :: Z :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Sp :: T :: C :: Bp :: Z :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: T :: C :: Bp :: Z :: N :: T :: R :: nil) ((C :: Sp :: T :: nil) ++ (C :: Bp :: Z :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Sp :: T :: nil) (C :: Bp :: Z :: N :: T :: R :: nil) (C :: T :: nil) 2 3 2 HCSpTMtmp HCBpZNTRMtmp HCTmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpZNSpTRM : rk(C :: Bp :: Z :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZNSpTRm : rk(C :: Bp :: Z :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpZNSpTReq HCBpZNSpTRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSpR *)
(* dans constructLemma(), requis par LCApBpZNSpTR *)
(* dans la couche 0 *)
Lemma LOoCApBpZNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm2 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm3 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm4 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 4 4 HOoCApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpZNSpTRM : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpZNSpTRm : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoCApBpZNSpTReq HOoCApBpZNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpZNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm2 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm3 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpZNSpTR requis par la preuve de (?)OoACApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpZNSpTR requis par la preuve de (?)OoACApBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpZNSpTRm2 : rk(Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpZNSpTRm3 : rk(Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpZNSpTRm2 : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpZNSpTRmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApBpZNSpTReq HOoACApBpZNSpTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpZNSpTRmtmp;try rewrite HT2 in HOoACApBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpZNSpTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpZNSpTRM1. try clear HOoACApBpZNSpTRM2. try clear HOoACApBpZNSpTRM3. try clear HOoACApBpZNSpTRm4. try clear HOoACApBpZNSpTRm3. try clear HOoACApBpZNSpTRm2. try clear HOoACApBpZNSpTRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpZNSpTRm3 : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpZNSpTRmtmp : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoCApBpZNSpTReq HOoCApBpZNSpTRm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpZNSpTRmtmp;try rewrite HT2 in HOoCApBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpZNSpTRmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HCApBpZNSpTRm4 : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	try assert(HOoCApBpZNSpTReq : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) = 4) by (apply LOoCApBpZNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpZNSpTRmtmp : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HOoCApBpZNSpTReq HOoCApBpZNSpTRm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpZNSpTRmtmp;try rewrite HT2 in HOoCApBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Ap :: Bp :: N :: nil) 4 3 3 HOoCApBpZNSpTRmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoCApBpZNSpTRM1. try clear HOoCApBpZNSpTRM2. try clear HOoCApBpZNSpTRM3. try clear HOoCApBpZNSpTRm4. try clear HOoCApBpZNSpTRm3. try clear HOoCApBpZNSpTRm2. try clear HOoCApBpZNSpTRm1. 

assert(HCApBpZNSpTRM : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpZNSpTRm : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApBpZNSpTReq HCApBpZNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCSpR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Sp :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CSpR requis par la preuve de (?)CSpR pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACSpR requis par la preuve de (?)CSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACSpR requis par la preuve de (?)OoACSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACSpR requis par la preuve de (?)OoACSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACSpRm2 : rk(Oo :: A :: C :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACSpRm3 : rk(Oo :: A :: C :: Sp :: R :: nil) >= 3).
{
	try assert(HOoASpeq : rk(Oo :: A :: Sp :: nil) = 3) by (apply LOoASp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoASpmtmp : rk(Oo :: A :: Sp :: nil) >= 3) by (solve_hyps_min HOoASpeq HOoASpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Sp :: nil) (Oo :: A :: C :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Sp :: nil) (Oo :: A :: C :: Sp :: R :: nil) 3 3 HOoASpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CSpR requis par la preuve de (?)CSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Sp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Sp ::   de rang : 3 et 3 *)
assert(HCSpRm2 : rk(C :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACSpeq : rk(Oo :: A :: C :: Sp :: nil) = 3) by (apply LOoACSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACSpMtmp : rk(Oo :: A :: C :: Sp :: nil) <= 3) by (solve_hyps_max HOoACSpeq HOoACSpM3).
	assert(HOoACSpRmtmp : rk(Oo :: A :: C :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACSpReq HOoACSpRm3).
	try assert(HCSpeq : rk(C :: Sp :: nil) = 2) by (apply LCSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpmtmp : rk(C :: Sp :: nil) >= 2) by (solve_hyps_min HCSpeq HCSpm2).
	assert(Hincl : incl (C :: Sp :: nil) (list_inter (Oo :: A :: C :: Sp :: nil) (C :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Sp :: R :: nil) (Oo :: A :: C :: Sp :: C :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Sp :: C :: Sp :: R :: nil) ((Oo :: A :: C :: Sp :: nil) ++ (C :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACSpRmtmp;try rewrite HT2 in HOoACSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Sp :: nil) (C :: Sp :: R :: nil) (C :: Sp :: nil) 3 2 3 HOoACSpRmtmp HCSpmtmp HOoACSpMtmp Hincl); apply HT.
}
try clear HCSpM1. try clear HCSpM2. try clear HCSpM3. try clear HCSpm4. try clear HCSpm3. try clear HCSpm2. try clear HCSpm1. try clear HOoACSpRM1. try clear HOoACSpRM2. try clear HOoACSpRM3. try clear HOoACSpRm4. try clear HOoACSpRm3. try clear HOoACSpRm2. try clear HOoACSpRm1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HCSpRM2 : rk(C :: Sp :: R :: nil) <= 2).
{
	try assert(HCApSpReq : rk(C :: Ap :: Sp :: R :: nil) = 3) by (apply LCApSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApSpRMtmp : rk(C :: Ap :: Sp :: R :: nil) <= 3) by (solve_hyps_max HCApSpReq HCApSpRM3).
	try assert(HCBpZNSpTReq : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) = 3) by (apply LCBpZNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNSpTRMtmp : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) <= 3) by (solve_hyps_max HCBpZNSpTReq HCBpZNSpTRM3).
	try assert(HCApBpZNSpTReq : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) = 4) by (apply LCApBpZNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpZNSpTRmtmp : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HCApBpZNSpTReq HCApBpZNSpTRm4).
	assert(Hincl : incl (C :: Sp :: R :: nil) (list_inter (C :: Ap :: Sp :: R :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Ap :: Sp :: R :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Sp :: R :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((C :: Ap :: Sp :: R :: nil) ++ (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpZNSpTRmtmp;try rewrite HT2 in HCApBpZNSpTRmtmp.
	assert(HT := rule_3 (C :: Ap :: Sp :: R :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Sp :: R :: nil) 3 3 4 HCApSpRMtmp HCBpZNSpTRMtmp HCApBpZNSpTRmtmp Hincl);apply HT.
}


assert(HCSpRM : rk(C :: Sp :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCSpReq HCSpRM3).
assert(HCSpRm : rk(C :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCSpReq HCSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMSpR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: Sp :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMSpRM : rk(Oo :: A :: B :: Ap :: M :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMSpRm : rk(Oo :: A :: B :: Ap :: M :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HOoABApMSpReq HOoABApMSpRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCTR *)
(* dans constructLemma(), requis par LCApTR *)
(* dans la couche 0 *)
Lemma LCApYMTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Y :: M :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApYMTR requis par la preuve de (?)CApYMTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApYMTR requis par la preuve de (?)CApYMTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApYMTR requis par la preuve de (?)CApYMTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApYMTR requis par la preuve de (?)OoACApYMTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApYMTR requis par la preuve de (?)OoACApYMTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMTRm2 : rk(Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMTRm3 : rk(Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApYMTR requis par la preuve de (?)CApYMTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Y :: M :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApYMTRm2 : rk(C :: Ap :: Y :: M :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApYMTRmtmp : rk(Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApYMTReq HOoACApYMTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Y :: M :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApYMTRmtmp;try rewrite HT2 in HOoACApYMTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApYMTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApYMTRM1. try clear HOoACApYMTRM2. try clear HOoACApYMTRM3. try clear HOoACApYMTRm4. try clear HOoACApYMTRm3. try clear HOoACApYMTRm2. try clear HOoACApYMTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApYMTRm3 : rk(C :: Ap :: Y :: M :: T :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: T :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCApYMTRM3 : rk(C :: Ap :: Y :: M :: T :: R :: nil) <= 3).
{
	try assert(HCApMTeq : rk(C :: Ap :: M :: T :: nil) = 3) by (apply LCApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMTMtmp : rk(C :: Ap :: M :: T :: nil) <= 3) by (solve_hyps_max HCApMTeq HCApMTM3).
	try assert(HCApYMReq : rk(C :: Ap :: Y :: M :: R :: nil) = 3) by (apply LCApYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMRMtmp : rk(C :: Ap :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HCApYMReq HCApYMRM3).
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hincl : incl (C :: Ap :: M :: nil) (list_inter (C :: Ap :: M :: T :: nil) (C :: Ap :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Y :: M :: T :: R :: nil) (C :: Ap :: M :: T :: C :: Ap :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: T :: C :: Ap :: Y :: M :: R :: nil) ((C :: Ap :: M :: T :: nil) ++ (C :: Ap :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: M :: T :: nil) (C :: Ap :: Y :: M :: R :: nil) (C :: Ap :: M :: nil) 3 3 3 HCApMTMtmp HCApYMRMtmp HCApMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCApYMTRM : rk(C :: Ap :: Y :: M :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApYMTRm : rk(C :: Ap :: Y :: M :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApYMTReq HCApYMTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApTR requis par la preuve de (?)CApTR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApTR requis par la preuve de (?)CApTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApTR requis par la preuve de (?)CApTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApTR requis par la preuve de (?)OoACApTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApTR requis par la preuve de (?)OoACApTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTRm2 : rk(Oo :: A :: C :: Ap :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTRm3 : rk(Oo :: A :: C :: Ap :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApTR requis par la preuve de (?)CApTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApTRm2 : rk(C :: Ap :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApTRmtmp : rk(Oo :: A :: C :: Ap :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApTReq HOoACApTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApTRmtmp;try rewrite HT2 in HOoACApTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApTRM1. try clear HOoACApTRM2. try clear HOoACApTRM3. try clear HOoACApTRm4. try clear HOoACApTRm3. try clear HOoACApTRm2. try clear HOoACApTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApTRm3 : rk(C :: Ap :: T :: R :: nil) >= 3).
{
	try assert(HCApTeq : rk(C :: Ap :: T :: nil) = 3) by (apply LCApT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApTmtmp : rk(C :: Ap :: T :: nil) >= 3) by (solve_hyps_min HCApTeq HCApTm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: T :: nil) (C :: Ap :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: T :: nil) (C :: Ap :: T :: R :: nil) 3 3 HCApTmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApTRM3 : rk(C :: Ap :: T :: R :: nil) <= 3).
{
	try assert(HCApYMTReq : rk(C :: Ap :: Y :: M :: T :: R :: nil) = 3) by (apply LCApYMTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMTRMtmp : rk(C :: Ap :: Y :: M :: T :: R :: nil) <= 3) by (solve_hyps_max HCApYMTReq HCApYMTRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: T :: R :: nil) (C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: T :: R :: nil) (C :: Ap :: Y :: M :: T :: R :: nil) 3 3 HCApYMTRMtmp Hcomp Hincl);apply HT.
}


assert(HCApTRM : rk(C :: Ap :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApTRm : rk(C :: Ap :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApTReq HCApTRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCTR *)
(* dans constructLemma(), requis par LCBpNTR *)
(* dans la couche 0 *)
Lemma LBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNTR requis par la preuve de (?)BpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpNTR requis par la preuve de (?)BpNTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)BpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm2 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm3 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm4 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpNTR requis par la preuve de (?)BpNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: N :: T :: R ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: N ::   de rang : 4 et 4 *)
assert(HBpNTRm2 : rk(Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNMtmp : rk(Oo :: A :: B :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABBpNeq HOoABBpNM4).
	assert(HOoABBpNTRmtmp : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 4) by (solve_hyps_min HOoABBpNTReq HOoABBpNTRm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: T :: R :: nil) (Oo :: A :: B :: Bp :: N :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Bp :: N :: T :: R :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNTRmtmp;try rewrite HT2 in HOoABBpNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: T :: R :: nil) (Bp :: N :: nil) 4 2 4 HOoABBpNTRmtmp HBpNmtmp HOoABBpNMtmp Hincl); apply HT.
}
try clear HOoABBpNTRM1. try clear HOoABBpNTRM2. try clear HOoABBpNTRM3. try clear HOoABBpNTRm4. try clear HOoABBpNTRm3. try clear HOoABBpNTRm2. try clear HOoABBpNTRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpNTRM3 : rk(Bp :: N :: T :: R :: nil) <= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: N :: T :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: N :: T :: R :: nil) (Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: R :: nil) ((Bp :: N :: T :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: T :: nil) (R :: nil) (nil) 2 1 0 HBpNTMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpNTRm3 : rk(Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HBpNReq : rk(Bp :: N :: R :: nil) = 3) by (apply LBpNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNRmtmp : rk(Bp :: N :: R :: nil) >= 3) by (solve_hyps_min HBpNReq HBpNRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil) 3 3 HBpNRmtmp Hcomp Hincl);apply HT.
}


assert(HBpNTRM : rk(Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpNTRm : rk(Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HBpNTReq HBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpNTR requis par la preuve de (?)CBpNTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNTR requis par la preuve de (?)CBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNTR requis par la preuve de (?)CBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNTR requis par la preuve de (?)OoACBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNTR requis par la preuve de (?)OoACBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNTRm2 : rk(Oo :: A :: C :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNTRm3 : rk(Oo :: A :: C :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNTR requis par la preuve de (?)CBpNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNTRm2 : rk(C :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNTRmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpNTReq HOoACBpNTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTRmtmp;try rewrite HT2 in HOoACBpNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpNTRM1. try clear HOoACBpNTRM2. try clear HOoACBpNTRM3. try clear HOoACBpNTRm4. try clear HOoACBpNTRm3. try clear HOoACBpNTRm2. try clear HOoACBpNTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNTRm3 : rk(C :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: N :: T :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpNTRM3 : rk(C :: Bp :: N :: T :: R :: nil) <= 3).
{
	try assert(HCBpNReq : rk(C :: Bp :: N :: R :: nil) = 3) by (apply LCBpNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNRMtmp : rk(C :: Bp :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpNReq HCBpNRM3).
	try assert(HBpNTReq : rk(Bp :: N :: T :: R :: nil) = 3) by (apply LBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTRMtmp : rk(Bp :: N :: T :: R :: nil) <= 3) by (solve_hyps_max HBpNTReq HBpNTRM3).
	try assert(HBpNReq : rk(Bp :: N :: R :: nil) = 3) by (apply LBpNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNRmtmp : rk(Bp :: N :: R :: nil) >= 3) by (solve_hyps_min HBpNReq HBpNRm3).
	assert(Hincl : incl (Bp :: N :: R :: nil) (list_inter (C :: Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: T :: R :: nil) (C :: Bp :: N :: R :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: R :: Bp :: N :: T :: R :: nil) ((C :: Bp :: N :: R :: nil) ++ (Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil) (Bp :: N :: R :: nil) 3 3 3 HCBpNRMtmp HBpNTRMtmp HBpNRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpNTRM : rk(C :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNTRm : rk(C :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpNTReq HCBpNTRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCTR *)
(* dans constructLemma(), requis par LCApBpNTR *)
(* dans la couche 0 *)
Lemma LOoCApBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: N :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm2 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm3 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm4 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 4 4 HOoCApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpNTRM : rk(Oo :: C :: Ap :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpNTRm : rk(Oo :: C :: Ap :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoCApBpNTReq HOoCApBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: N :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm2 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm3 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpNTR requis par la preuve de (?)OoACApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpNTR requis par la preuve de (?)OoACApBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNTRm2 : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNTRm3 : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: N :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpNTRm2 : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpNTRmtmp : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApBpNTReq HOoACApBpNTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpNTRmtmp;try rewrite HT2 in HOoACApBpNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpNTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpNTRM1. try clear HOoACApBpNTRM2. try clear HOoACApBpNTRM3. try clear HOoACApBpNTRm4. try clear HOoACApBpNTRm3. try clear HOoACApBpNTRm2. try clear HOoACApBpNTRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: T :: R ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpNTRm3 : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpNTRmtmp : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoCApBpNTReq HOoCApBpNTRm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: T :: R :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNTRmtmp;try rewrite HT2 in HOoCApBpNTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpNTRmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: T :: R ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HCApBpNTRm4 : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	try assert(HOoCApBpNTReq : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) = 4) by (apply LOoCApBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpNTRmtmp : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 4) by (solve_hyps_min HOoCApBpNTReq HOoCApBpNTRm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: T :: R :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (C :: Ap :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNTRmtmp;try rewrite HT2 in HOoCApBpNTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil) (Ap :: Bp :: N :: nil) 4 3 3 HOoCApBpNTRmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoCApBpNTRM1. try clear HOoCApBpNTRM2. try clear HOoCApBpNTRM3. try clear HOoCApBpNTRm4. try clear HOoCApBpNTRm3. try clear HOoCApBpNTRm2. try clear HOoCApBpNTRm1. 

assert(HCApBpNTRM : rk(C :: Ap :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpNTRm : rk(C :: Ap :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApBpNTReq HCApBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: T :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CTR requis par la preuve de (?)CTR pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACTR requis par la preuve de (?)CTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACTR requis par la preuve de (?)OoACTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACTR requis par la preuve de (?)OoACTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACTRm2 : rk(Oo :: A :: C :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACTRm3 : rk(Oo :: A :: C :: T :: R :: nil) >= 3).
{
	try assert(HOoATeq : rk(Oo :: A :: T :: nil) = 3) by (apply LOoAT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoATmtmp : rk(Oo :: A :: T :: nil) >= 3) by (solve_hyps_min HOoATeq HOoATm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: T :: nil) (Oo :: A :: C :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: T :: nil) (Oo :: A :: C :: T :: R :: nil) 3 3 HOoATmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CTR requis par la preuve de (?)CTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: T :: R ::  de rang :  3 et 4 	 AiB : C :: T ::  de rang :  2 et 2 	 A : Oo :: A :: C :: T ::   de rang : 3 et 3 *)
assert(HCTRm2 : rk(C :: T :: R :: nil) >= 2).
{
	try assert(HOoACTeq : rk(Oo :: A :: C :: T :: nil) = 3) by (apply LOoACT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACTMtmp : rk(Oo :: A :: C :: T :: nil) <= 3) by (solve_hyps_max HOoACTeq HOoACTM3).
	assert(HOoACTRmtmp : rk(Oo :: A :: C :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACTReq HOoACTRm3).
	try assert(HCTeq : rk(C :: T :: nil) = 2) by (apply LCT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCTmtmp : rk(C :: T :: nil) >= 2) by (solve_hyps_min HCTeq HCTm2).
	assert(Hincl : incl (C :: T :: nil) (list_inter (Oo :: A :: C :: T :: nil) (C :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: T :: R :: nil) (Oo :: A :: C :: T :: C :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: T :: C :: T :: R :: nil) ((Oo :: A :: C :: T :: nil) ++ (C :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACTRmtmp;try rewrite HT2 in HOoACTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: T :: nil) (C :: T :: R :: nil) (C :: T :: nil) 3 2 3 HOoACTRmtmp HCTmtmp HOoACTMtmp Hincl); apply HT.
}
try clear HCTM1. try clear HCTM2. try clear HCTM3. try clear HCTm4. try clear HCTm3. try clear HCTm2. try clear HCTm1. try clear HOoACTRM1. try clear HOoACTRM2. try clear HOoACTRM3. try clear HOoACTRm4. try clear HOoACTRm3. try clear HOoACTRm2. try clear HOoACTRm1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HCTRM2 : rk(C :: T :: R :: nil) <= 2).
{
	try assert(HCApTReq : rk(C :: Ap :: T :: R :: nil) = 3) by (apply LCApTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApTRMtmp : rk(C :: Ap :: T :: R :: nil) <= 3) by (solve_hyps_max HCApTReq HCApTRM3).
	try assert(HCBpNTReq : rk(C :: Bp :: N :: T :: R :: nil) = 3) by (apply LCBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNTRMtmp : rk(C :: Bp :: N :: T :: R :: nil) <= 3) by (solve_hyps_max HCBpNTReq HCBpNTRM3).
	try assert(HCApBpNTReq : rk(C :: Ap :: Bp :: N :: T :: R :: nil) = 4) by (apply LCApBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpNTRmtmp : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 4) by (solve_hyps_min HCApBpNTReq HCApBpNTRm4).
	assert(Hincl : incl (C :: T :: R :: nil) (list_inter (C :: Ap :: T :: R :: nil) (C :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: N :: T :: R :: nil) (C :: Ap :: T :: R :: C :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: T :: R :: C :: Bp :: N :: T :: R :: nil) ((C :: Ap :: T :: R :: nil) ++ (C :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpNTRmtmp;try rewrite HT2 in HCApBpNTRmtmp.
	assert(HT := rule_3 (C :: Ap :: T :: R :: nil) (C :: Bp :: N :: T :: R :: nil) (C :: T :: R :: nil) 3 3 4 HCApTRMtmp HCBpNTRMtmp HCApBpNTRmtmp Hincl);apply HT.
}


assert(HCTRM : rk(C :: T :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCTReq HCTRM3).
assert(HCTRm : rk(C :: T :: R ::  nil) >= 1) by (solve_hyps_min HCTReq HCTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm2 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm3 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm4 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpNTRM : rk(Oo :: A :: B :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNTRm : rk(Oo :: A :: B :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoABBpNTReq HOoABBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpYMUR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y :: M :: U :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpYMUR requis par la preuve de (?)ACpYMUR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYMUR requis par la preuve de (?)ACpYMUR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYMUR requis par la preuve de (?)ACpYMUR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYMUR requis par la preuve de (?)OoABCpYMUR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYMUR requis par la preuve de (?)OoABCpYMUR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMURm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMURm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYMUR requis par la preuve de (?)ACpYMUR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M :: U :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMURm2 : rk(A :: Cp :: Y :: M :: U :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMURmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) >= 3) by (solve_hyps_min HOoABCpYMUReq HOoABCpYMURm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: U :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMURmtmp;try rewrite HT2 in HOoABCpYMURmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMURmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMURM1. try clear HOoABCpYMURM2. try clear HOoABCpYMURM3. try clear HOoABCpYMURm4. try clear HOoABCpYMURm3. try clear HOoABCpYMURm2. try clear HOoABCpYMURm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMURm3 : rk(A :: Cp :: Y :: M :: U :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACpYMURM3 : rk(A :: Cp :: Y :: M :: U :: R :: nil) <= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (A :: M :: U :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: U :: R :: nil) (A :: M :: U :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: U :: A :: Cp :: Y :: M :: R :: nil) ((A :: M :: U :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: M :: U :: nil) (A :: Cp :: Y :: M :: R :: nil) (A :: M :: nil) 2 3 2 HAMUMtmp HACpYMRMtmp HAMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HAMM1. try clear HAMM2. try clear HAMM3. try clear HAMm4. try clear HAMm3. try clear HAMm2. try clear HAMm1. 

assert(HACpYMURM : rk(A :: Cp :: Y :: M :: U :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMURm : rk(A :: Cp :: Y :: M :: U :: R ::  nil) >= 1) by (solve_hyps_min HACpYMUReq HACpYMURm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpZNVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z :: N :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpZNVR requis par la preuve de (?)OoABCpZNVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpZNVR requis par la preuve de (?)OoABCpZNVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNVRm2 : rk(Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNVRm3 : rk(Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Z :: N :: V :: R ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpZNVRm2 : rk(B :: Cp :: Z :: N :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpZNVRmtmp : rk(Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpZNVReq HOoABCpZNVRm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: Z :: N :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpZNVRmtmp;try rewrite HT2 in HOoABCpZNVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: V :: R :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpZNVRmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpZNVRM1. try clear HOoABCpZNVRM2. try clear HOoABCpZNVRM3. try clear HOoABCpZNVRm4. try clear HOoABCpZNVRm3. try clear HOoABCpZNVRm2. try clear HOoABCpZNVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpZNVRm3 : rk(B :: Cp :: Z :: N :: V :: R :: nil) >= 3).
{
	try assert(HBCpNeq : rk(B :: Cp :: N :: nil) = 3) by (apply LBCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNmtmp : rk(B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBCpNeq HBCpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: V :: R :: nil) 3 3 HBCpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCpZNVRM3 : rk(B :: Cp :: Z :: N :: V :: R :: nil) <= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBCpZNReq : rk(B :: Cp :: Z :: N :: R :: nil) = 3) by (apply LBCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNRMtmp : rk(B :: Cp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HBCpZNReq HBCpZNRM3).
	try assert(HBNeq : rk(B :: N :: nil) = 2) by (apply LBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNmtmp : rk(B :: N :: nil) >= 2) by (solve_hyps_min HBNeq HBNm2).
	assert(Hincl : incl (B :: N :: nil) (list_inter (B :: N :: V :: nil) (B :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: Z :: N :: V :: R :: nil) (B :: N :: V :: B :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: N :: V :: B :: Cp :: Z :: N :: R :: nil) ((B :: N :: V :: nil) ++ (B :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: N :: V :: nil) (B :: Cp :: Z :: N :: R :: nil) (B :: N :: nil) 2 3 2 HBNVMtmp HBCpZNRMtmp HBNmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HBNM1. try clear HBNM2. try clear HBNM3. try clear HBNm4. try clear HBNm3. try clear HBNm2. try clear HBNm1. 

assert(HBCpZNVRM : rk(B :: Cp :: Z :: N :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpZNVRm : rk(B :: Cp :: Z :: N :: V :: R ::  nil) >= 1) by (solve_hyps_min HBCpZNVReq HBCpZNVRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpUVR *)
(* dans constructLemma(), requis par LACpUVR *)
(* dans la couche 0 *)
Lemma LACpYMUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y :: M :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYMUVR requis par la preuve de (?)OoABCpYMUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYMUVR requis par la preuve de (?)OoABCpYMUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMUVRm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMUVRm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMUVRm2 : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMUVRmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpYMUVReq HOoABCpYMUVRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMUVRmtmp;try rewrite HT2 in HOoABCpYMUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMUVRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMUVRM1. try clear HOoABCpYMUVRM2. try clear HOoABCpYMUVRM3. try clear HOoABCpYMUVRm4. try clear HOoABCpYMUVRm3. try clear HOoABCpYMUVRm2. try clear HOoABCpYMUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMUVRm3 : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACpYMUVRM3 : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) <= 3).
{
	try assert(HACpMVeq : rk(A :: Cp :: M :: V :: nil) = 3) by (apply LACpMV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMVMtmp : rk(A :: Cp :: M :: V :: nil) <= 3) by (solve_hyps_max HACpMVeq HACpMVM3).
	try assert(HACpYMUReq : rk(A :: Cp :: Y :: M :: U :: R :: nil) = 3) by (apply LACpYMUR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMURMtmp : rk(A :: Cp :: Y :: M :: U :: R :: nil) <= 3) by (solve_hyps_max HACpYMUReq HACpYMURM3).
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hincl : incl (A :: Cp :: M :: nil) (list_inter (A :: Cp :: M :: V :: nil) (A :: Cp :: Y :: M :: U :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: U :: V :: R :: nil) (A :: Cp :: M :: V :: A :: Cp :: Y :: M :: U :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: M :: V :: A :: Cp :: Y :: M :: U :: R :: nil) ((A :: Cp :: M :: V :: nil) ++ (A :: Cp :: Y :: M :: U :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Cp :: M :: V :: nil) (A :: Cp :: Y :: M :: U :: R :: nil) (A :: Cp :: M :: nil) 3 3 3 HACpMVMtmp HACpYMURMtmp HACpMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HACpYMUVRM : rk(A :: Cp :: Y :: M :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMUVRm : rk(A :: Cp :: Y :: M :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HACpYMUVReq HACpYMUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpUVR requis par la preuve de (?)ACpUVR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpUVR requis par la preuve de (?)ACpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)ACpUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm2 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm3 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpUVR requis par la preuve de (?)ACpUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: U :: V :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpUVRm2 : rk(A :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpUVRmtmp : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpUVReq HOoABCpUVRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpUVRmtmp;try rewrite HT2 in HOoABCpUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: V :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpUVRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpUVRm3 : rk(A :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HACpUeq : rk(A :: Cp :: U :: nil) = 3) by (apply LACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpUmtmp : rk(A :: Cp :: U :: nil) >= 3) by (solve_hyps_min HACpUeq HACpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: U :: nil) (A :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: U :: nil) (A :: Cp :: U :: V :: R :: nil) 3 3 HACpUmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpUVRM3 : rk(A :: Cp :: U :: V :: R :: nil) <= 3).
{
	try assert(HACpYMUVReq : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) = 3) by (apply LACpYMUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMUVRMtmp : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HACpYMUVReq HACpYMUVRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: U :: V :: R :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Cp :: U :: V :: R :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil) 3 3 HACpYMUVRMtmp Hcomp Hincl);apply HT.
}


assert(HACpUVRM : rk(A :: Cp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpUVRm : rk(A :: Cp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HACpUVReq HACpUVRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpUVR *)
(* dans la couche 0 *)
Lemma LBCpZNUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z :: N :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpZNUVR requis par la preuve de (?)OoABCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpZNUVR requis par la preuve de (?)OoABCpZNUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNUVRm2 : rk(Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNUVRm3 : rk(Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpZNUVRm2 : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpZNUVRmtmp : rk(Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpZNUVReq HOoABCpZNUVRm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpZNUVRmtmp;try rewrite HT2 in HOoABCpZNUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpZNUVRmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpZNUVRM1. try clear HOoABCpZNUVRM2. try clear HOoABCpZNUVRM3. try clear HOoABCpZNUVRm4. try clear HOoABCpZNUVRm3. try clear HOoABCpZNUVRm2. try clear HOoABCpZNUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpZNUVRm3 : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HBCpNeq : rk(B :: Cp :: N :: nil) = 3) by (apply LBCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNmtmp : rk(B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBCpNeq HBCpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil) 3 3 HBCpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCpZNUVRM3 : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) <= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HBCpZNVReq : rk(B :: Cp :: Z :: N :: V :: R :: nil) = 3) by (apply LBCpZNVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNVRMtmp : rk(B :: Cp :: Z :: N :: V :: R :: nil) <= 3) by (solve_hyps_max HBCpZNVReq HBCpZNVRM3).
	try assert(HCpVeq : rk(Cp :: V :: nil) = 2) by (apply LCpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpVmtmp : rk(Cp :: V :: nil) >= 2) by (solve_hyps_min HCpVeq HCpVm2).
	assert(Hincl : incl (Cp :: V :: nil) (list_inter (Cp :: U :: V :: nil) (B :: Cp :: Z :: N :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: Z :: N :: U :: V :: R :: nil) (Cp :: U :: V :: B :: Cp :: Z :: N :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: U :: V :: B :: Cp :: Z :: N :: V :: R :: nil) ((Cp :: U :: V :: nil) ++ (B :: Cp :: Z :: N :: V :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: U :: V :: nil) (B :: Cp :: Z :: N :: V :: R :: nil) (Cp :: V :: nil) 2 3 2 HCpUVMtmp HBCpZNVRMtmp HCpVmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCpVM1. try clear HCpVM2. try clear HCpVM3. try clear HCpVm4. try clear HCpVm3. try clear HCpVm2. try clear HCpVm1. 

assert(HBCpZNUVRM : rk(B :: Cp :: Z :: N :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpZNUVRm : rk(B :: Cp :: Z :: N :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HBCpZNUVReq HBCpZNUVRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpUVR *)
(* dans la couche 0 *)
Lemma LABCpZNUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp :: Z :: N :: U :: V :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCpZNUVR requis par la preuve de (?)ABCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpZNUVR requis par la preuve de (?)ABCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpZNUVR requis par la preuve de (?)ABCpZNUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpZNUVRm2 : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpZNUVRm3 : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpZNUVRm4 : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 4).
{
	try assert(HABCpNeq : rk(A :: B :: Cp :: N :: nil) = 4) by (apply LABCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpNmtmp : rk(A :: B :: Cp :: N :: nil) >= 4) by (solve_hyps_min HABCpNeq HABCpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: N :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: N :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 4 4 HABCpNmtmp Hcomp Hincl);apply HT.
}


assert(HABCpZNUVRM : rk(A :: B :: Cp :: Z :: N :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpZNUVRm : rk(A :: B :: Cp :: Z :: N :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HABCpZNUVReq HABCpZNUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: U :: V :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpUVR requis par la preuve de (?)CpUVR pour la règle 3  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CpUVR requis par la preuve de (?)CpUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)CpUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm2 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm3 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm4 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 4).
{
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 4 4 HOoACpUmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpUVR requis par la preuve de (?)CpUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: U :: V :: R ::  de rang :  4 et 4 	 AiB : Cp :: U ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp :: U ::   de rang : 4 et 4 *)
assert(HCpUVRm2 : rk(Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpUeq : rk(Oo :: A :: B :: Cp :: U :: nil) = 4) by (apply LOoABCpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpUMtmp : rk(Oo :: A :: B :: Cp :: U :: nil) <= 4) by (solve_hyps_max HOoABCpUeq HOoABCpUM4).
	assert(HOoABCpUVRmtmp : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 4) by (solve_hyps_min HOoABCpUVReq HOoABCpUVRm4).
	try assert(HCpUeq : rk(Cp :: U :: nil) = 2) by (apply LCpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUmtmp : rk(Cp :: U :: nil) >= 2) by (solve_hyps_min HCpUeq HCpUm2).
	assert(Hincl : incl (Cp :: U :: nil) (list_inter (Oo :: A :: B :: Cp :: U :: nil) (Cp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: U :: Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: U :: Cp :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: U :: nil) ++ (Cp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpUVRmtmp;try rewrite HT2 in HOoABCpUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: U :: nil) (Cp :: U :: V :: R :: nil) (Cp :: U :: nil) 4 2 4 HOoABCpUVRmtmp HCpUmtmp HOoABCpUMtmp Hincl); apply HT.
}
try clear HCpUM1. try clear HCpUM2. try clear HCpUM3. try clear HCpUm4. try clear HCpUm3. try clear HCpUm2. try clear HCpUm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCpUVRM3 : rk(Cp :: U :: V :: R :: nil) <= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: U :: V :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: U :: V :: R :: nil) (Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: U :: V :: R :: nil) ((Cp :: U :: V :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: U :: V :: nil) (R :: nil) (nil) 2 1 0 HCpUVMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HCpUVRM2 : rk(Cp :: U :: V :: R :: nil) <= 2).
{
	try assert(HACpUVReq : rk(A :: Cp :: U :: V :: R :: nil) = 3) by (apply LACpUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpUVRMtmp : rk(A :: Cp :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HACpUVReq HACpUVRM3).
	try assert(HBCpZNUVReq : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) = 3) by (apply LBCpZNUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNUVRMtmp : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HBCpZNUVReq HBCpZNUVRM3).
	try assert(HABCpZNUVReq : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) = 4) by (apply LABCpZNUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpZNUVRmtmp : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 4) by (solve_hyps_min HABCpZNUVReq HABCpZNUVRm4).
	assert(Hincl : incl (Cp :: U :: V :: R :: nil) (list_inter (A :: Cp :: U :: V :: R :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) (A :: Cp :: U :: V :: R :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: U :: V :: R :: B :: Cp :: Z :: N :: U :: V :: R :: nil) ((A :: Cp :: U :: V :: R :: nil) ++ (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCpZNUVRmtmp;try rewrite HT2 in HABCpZNUVRmtmp.
	assert(HT := rule_3 (A :: Cp :: U :: V :: R :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil) (Cp :: U :: V :: R :: nil) 3 3 4 HACpUVRMtmp HBCpZNUVRMtmp HABCpZNUVRmtmp Hincl);apply HT.
}


assert(HCpUVRM : rk(Cp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpUVRm : rk(Cp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HCpUVReq HCpUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCpUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: U :: V :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm2 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm3 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm4 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 4).
{
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 4 4 HOoACpUmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCpUVRM : rk(Oo :: A :: B :: Cp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpUVRm : rk(Oo :: A :: B :: Cp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HOoABCpUVReq HOoABCpUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSpUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSpUVR requis par la preuve de (?)OoACCpSpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSpUVR requis par la preuve de (?)OoACCpSpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpUVRm2 : rk(Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpUVRm3 : rk(Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp :: U :: V :: R ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpUVRm2 : rk(C :: Cp :: Sp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpUVRmtmp : rk(Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoACCpSpUVReq HOoACCpSpUVRm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: U :: V :: R :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpUVRmtmp;try rewrite HT2 in HOoACCpSpUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpUVRmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpUVRM1. try clear HOoACCpSpUVRM2. try clear HOoACCpSpUVRM3. try clear HOoACCpSpUVRm4. try clear HOoACCpSpUVRm3. try clear HOoACCpSpUVRm2. try clear HOoACCpSpUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpUVRm3 : rk(C :: Cp :: Sp :: U :: V :: R :: nil) >= 3).
{
	try assert(HCCpSpeq : rk(C :: Cp :: Sp :: nil) = 3) by (apply LCCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpmtmp : rk(C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HCCpSpeq HCCpSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil) 3 3 HCCpSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCCpSpUVRM3 : rk(C :: Cp :: Sp :: U :: V :: R :: nil) <= 3).
{
	try assert(HCSpReq : rk(C :: Sp :: R :: nil) = 2) by (apply LCSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpRMtmp : rk(C :: Sp :: R :: nil) <= 2) by (solve_hyps_max HCSpReq HCSpRM2).
	try assert(HCpUVReq : rk(Cp :: U :: V :: R :: nil) = 2) by (apply LCpUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVRMtmp : rk(Cp :: U :: V :: R :: nil) <= 2) by (solve_hyps_max HCpUVReq HCpUVRM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (C :: Sp :: R :: nil) (Cp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: Sp :: U :: V :: R :: nil) (C :: Sp :: R :: Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: R :: Cp :: U :: V :: R :: nil) ((C :: Sp :: R :: nil) ++ (Cp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Sp :: R :: nil) (Cp :: U :: V :: R :: nil) (R :: nil) 2 2 1 HCSpRMtmp HCpUVRMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCCpSpUVRM : rk(C :: Cp :: Sp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCCpSpUVRm : rk(C :: Cp :: Sp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HCCpSpUVReq HCCpSpUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSpTUVR : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp :: T :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSpTUVR requis par la preuve de (?)OoACCpSpTUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSpTUVR requis par la preuve de (?)OoACCpSpTUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVRm2 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVRm3 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpTUVRm2 : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpTUVRmtmp : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoACCpSpTUVReq HOoACCpSpTUVRm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: T :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpTUVRmtmp;try rewrite HT2 in HOoACCpSpTUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpTUVRmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpTUVRM1. try clear HOoACCpSpTUVRM2. try clear HOoACCpSpTUVRM3. try clear HOoACCpSpTUVRm4. try clear HOoACCpSpTUVRm3. try clear HOoACCpSpTUVRm2. try clear HOoACCpSpTUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpTUVRm3 : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 3).
{
	try assert(HCCpSpeq : rk(C :: Cp :: Sp :: nil) = 3) by (apply LCCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpmtmp : rk(C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HCCpSpeq HCCpSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil) 3 3 HCCpSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCCpSpTUVRM3 : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) <= 3).
{
	try assert(HCTReq : rk(C :: T :: R :: nil) = 2) by (apply LCTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCTRMtmp : rk(C :: T :: R :: nil) <= 2) by (solve_hyps_max HCTReq HCTRM2).
	try assert(HCCpSpUVReq : rk(C :: Cp :: Sp :: U :: V :: R :: nil) = 3) by (apply LCCpSpUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpUVRMtmp : rk(C :: Cp :: Sp :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HCCpSpUVReq HCCpSpUVRM3).
	try assert(HCReq : rk(C :: R :: nil) = 2) by (apply LCR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCRmtmp : rk(C :: R :: nil) >= 2) by (solve_hyps_min HCReq HCRm2).
	assert(Hincl : incl (C :: R :: nil) (list_inter (C :: T :: R :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: Sp :: T :: U :: V :: R :: nil) (C :: T :: R :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: T :: R :: C :: Cp :: Sp :: U :: V :: R :: nil) ((C :: T :: R :: nil) ++ (C :: Cp :: Sp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: T :: R :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil) (C :: R :: nil) 2 3 2 HCTRMtmp HCCpSpUVRMtmp HCRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCRM1. try clear HCRM2. try clear HCRM3. try clear HCRm4. try clear HCRm3. try clear HCRm2. try clear HCRm1. 

assert(HCCpSpTUVRM : rk(C :: Cp :: Sp :: T :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCCpSpTUVRm : rk(C :: Cp :: Sp :: T :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HCCpSpTUVReq HCCpSpTUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSpTUV : forall Oo A B C Ap Bp Cp X Y Z M N Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Sp ::  nil) = 4 ->
rk(Bp :: N :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: Sp :: T ::  nil) = 4 -> rk(A :: M :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: U ::  nil) = 4 -> rk(A :: C :: M :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: V ::  nil) = 4 -> rk(B :: C :: N :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp :: T :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMSpeq HOoABCApMSpeq HBpNTeq HOoABCBpNTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNSpTeq HAMUeq
HOoAApBpCpMUeq HACMSpTUeq HBNVeq HOoBApBpCpNVeq HBCNSpTVeq HCpUVeq HOoABCCpUVeq HABMNUVeq HApCpMSpUVeq HBpCpNTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSpTUV requis par la preuve de (?)OoACCpSpTUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSpTUV requis par la preuve de (?)OoACCpSpTUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVm2 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVm3 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp :: T :: U :: V ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpTUVm2 : rk(C :: Cp :: Sp :: T :: U :: V :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpTUVmtmp : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) >= 3) by (solve_hyps_min HOoACCpSpTUVeq HOoACCpSpTUVm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: T :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpTUVmtmp;try rewrite HT2 in HOoACCpSpTUVmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpTUVmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpTUVM1. try clear HOoACCpSpTUVM2. try clear HOoACCpSpTUVM3. try clear HOoACCpSpTUVm4. try clear HOoACCpSpTUVm3. try clear HOoACCpSpTUVm2. try clear HOoACCpSpTUVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpTUVm3 : rk(C :: Cp :: Sp :: T :: U :: V :: nil) >= 3).
{
	try assert(HCCpSpeq : rk(C :: Cp :: Sp :: nil) = 3) by (apply LCCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpmtmp : rk(C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HCCpSpeq HCCpSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil) 3 3 HCCpSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpTUVM3 : rk(C :: Cp :: Sp :: T :: U :: V :: nil) <= 3).
{
	try assert(HCCpSpTUVReq : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) = 3) by (apply LCCpSpTUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpTUVRMtmp : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HCCpSpTUVReq HCCpSpTUVRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: T :: U :: V :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Cp :: Sp :: T :: U :: V :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil) 3 3 HCCpSpTUVRMtmp Hcomp Hincl);apply HT.
}


assert(HCCpSpTUVM : rk(C :: Cp :: Sp :: T :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCCpSpTUVm : rk(C :: Cp :: Sp :: T :: U :: V ::  nil) >= 1) by (solve_hyps_min HCCpSpTUVeq HCCpSpTUVm1).
intuition.
Qed.

