Require Import lemmas_automation_g.


(* dans la couche 0 *)
Lemma LOo : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LA : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HAM : rk(A ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAeq HAM1).
assert(HAm : rk(A ::  nil) >= 1) by (solve_hyps_min HAeq HAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoA : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoAM : rk(Oo :: A ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoAeq HOoAM2).
assert(HOoAm : rk(Oo :: A ::  nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBM : rk(B ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBeq HBM1).
assert(HBm : rk(B ::  nil) >= 1) by (solve_hyps_min HBeq HBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoBM : rk(Oo :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBeq HOoBM2).
assert(HOoBm : rk(Oo :: B ::  nil) >= 1) by (solve_hyps_min HOoBeq HOoBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HABM : rk(A :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABeq HABM2).
assert(HABm : rk(A :: B ::  nil) >= 1) by (solve_hyps_min HABeq HABm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAB *)
(* dans la couche 0 *)
Lemma LOoABC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoABCM : rk(Oo :: A :: B :: C ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCm : rk(Oo :: A :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoABCeq HOoABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABM2 : rk(Oo :: A :: B :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoABM : rk(Oo :: A :: B ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABeq HOoABM3).
assert(HOoABm : rk(Oo :: A :: B ::  nil) >= 1) by (solve_hyps_min HOoABeq HOoABm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HCM : rk(C ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCeq HCM1).
assert(HCm : rk(C ::  nil) >= 1) by (solve_hyps_min HCeq HCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoCM : rk(Oo :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCeq HOoCM2).
assert(HOoCm : rk(Oo :: C ::  nil) >= 1) by (solve_hyps_min HOoCeq HOoCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACm2 : rk(Oo :: A :: C :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACM2 : rk(Oo :: A :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoACM : rk(Oo :: A :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACeq HOoACM3).
assert(HOoACm : rk(Oo :: A :: C ::  nil) >= 1) by (solve_hyps_min HOoACeq HOoACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBCM : rk(B :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCeq HBCM2).
assert(HBCm : rk(B :: C ::  nil) >= 1) by (solve_hyps_min HBCeq HBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCm2 : rk(Oo :: B :: C :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCM2 : rk(Oo :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoBCM : rk(Oo :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBCeq HOoBCM3).
assert(HOoBCm : rk(Oo :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoBCeq HOoBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCM2 : rk(A :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

assert(HABCM : rk(A :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCeq HABCM3).
assert(HABCm : rk(A :: B :: C ::  nil) >= 1) by (solve_hyps_min HABCeq HABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HApM : rk(Ap ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HApeq HApM1).
assert(HApm : rk(Ap ::  nil) >= 1) by (solve_hyps_min HApeq HApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoApM : rk(Oo :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoApeq HOoApM2).
assert(HOoApm : rk(Oo :: Ap ::  nil) >= 1) by (solve_hyps_min HOoApeq HOoApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAAp *)
(* dans la couche 0 *)
Lemma LOoAAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoAApM : rk(Oo :: A :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAApeq HOoAApM3).
assert(HOoAApm : rk(Oo :: A :: Ap ::  nil) >= 1) by (solve_hyps_min HOoAApeq HOoAApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)AAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HAApm2 : rk(A :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: nil) (Oo :: A :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: Ap :: nil) ((Oo :: A :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApmtmp;try rewrite HT2 in HOoAApmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HOoAApmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


assert(HAApM : rk(A :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAApeq HAApM2).
assert(HAApm : rk(A :: Ap ::  nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans constructLemma(), requis par LBApMQSp *)
(* dans constructLemma(), requis par LOoBCApMQSp *)
(* dans la couche 0 *)
Lemma LOoABCApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoABCApMQSpM : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApMQSpm : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMQSp requis par la preuve de (?)OoBCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMQSp requis par la preuve de (?)OoBCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMQSpm3 : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMQSpmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoBCApMQSpm4 : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: nil) 4 2 2 HOoABCApMQSpmtmp HOoBmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoBCApMQSpM : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApMQSpm : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApMQSp requis par la preuve de (?)BApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMQSp requis par la preuve de (?)BApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMQSp requis par la preuve de (?)BCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMQSp requis par la preuve de (?)BCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCApMQSpm2 : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: nil) ++ (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 2 HOoABCApMQSpmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApMQSpm3 : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil) (B :: nil) 4 1 2 HOoABCApMQSpmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApMQSp requis par la preuve de (?)BApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApMQSp requis par la preuve de (?)BApMQSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApMQSp requis par la preuve de (?)BApMQSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBApMQSpM3 : rk(B :: Ap :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: Sp :: nil) (B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: M :: Q :: Sp :: nil) ((B :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: M :: Q :: Sp :: nil) (nil) 1 2 0 HBMtmp HApMQSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HBApMQSpm2 : rk(B :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBCApMQSpmtmp : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HBCApMQSpeq HBCApMQSpm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Q :: Sp :: nil) (C :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: B :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMQSpmtmp;try rewrite HT2 in HBCApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (B :: Ap :: M :: Q :: Sp :: nil) (nil) 3 0 1 HBCApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBApMQSpm3 : rk(B :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMQSpeq : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoBCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: C :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: C :: nil) ++ (B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQSpmtmp;try rewrite HT2 in HOoBCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: Ap :: M :: Q :: Sp :: nil) (B :: nil) 4 1 2 HOoBCApMQSpmtmp HBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBApMQSpM : rk(B :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApMQSpm : rk(B :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HBApMQSpeq HBApMQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Q :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HApMQSpM : rk(Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApMQSpm : rk(Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HApMQSpeq HApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HBApMQSpeq : rk(B :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LBApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMQSpmtmp : rk(B :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HBApMQSpeq HBApMQSpm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: Sp :: nil) (B :: Ap :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Ap :: M :: Q :: Sp :: nil) ((B :: Ap :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQSpmtmp;try rewrite HT2 in HBApMQSpmtmp.
	assert(HT := rule_2 (B :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 3 1 2 HBApMQSpmtmp HApmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBAp *)
(* dans la couche 0 *)
Lemma LOoBApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApMQSp requis par la preuve de (?)OoBApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApMQSp requis par la preuve de (?)OoBApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApMQSp requis par la preuve de (?)OoBApMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMQSpm2 : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBApMQSpm3 : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoBCApMQSpeq : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoBCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (C :: Oo :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (Oo :: B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQSpmtmp;try rewrite HT2 in HOoBCApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: B :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 1 HOoBCApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBApMQSpm4 : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMQSpeq : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoBCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: C :: Oo :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: B :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQSpmtmp;try rewrite HT2 in HOoBCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: nil) 4 2 2 HOoBCApMQSpmtmp HOoBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HOoBApMQSpM : rk(Oo :: B :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMQSpm : rk(Oo :: B :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApMQSpeq HOoBApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApm2 : rk(Oo :: B :: Ap :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApm3 : rk(Oo :: B :: Ap :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoBApMQSpeq : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoBApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMQSpmtmp : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApMQSpeq HOoBApMQSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: B :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: Ap :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: Ap :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMQSpmtmp;try rewrite HT2 in HOoBApMQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 4 1 2 HOoBApMQSpmtmp HApmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoBApM : rk(Oo :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBApeq HOoBApM3).
assert(HOoBApm : rk(Oo :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBApeq HOoBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABAp *)
(* dans constructLemma(), requis par LABApMQSp *)
(* dans la couche 0 *)
Lemma LABCApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApMQSp requis par la preuve de (?)ABCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApMQSp requis par la preuve de (?)ABCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCApMQSpm3 : rk(A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (A :: nil) 4 1 2 HOoABCApMQSpmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApMQSpm4 : rk(A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (A :: B :: nil) 4 2 2 HOoABCApMQSpmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCApMQSpM : rk(A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApMQSpm : rk(A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HABCApMQSpeq HABCApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApMQSp requis par la preuve de (?)ABApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApMQSp requis par la preuve de (?)ABApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApMQSp requis par la preuve de (?)ABApMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMQSpm2 : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: Q :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABApMQSpm3 : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCApMQSpeq : rk(A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCApMQSpmtmp : rk(A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABCApMQSpeq HABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (C :: A :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (A :: B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApMQSpmtmp;try rewrite HT2 in HABCApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 1 HABCApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABApMQSpm4 : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCApMQSpeq : rk(A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCApMQSpmtmp : rk(A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABCApMQSpeq HABCApMQSpm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (A :: B :: C :: A :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Ap :: M :: Q :: Sp :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApMQSpmtmp;try rewrite HT2 in HABCApMQSpmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Ap :: M :: Q :: Sp :: nil) (A :: B :: nil) 4 2 2 HABCApMQSpmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABApMQSpM : rk(A :: B :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMQSpm : rk(A :: B :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HABApMQSpeq HABApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApm3 : rk(A :: B :: Ap :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HABApMQSpeq : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LABApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMQSpmtmp : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApMQSpeq HABApMQSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: B :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: Q :: Sp :: nil) (A :: B :: Ap :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Ap :: M :: Q :: Sp :: nil) ((A :: B :: Ap :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMQSpmtmp;try rewrite HT2 in HABApMQSpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 4 1 2 HABApMQSpmtmp HApmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HABApM : rk(A :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABApeq HABApM3).
assert(HABApm : rk(A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HABApeq HABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: nil) ((Oo :: A :: B :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Ap :: nil) (nil) 2 1 0 HOoABMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCAp *)
(* dans constructLemma(), requis par LCApMQSp *)
(* dans la couche 0 *)
Lemma LOoACApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMQSp requis par la preuve de (?)OoACApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMQSp requis par la preuve de (?)OoACApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMQSp requis par la preuve de (?)OoACApMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMQSpm2 : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACApMQSpm3 : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (B :: Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((B :: nil) ++ (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 1 HOoABCApMQSpmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACApMQSpm4 : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMQSpmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACApMQSpM : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMQSpm : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApMQSp requis par la preuve de (?)CApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMQSp requis par la preuve de (?)CApMQSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMQSp requis par la preuve de (?)CApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HCApMQSpm2 : rk(C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (C :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 2 HOoABCApMQSpmtmp Hmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCApMQSpM3 : rk(C :: Ap :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: Sp :: nil) (C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: M :: Q :: Sp :: nil) (nil) 1 2 0 HCMtmp HApMQSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HCApMQSpm3 : rk(C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (C :: Ap :: M :: Q :: Sp :: nil) (C :: nil) 4 1 2 HOoACApMQSpmtmp HCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HCApMQSpM : rk(C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMQSpm : rk(C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HCApMQSpeq HCApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)CAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApm2 : rk(C :: Ap :: nil) >= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HCApMQSpeq : rk(C :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMQSpmtmp : rk(C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HCApMQSpeq HCApMQSpm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: Sp :: nil) (C :: Ap :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Ap :: M :: Q :: Sp :: nil) ((C :: Ap :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMQSpmtmp;try rewrite HT2 in HCApMQSpmtmp.
	assert(HT := rule_2 (C :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 3 1 2 HCApMQSpmtmp HApmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HCApM : rk(C :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCApeq HCApM2).
assert(HCApm : rk(C :: Ap ::  nil) >= 1) by (solve_hyps_min HCApeq HCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCAp *)
(* dans la couche 0 *)
Lemma LOoCApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMQSp requis par la preuve de (?)OoBCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMQSpm3 : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMQSpmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCApMQSpm2 : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCApMQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQSpmtmp;try rewrite HT2 in HOoBCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 3 1 2 HOoBCApMQSpmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCApMQSpm3 : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMQSpmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoCApMQSpm4 : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hincl : incl (Oo :: C :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: Oo :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: C :: nil) 4 2 2 HOoACApMQSpmtmp HOoCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoCApMQSpM : rk(Oo :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMQSpm : rk(Oo :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApMQSpeq HOoCApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCAp requis par la preuve de (?)OoCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCAp requis par la preuve de (?)OoCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApm2 : rk(Oo :: C :: Ap :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApm3 : rk(Oo :: C :: Ap :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoCApMQSpeq : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMQSpmtmp : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApMQSpeq HOoCApMQSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: C :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: C :: Ap :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: Ap :: M :: Q :: Sp :: nil) ((Oo :: C :: Ap :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMQSpmtmp;try rewrite HT2 in HOoCApMQSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 4 1 2 HOoCApMQSpmtmp HApmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoCApM : rk(Oo :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCApeq HOoCApM3).
assert(HOoCApm : rk(Oo :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoCApeq HOoCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: nil) ((Oo :: A :: C :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Ap :: nil) (nil) 2 1 0 HOoACMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCAp *)
(* dans la couche 0 *)
Lemma LBCApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMQSp requis par la preuve de (?)BCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMQSp requis par la preuve de (?)BCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMQSp requis par la preuve de (?)BCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCApMQSpm2 : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: nil) ++ (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 2 HOoABCApMQSpmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApMQSpm3 : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil) (B :: nil) 4 1 2 HOoABCApMQSpmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBCApMQSpm4 : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCApMQSpeq : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoBCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (Oo :: B :: C :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: C :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: C :: nil) ++ (B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQSpmtmp;try rewrite HT2 in HOoBCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: C :: Ap :: M :: Q :: Sp :: nil) (B :: C :: nil) 4 2 2 HOoBCApMQSpmtmp HBCmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBCApMQSpM : rk(B :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApMQSpm : rk(B :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HBCApMQSpeq HBCApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApm2 : rk(B :: C :: Ap :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCApm3 : rk(B :: C :: Ap :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HBCApMQSpeq : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LBCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApMQSpmtmp : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HBCApMQSpeq HBCApMQSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Q :: Sp :: nil) (B :: C :: Ap :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: Ap :: M :: Q :: Sp :: nil) ((B :: C :: Ap :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMQSpmtmp;try rewrite HT2 in HBCApMQSpmtmp.
	assert(HT := rule_2 (B :: C :: Ap :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 4 1 2 HBCApMQSpmtmp HApmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HBCApM : rk(B :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCApeq HBCApM3).
assert(HBCApm : rk(B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HBCApeq HBCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCAp *)
(* dans la couche 0 *)
Lemma LOoABCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABCAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: nil) ((Oo :: A :: B :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Ap :: nil) (nil) 2 1 0 HOoABMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApm2 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABCApM3 : rk(Oo :: A :: B :: C :: Ap :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: C :: Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Ap :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: nil) (Oo :: A :: nil) 2 3 2 HOoACMtmp HOoABApMtmp HOoAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApm3 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApM : rk(Oo :: A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApm : rk(Oo :: A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABCApeq HOoABCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCAp requis par la preuve de (?)OoBCAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCAp requis par la preuve de (?)OoBCAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCAp requis par la preuve de (?)OoBCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApm2 : rk(Oo :: B :: C :: Ap :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBCApM3 : rk(Oo :: B :: C :: Ap :: nil) <= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: C :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: nil) (Oo :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: nil) ((Oo :: B :: C :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: nil) (Ap :: nil) (nil) 2 1 0 HOoBCMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  3 et 3 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApm3 : rk(Oo :: B :: C :: Ap :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 3) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoABCApeq HOoABCApm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoBCApM : rk(Oo :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApm : rk(Oo :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBCApeq HOoBCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBpM : rk(Bp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBpeq HBpM1).
assert(HBpm : rk(Bp ::  nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoBpM : rk(Oo :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBpeq HOoBpM2).
assert(HOoBpm : rk(Oo :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBpeq HOoBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoAApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoAApBpCpM3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HAMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpCpM : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpm : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoApBpCpM : rk(Oo :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpCpm : rk(Oo :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoAApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpm2 : rk(Oo :: A :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpm3 : rk(Oo :: A :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoAApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABpM : rk(Oo :: A :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABpeq HOoABpM3).
assert(HOoABpm : rk(Oo :: A :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABpeq HOoABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBp *)
(* dans constructLemma(), requis par LOoBApBpCp *)
(* dans la couche 0 *)
Lemma LOoABApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABApBpCpM3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoABMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpCpM : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpCpm : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpCp requis par la preuve de (?)OoBApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBApBpCpM3 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HBMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpCpm2 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpCpm3 : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpCpmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoBApBpCpM : rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpCpm : rk(Oo :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)BBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpm2 : rk(B :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoBApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HBBpM : rk(B :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBBpeq HBBpM2).
assert(HBBpm : rk(B :: Bp ::  nil) >= 1) by (solve_hyps_min HBBpeq HBBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBp requis par la preuve de (?)OoBBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBBp requis par la preuve de (?)OoBBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpm2 : rk(Oo :: B :: Bp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBBpm3 : rk(Oo :: B :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoBBpM : rk(Oo :: B :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBBpeq HOoBBpM3).
assert(HOoBBpm : rk(Oo :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBBpeq HOoBBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: nil) ((Oo :: A :: B :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Bp :: nil) (nil) 2 1 0 HOoABMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpm3 : rk(Oo :: A :: B :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABBpM : rk(Oo :: A :: B :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpm : rk(Oo :: A :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABBpeq HOoABBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBp *)
(* dans constructLemma(), requis par LOoCApBpCp *)
(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACApBpCpM3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoACMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCp requis par la preuve de (?)OoCApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoCApBpCpM3 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HCMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpCpm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApBpCpmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


assert(HOoCApBpCpM : rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpm : rk(Oo :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBp requis par la preuve de (?)CBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpm2 : rk(C :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoCApBpCpeq : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpmtmp;try rewrite HT2 in HOoCApBpCpmtmp.
	assert(HT := rule_2 (C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoCApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HCBpM : rk(C :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCBpeq HCBpM2).
assert(HCBpm : rk(C :: Bp ::  nil) >= 1) by (solve_hyps_min HCBpeq HCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCBp requis par la preuve de (?)OoCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCBp requis par la preuve de (?)OoCBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCBpm2 : rk(Oo :: C :: Bp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Bp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCBpm3 : rk(Oo :: C :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoCApBpCpeq : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (Oo :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpmtmp;try rewrite HT2 in HOoCApBpCpmtmp.
	assert(HT := rule_2 (Oo :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoCApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoCBpM : rk(Oo :: C :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCBpeq HOoCBpM3).
assert(HOoCBpm : rk(Oo :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoCBpeq HOoCBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACBp *)
(* dans constructLemma(), requis par LACBpNPT *)
(* dans constructLemma(), requis par LOoACBpNPT *)
(* dans la couche 0 *)
Lemma LOoABCBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoABCBpNPTM : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNPTm : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNPT requis par la preuve de (?)OoACBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNPT requis par la preuve de (?)OoACBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNPT requis par la preuve de (?)OoACBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNPTm2 : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACBpNPTm3 : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (B :: Oo :: A :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Bp :: N :: P :: T :: nil) ((B :: nil) ++ (Oo :: A :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (nil) 4 0 1 HOoABCBpNPTmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACBpNPTm4 : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: Oo :: A :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: nil) 4 2 2 HOoABCBpNPTmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACBpNPTM : rk(Oo :: A :: C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpNPTm : rk(Oo :: A :: C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpNPT requis par la preuve de (?)ACBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpNPT requis par la preuve de (?)ACBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpNPT requis par la preuve de (?)ACBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACBpNPTm2 : rk(A :: C :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: B :: A :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Bp :: N :: P :: T :: nil) ((Oo :: B :: nil) ++ (A :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Bp :: N :: P :: T :: nil) (nil) 4 0 2 HOoABCBpNPTmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACBpNPTm3 : rk(A :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: A :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Bp :: N :: P :: T :: nil) (A :: nil) 4 1 2 HOoABCBpNPTmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACBpNPTm4 : rk(A :: C :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPTeq : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNPTmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: A :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPTmtmp;try rewrite HT2 in HOoACBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Bp :: N :: P :: T :: nil) (A :: C :: nil) 4 2 2 HOoACBpNPTmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACBpNPTM : rk(A :: C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpNPTm : rk(A :: C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HACBpNPTeq HACBpNPTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACBp *)
(* dans la couche 0 *)
Lemma LBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: P :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBpNPTM : rk(Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpNPTm : rk(Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HBpNPTeq HBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACBpm3 : rk(A :: C :: Bp :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HACBpNPTeq : rk(A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACBpNPTmtmp : rk(A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HACBpNPTeq HACBpNPTm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: C :: Bp :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: N :: P :: T :: nil) (A :: C :: Bp :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: Bp :: N :: P :: T :: nil) ((A :: C :: Bp :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpNPTmtmp;try rewrite HT2 in HACBpNPTmtmp.
	assert(HT := rule_2 (A :: C :: Bp :: nil) (Bp :: N :: P :: T :: nil) (Bp :: nil) 4 1 2 HACBpNPTmtmp HBpmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HACBpM : rk(A :: C :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACBpeq HACBpM3).
assert(HACBpm : rk(A :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HACBpeq HACBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBp requis par la preuve de (?)OoACBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpm2 : rk(Oo :: A :: C :: Bp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACBpM3 : rk(Oo :: A :: C :: Bp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: nil) (Oo :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: nil) ((Oo :: A :: C :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Bp :: nil) (nil) 2 1 0 HOoACMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACBpm3 : rk(Oo :: A :: C :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoACApBpCpmtmp HOoBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACBpM : rk(Oo :: A :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpm : rk(Oo :: A :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoACBpeq HOoACBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpm2 : rk(Oo :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpM2 : rk(Oo :: Ap :: Bp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpM : rk(Oo :: Ap :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApBpeq HOoApBpM3).
assert(HOoApBpm : rk(Oo :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoApBpeq HOoApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HCpM : rk(Cp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCpeq HCpM1).
assert(HCpm : rk(Cp ::  nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoCpM : rk(Oo :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCpeq HOoCpM2).
assert(HOoCpm : rk(Oo :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCpeq HOoCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ACp requis par la preuve de (?)ACp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpm2 : rk(A :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoAApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HACpM : rk(A :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACpeq HACpM2).
assert(HACpm : rk(A :: Cp ::  nil) >= 1) by (solve_hyps_min HACpeq HACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpm2 : rk(Oo :: A :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpm3 : rk(Oo :: A :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoAApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACpM : rk(Oo :: A :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACpeq HOoACpM3).
assert(HOoACpm : rk(Oo :: A :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACpeq HOoACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)BCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCpm2 : rk(B :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBApBpCpeq : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBApBpCpeq HOoBApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: nil) (B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpmtmp;try rewrite HT2 in HOoBApBpCpmtmp.
	assert(HT := rule_2 (B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoBApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HBCpM : rk(B :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCpeq HBCpM2).
assert(HBCpm : rk(B :: Cp ::  nil) >= 1) by (solve_hyps_min HBCpeq HBCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans constructLemma(), requis par LABCpUV *)
(* dans constructLemma(), requis par LABCCpUV *)
(* dans la couche 0 *)
Lemma LOoABCCpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoABCCpUVM : rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpUVm : rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCCpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCpUV requis par la preuve de (?)ABCCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCpUV requis par la preuve de (?)ABCCpUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCCpUVm3 : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: A :: B :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Cp :: U :: V :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoABCCpUVmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCCpUVm4 : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: A :: B :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Cp :: U :: V :: nil) (A :: B :: nil) 4 2 2 HOoABCCpUVmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCCpUVM : rk(A :: B :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCCpUVm : rk(A :: B :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HABCCpUVeq HABCCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCpUV requis par la preuve de (?)ABCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpUV requis par la preuve de (?)ABCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpUV requis par la preuve de (?)ABCpUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpUVm2 : rk(A :: B :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: U :: V :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABCpUVm3 : rk(A :: B :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCCpUVeq : rk(A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCCpUVmtmp : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HABCCpUVeq HABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: U :: V :: nil) (C :: A :: B :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Cp :: U :: V :: nil) ((C :: nil) ++ (A :: B :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpUVmtmp;try rewrite HT2 in HABCCpUVmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Cp :: U :: V :: nil) (nil) 4 0 1 HABCCpUVmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABCpUVm4 : rk(A :: B :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCCpUVeq : rk(A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCCpUVmtmp : rk(A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HABCCpUVeq HABCCpUVm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: U :: V :: nil) (A :: B :: C :: A :: B :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Cp :: U :: V :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpUVmtmp;try rewrite HT2 in HABCCpUVmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Cp :: U :: V :: nil) (A :: B :: nil) 4 2 2 HABCCpUVmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABCpUVM : rk(A :: B :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpUVm : rk(A :: B :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HABCpUVeq HABCpUVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LCpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: U :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HCpUVM : rk(Cp :: U :: V ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCpUVeq HCpUVM3).
assert(HCpUVm : rk(Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HCpUVeq HCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCpm3 : rk(A :: B :: Cp :: nil) >= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HABCpUVeq : rk(A :: B :: Cp :: U :: V :: nil) = 4) by (apply LABCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpUVmtmp : rk(A :: B :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HABCpUVeq HABCpUVm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: U :: V :: nil) (A :: B :: Cp :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: Cp :: U :: V :: nil) ((A :: B :: Cp :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCpUVmtmp;try rewrite HT2 in HABCpUVmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (Cp :: U :: V :: nil) (Cp :: nil) 4 1 2 HABCpUVmtmp HCpmtmp HCpUVMtmp Hincl);apply HT.
}


assert(HABCpM : rk(A :: B :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCpeq HABCpM3).
assert(HABCpm : rk(A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HABCpeq HABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABCpM3 : rk(Oo :: A :: B :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Cp :: nil) (nil) 2 1 0 HOoABMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCpm3 : rk(Oo :: A :: B :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoABApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABCpM : rk(Oo :: A :: B :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpm : rk(Oo :: A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCpeq HOoABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)CCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCCpm2 : rk(C :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoCApBpCpeq : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoCApBpCpeq HOoCApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: nil) (C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpmtmp;try rewrite HT2 in HOoCApBpCpmtmp.
	assert(HT := rule_2 (C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoCApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HCCpM : rk(C :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCCpeq HCCpM2).
assert(HCCpm : rk(C :: Cp ::  nil) >= 1) by (solve_hyps_min HCCpeq HCCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACCp *)
(* dans constructLemma(), requis par LACCpUV *)
(* dans la couche 0 *)
Lemma LOoACCpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpUV requis par la preuve de (?)OoACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpUV requis par la preuve de (?)OoACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpUV requis par la preuve de (?)OoACCpUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpUVm2 : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B ::   de rang : 1 et 1 *)
assert(HOoACCpUVm3 : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (B :: Oo :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: C :: Cp :: U :: V :: nil) ((B :: nil) ++ (Oo :: A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil) (nil) 4 0 1 HOoABCCpUVmtmp Hmtmp HBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoACCpUVm4 : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: Oo :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: A :: C :: Cp :: U :: V :: nil) (Oo :: A :: nil) 4 2 2 HOoABCCpUVmtmp HOoAmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoACCpUVM : rk(Oo :: A :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpUVm : rk(Oo :: A :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HOoACCpUVeq HOoACCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp :: U :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm2 : rk(A :: C :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (nil) 4 0 2 HOoABCCpUVmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm3 : rk(A :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoABCCpUVmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACCpUVm4 : rk(A :: C :: Cp :: U :: V :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACCpUVeq : rk(Oo :: A :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoACCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpUVmtmp : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoACCpUVeq HOoACCpUVm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: U :: V :: nil) (Oo :: A :: C :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpUVmtmp;try rewrite HT2 in HOoACCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Cp :: U :: V :: nil) (A :: C :: nil) 4 2 2 HOoACCpUVmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACCpUVM : rk(A :: C :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpUVm : rk(A :: C :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HACCpUVeq HACCpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACCpm3 : rk(A :: C :: Cp :: nil) >= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HACCpUVeq : rk(A :: C :: Cp :: U :: V :: nil) = 4) by (apply LACCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpUVmtmp : rk(A :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HACCpUVeq HACCpUVm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: C :: Cp :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: U :: V :: nil) (A :: C :: Cp :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: Cp :: U :: V :: nil) ((A :: C :: Cp :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpUVmtmp;try rewrite HT2 in HACCpUVmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (Cp :: U :: V :: nil) (Cp :: nil) 4 1 2 HACCpUVmtmp HCpmtmp HCpUVMtmp Hincl);apply HT.
}


assert(HACCpM : rk(A :: C :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACCpeq HACCpM3).
assert(HACCpm : rk(A :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HACCpeq HACCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpm2 : rk(Oo :: A :: C :: Cp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACCpM3 : rk(Oo :: A :: C :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: nil) (Oo :: A :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Cp :: nil) (nil) 2 1 0 HOoACMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACCpm3 : rk(Oo :: A :: C :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoACApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACCpM : rk(Oo :: A :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpm : rk(Oo :: A :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACCpeq HOoACCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpm2 : rk(Oo :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpM2 : rk(Oo :: Ap :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpM : rk(Oo :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApCpeq HOoApCpM3).
assert(HOoApCpm : rk(Oo :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApCpeq HOoApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBpCpM : rk(Bp :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpCpeq HBpCpM2).
assert(HBpCpm : rk(Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HBpCpeq HBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCp requis par la preuve de (?)OoBpCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpCp requis par la preuve de (?)OoBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpm2 : rk(Oo :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpM2 : rk(Oo :: Bp :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoBpCpM : rk(Oo :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpCpeq HOoBpCpM3).
assert(HOoBpCpm : rk(Oo :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBpCpeq HOoBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpCp requis par la preuve de (?)ApBpCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpCp requis par la preuve de (?)ApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpm2 : rk(Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpM2 : rk(Ap :: Bp :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HApBpCpM : rk(Ap :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpCpeq HApBpCpM3).
assert(HApBpCpm : rk(Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HApBpCpeq HApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Y ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HYM : rk(Y ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HYeq HYM1).
assert(HYm : rk(Y ::  nil) >= 1) by (solve_hyps_min HYeq HYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HCApYM : rk(C :: Ap :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApYeq HCApYM3).
assert(HCApYm : rk(C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HCApYeq HCApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HACpYM : rk(A :: Cp :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpYeq HACpYM3).
assert(HACpYm : rk(A :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HACpYeq HACpYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LZ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Z ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HZM : rk(Z ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HZeq HZM1).
assert(HZm : rk(Z ::  nil) >= 1) by (solve_hyps_min HZeq HZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HCBpZM : rk(C :: Bp :: Z ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpZeq HCBpZM3).
assert(HCBpZm : rk(C :: Bp :: Z ::  nil) >= 1) by (solve_hyps_min HCBpZeq HCBpZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpZ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBCpZM : rk(B :: Cp :: Z ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCpZeq HBCpZM3).
assert(HBCpZm : rk(B :: Cp :: Z ::  nil) >= 1) by (solve_hyps_min HBCpZeq HBCpZm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HMM : rk(M ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HMeq HMM1).
assert(HMm : rk(M ::  nil) >= 1) by (solve_hyps_min HMeq HMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAM *)
(* dans la couche 0 *)
Lemma LAApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApMQSp requis par la preuve de (?)AApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApMQSp requis par la preuve de (?)AApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApMQSp requis par la preuve de (?)ACApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApMQSp requis par la preuve de (?)ACApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACApMQSpm2 : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 2 HOoABCApMQSpmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApMQSpm3 : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil) (A :: nil) 4 1 2 HOoABCApMQSpmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApMQSp requis par la preuve de (?)AApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMQSp requis par la preuve de (?)AApMQSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApMQSpM3 : rk(A :: Ap :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: Sp :: nil) (A :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: M :: Q :: Sp :: nil) ((A :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: M :: Q :: Sp :: nil) (nil) 1 2 0 HAMtmp HApMQSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HAApMQSpm2 : rk(A :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACApMQSpmtmp : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HACApMQSpeq HACApMQSpm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Q :: Sp :: nil) (C :: A :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (A :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMQSpmtmp;try rewrite HT2 in HACApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Ap :: M :: Q :: Sp :: nil) (nil) 3 0 1 HACApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HAApMQSpm3 : rk(A :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: A :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (A :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Ap :: M :: Q :: Sp :: nil) (A :: nil) 4 1 2 HOoACApMQSpmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HAApMQSpM : rk(A :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMQSpm : rk(A :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HAApMQSpeq HAApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AM requis par la preuve de (?)AM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAMm2 : rk(A :: M :: nil) >= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HAApMQSpeq : rk(A :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMQSpmtmp : rk(A :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HAApMQSpeq HAApMQSpm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: Sp :: nil) (A :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: Ap :: M :: Q :: Sp :: nil) ((A :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMQSpmtmp;try rewrite HT2 in HAApMQSpmtmp.
	assert(HT := rule_2 (A :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (M :: nil) 3 1 2 HAApMQSpmtmp HMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HAMM : rk(A :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAMeq HAMM2).
assert(HAMm : rk(A :: M ::  nil) >= 1) by (solve_hyps_min HAMeq HAMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAM *)
(* dans la couche 0 *)
Lemma LOoAApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMQSp requis par la preuve de (?)OoAApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMQSp requis par la preuve de (?)OoAApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMQSp requis par la preuve de (?)OoAApMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQSpm2 : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoAApMQSpm3 : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (C :: Oo :: A :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 1 HOoACApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoAApMQSpm4 : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: Oo :: A :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: nil) 4 2 2 HOoACApMQSpmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoAApMQSpM : rk(Oo :: A :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMQSpm : rk(Oo :: A :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAM requis par la preuve de (?)OoAM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAM requis par la preuve de (?)OoAM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAMm2 : rk(Oo :: A :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAMm3 : rk(Oo :: A :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: A :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (M :: nil) 4 1 2 HOoAApMQSpmtmp HMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoAMM : rk(Oo :: A :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAMeq HOoAMM3).
assert(HOoAMm : rk(Oo :: A :: M ::  nil) >= 1) by (solve_hyps_min HOoAMeq HOoAMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABM *)
(* dans la couche 0 *)
Lemma LOoABApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMQSp requis par la preuve de (?)OoABApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMQSp requis par la preuve de (?)OoABApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMQSp requis par la preuve de (?)OoABApMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMQSpm2 : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApMQSpm3 : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (C :: Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 1 HOoABCApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABApMQSpm4 : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: nil) 4 2 2 HOoABCApMQSpmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABApMQSpM : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMQSpm : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApMQSpeq HOoABApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABM requis par la preuve de (?)OoABM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABM requis par la preuve de (?)OoABM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABM requis par la preuve de (?)OoABM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMm2 : rk(Oo :: A :: B :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABMM3 : rk(Oo :: A :: B :: M :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: nil) (Oo :: A :: B :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: nil) ((Oo :: A :: B :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (M :: nil) (nil) 2 1 0 HOoABMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABMm3 : rk(Oo :: A :: B :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoABApMQSpeq : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMQSpeq HOoABApMQSpm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQSpmtmp;try rewrite HT2 in HOoABApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (M :: nil) 4 1 2 HOoABApMQSpmtmp HMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoABMM : rk(Oo :: A :: B :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABMm : rk(Oo :: A :: B :: M ::  nil) >= 1) by (solve_hyps_min HOoABMeq HOoABMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACM *)
(* dans la couche 0 *)
Lemma LACApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Ap :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApMQSp requis par la preuve de (?)ACApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApMQSp requis par la preuve de (?)ACApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApMQSp requis par la preuve de (?)ACApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACApMQSpm2 : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil) (nil) 4 0 2 HOoABCApMQSpmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApMQSpm3 : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil) (A :: nil) 4 1 2 HOoABCApMQSpmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACApMQSpm4 : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (Oo :: A :: C :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: A :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (A :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: C :: Ap :: M :: Q :: Sp :: nil) (A :: C :: nil) 4 2 2 HOoACApMQSpmtmp HACmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACApMQSpM : rk(A :: C :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApMQSpm : rk(A :: C :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HACApMQSpeq HACApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACMm2 : rk(A :: C :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACMm3 : rk(A :: C :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HACApMQSpeq : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACApMQSpmtmp : rk(A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HACApMQSpeq HACApMQSpm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (A :: C :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: M :: Q :: Sp :: nil) (A :: C :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: M :: Ap :: M :: Q :: Sp :: nil) ((A :: C :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApMQSpmtmp;try rewrite HT2 in HACApMQSpmtmp.
	assert(HT := rule_2 (A :: C :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (M :: nil) 4 1 2 HACApMQSpmtmp HMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HACMM : rk(A :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACMeq HACMM3).
assert(HACMm : rk(A :: C :: M ::  nil) >= 1) by (solve_hyps_min HACMeq HACMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApM *)
(* dans constructLemma(), requis par LAApMPU *)
(* dans constructLemma(), requis par LOoAApCpMPU *)
(* dans la couche 0 *)
Lemma LOoAApBpCpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoAApBpCpMPUM : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpMPUm : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpMPU requis par la preuve de (?)OoAApCpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpMPU requis par la preuve de (?)OoAApCpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpMPU requis par la preuve de (?)OoAApCpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMPUm2 : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMPUm3 : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoAApCpMPUm4 : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: nil) 4 2 2 HOoAApBpCpMPUmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoAApCpMPUM : rk(Oo :: A :: Ap :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpMPUm : rk(Oo :: A :: Ap :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoAApCpMPUeq HOoAApCpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: M :: P :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApMPU requis par la preuve de (?)AApMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApMPU requis par la preuve de (?)AApMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour AMPU requis par la preuve de (?)AApMPU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMPU requis par la preuve de (?)AApMPU pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HAApMPUM3 : rk(A :: Ap :: M :: P :: U :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: P :: U :: nil) (Ap :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: M :: P :: U :: nil) ((Ap :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: M :: P :: U :: nil) (nil) 1 2 0 HApMtmp HAMPUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMPUm2 : rk(A :: Ap :: M :: P :: U :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: M :: P :: U :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApMPUm3 : rk(A :: Ap :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPUeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMPUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMPUeq HOoAApCpMPUm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Cp :: A :: Ap :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: M :: P :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPUmtmp;try rewrite HT2 in HOoAApCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: M :: P :: U :: nil) (Ap :: nil) 4 1 2 HOoAApCpMPUmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HAApMPUM : rk(A :: Ap :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMPUm : rk(A :: Ap :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HAApMPUeq HAApMPUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApM *)
(* dans la couche 0 *)
Lemma LAMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M :: P :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HAMPUM : rk(A :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAMPUm : rk(A :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HAMPUeq HAMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApM requis par la preuve de (?)ApM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApMm2 : rk(Ap :: M :: nil) >= 2).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HAApMPUeq : rk(A :: Ap :: M :: P :: U :: nil) = 3) by (apply LAApMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMPUmtmp : rk(A :: Ap :: M :: P :: U :: nil) >= 3) by (solve_hyps_min HAApMPUeq HAApMPUm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: P :: U :: nil) (Ap :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: A :: M :: P :: U :: nil) ((Ap :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMPUmtmp;try rewrite HT2 in HAApMPUmtmp.
	assert(HT := rule_2 (Ap :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 3 1 2 HAApMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HApMM : rk(Ap :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApMeq HApMM2).
assert(HApMm : rk(Ap :: M ::  nil) >= 1) by (solve_hyps_min HApMeq HApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApM *)
(* dans la couche 0 *)
Lemma LOoApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApMQSp requis par la preuve de (?)OoApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMQSp requis par la preuve de (?)OoApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMQSp requis par la preuve de (?)OoBCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCApMQSpm3 : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMQSpmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMQSp requis par la preuve de (?)OoCApMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCApMQSpm2 : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCApMQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoBCApMQSpeq HOoBCApMQSpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMQSpmtmp;try rewrite HT2 in HOoBCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 3 1 2 HOoBCApMQSpmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCApMQSpm3 : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApMQSpeq : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApMQSpmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApMQSpeq HOoABCApMQSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMQSpmtmp;try rewrite HT2 in HOoABCApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 4 1 2 HOoABCApMQSpmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApMQSp requis par la preuve de (?)OoApMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApMQSp requis par la preuve de (?)OoApMQSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApMQSpM3 : rk(Oo :: Ap :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: M :: Q :: Sp :: nil) (Oo :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: M :: Q :: Sp :: nil) ((Oo :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: M :: Q :: Sp :: nil) (nil) 1 2 0 HOoMtmp HApMQSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoApMQSpm2 : rk(Oo :: Ap :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoCApMQSpmtmp : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoCApMQSpeq HOoCApMQSpm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (C :: Oo :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Ap :: M :: Q :: Sp :: nil) ((C :: nil) ++ (Oo :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMQSpmtmp;try rewrite HT2 in HOoCApMQSpmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: Ap :: M :: Q :: Sp :: nil) (nil) 3 0 1 HOoCApMQSpmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoApMQSpm3 : rk(Oo :: Ap :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: C :: Oo :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: Ap :: M :: Q :: Sp :: nil) (Oo :: nil) 4 1 2 HOoACApMQSpmtmp HOomtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoApMQSpM : rk(Oo :: Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApMQSpm : rk(Oo :: Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApMQSpeq HOoApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApM requis par la preuve de (?)OoApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApM requis par la preuve de (?)OoApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApMm2 : rk(Oo :: Ap :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApMm3 : rk(Oo :: Ap :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoApMQSpeq : rk(Oo :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LOoApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMQSpmtmp : rk(Oo :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoApMQSpeq HOoApMQSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: M :: Q :: Sp :: nil) (Oo :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApMQSpmtmp;try rewrite HT2 in HOoApMQSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HOoApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoApMM : rk(Oo :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApMeq HOoApMM3).
assert(HOoApMm : rk(Oo :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoApMeq HOoApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApM requis par la preuve de (?)AApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApM requis par la preuve de (?)AApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMm2 : rk(A :: Ap :: M :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: M :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApMm3 : rk(A :: Ap :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HAApMQSpeq : rk(A :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMQSpmtmp : rk(A :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HAApMQSpeq HAApMQSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (A :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: Q :: Sp :: nil) (A :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((A :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMQSpmtmp;try rewrite HT2 in HAApMQSpmtmp.
	assert(HT := rule_2 (A :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HAApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HAApMM : rk(A :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAApMeq HAApMM3).
assert(HAApMm : rk(A :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HAApMeq HAApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApM requis par la preuve de (?)OoAApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMm2 : rk(Oo :: A :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMm3 : rk(Oo :: A :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAApMm4 : rk(Oo :: A :: Ap :: M :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoAApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoAApMM : rk(Oo :: A :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMm : rk(Oo :: A :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoAApMeq HOoAApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApM requis par la preuve de (?)BApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)BApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApM requis par la preuve de (?)BApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApMm2 : rk(B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABApMeq HOoABApMm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: nil) (B :: Ap :: nil) 3 2 3 HOoABApMmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApMm3 : rk(B :: Ap :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HBApMQSpeq : rk(B :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LBApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMQSpmtmp : rk(B :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HBApMQSpeq HBApMQSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: Q :: Sp :: nil) (B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((B :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApMQSpmtmp;try rewrite HT2 in HBApMQSpmtmp.
	assert(HT := rule_2 (B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HBApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HBApMM : rk(B :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApMeq HBApMM3).
assert(HBApMm : rk(B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HBApMeq HBApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApM requis par la preuve de (?)OoBApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoBApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApM requis par la preuve de (?)OoBApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApM requis par la preuve de (?)OoBApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMm2 : rk(Oo :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApMm3 : rk(Oo :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABApMeq HOoABApMm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApMmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApMm4 : rk(Oo :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoBApMQSpeq : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoBApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMQSpmtmp : rk(Oo :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApMQSpeq HOoBApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMQSpmtmp;try rewrite HT2 in HOoBApMQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoBApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoBApMM : rk(Oo :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMm : rk(Oo :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoBApMeq HOoBApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApM requis par la preuve de (?)ABApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)ABApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApM requis par la preuve de (?)ABApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApM requis par la preuve de (?)ABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMm2 : rk(A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApMm3 : rk(A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABApMeq HOoABApMm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: M :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApMmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApMm4 : rk(A :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HABApMQSpeq : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LABApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMQSpmtmp : rk(A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApMQSpeq HABApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (A :: B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: Q :: Sp :: nil) (A :: B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((A :: B :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMQSpmtmp;try rewrite HT2 in HABApMQSpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HABApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HABApMM : rk(A :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMm : rk(A :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HABApMeq HABApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABApMm4 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoABApMQSpeq : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMQSpeq HOoABApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQSpmtmp;try rewrite HT2 in HOoABApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoABApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoABApMM : rk(Oo :: A :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMm : rk(Oo :: A :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoABApMeq HOoABApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApM requis par la preuve de (?)CApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApM requis par la preuve de (?)CApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm2 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm3 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApM requis par la preuve de (?)CApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMm2 : rk(C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMmtmp : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoACApMeq HOoACApMm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMmtmp;try rewrite HT2 in HOoACApMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApMm3 : rk(C :: Ap :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HCApMQSpeq : rk(C :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMQSpmtmp : rk(C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HCApMQSpeq HCApMQSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (C :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: Sp :: nil) (C :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((C :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMQSpmtmp;try rewrite HT2 in HCApMQSpmtmp.
	assert(HT := rule_2 (C :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HCApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HCApMM : rk(C :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApMeq HCApMM3).
assert(HCApMm : rk(C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HCApMeq HCApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm2 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm3 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApM requis par la preuve de (?)OoCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMm2 : rk(Oo :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: M :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApMm3 : rk(Oo :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMmtmp : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoACApMeq HOoACApMm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMmtmp;try rewrite HT2 in HOoACApMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApMmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApMm4 : rk(Oo :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoCApMQSpeq : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMQSpmtmp : rk(Oo :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApMQSpeq HOoCApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: C :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: C :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: C :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMQSpmtmp;try rewrite HT2 in HOoCApMQSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoCApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoCApMM : rk(Oo :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMm : rk(Oo :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoCApMeq HOoCApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApM requis par la preuve de (?)BCApM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApM requis par la preuve de (?)BCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApM requis par la preuve de (?)OoBCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApM requis par la preuve de (?)OoABCApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApM requis par la preuve de (?)OoABCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMm2 : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMm3 : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApM requis par la preuve de (?)OoBCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApM requis par la preuve de (?)OoBCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMm2 : rk(Oo :: B :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: M :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApMm3 : rk(Oo :: B :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApMmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoABCApMeq HOoABCApMm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMmtmp;try rewrite HT2 in HOoABCApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: M :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApMmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApMM1. try clear HOoABCApMM2. try clear HOoABCApMM3. try clear HOoABCApMm4. try clear HOoABCApMm3. try clear HOoABCApMm2. try clear HOoABCApMm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApM requis par la preuve de (?)BCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApM requis par la preuve de (?)BCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMm2 : rk(B :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: M :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: M ::  de rang :  3 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HBCApMm3 : rk(B :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoBCApeq : rk(Oo :: B :: C :: Ap :: nil) = 3) by (apply LOoBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMtmp : rk(Oo :: B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoBCApeq HOoBCApM3).
	assert(HOoBCApMmtmp : rk(Oo :: B :: C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoBCApMeq HOoBCApMm3).
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: B :: C :: Ap :: M :: nil) ((Oo :: B :: C :: Ap :: nil) ++ (B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMmtmp;try rewrite HT2 in HOoBCApMmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: nil) (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: nil) 3 3 3 HOoBCApMmtmp HBCApmtmp HOoBCApMtmp Hincl); apply HT.
}
try clear HOoBCApMM1. try clear HOoBCApMM2. try clear HOoBCApMM3. try clear HOoBCApMm4. try clear HOoBCApMm3. try clear HOoBCApMm2. try clear HOoBCApMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCApMm4 : rk(B :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HBCApMQSpeq : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LBCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApMQSpmtmp : rk(B :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HBCApMQSpeq HBCApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (B :: C :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: Q :: Sp :: nil) (B :: C :: Ap :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: M :: Ap :: M :: Q :: Sp :: nil) ((B :: C :: Ap :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMQSpmtmp;try rewrite HT2 in HBCApMQSpmtmp.
	assert(HT := rule_2 (B :: C :: Ap :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HBCApMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HBCApMM : rk(B :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApMm : rk(B :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HBCApMeq HBCApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpM *)
(* dans constructLemma(), requis par LABpMPU *)
(* dans la couche 0 *)
Lemma LOoABpCpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpMPU requis par la preuve de (?)OoABpCpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpMPU requis par la preuve de (?)OoABpCpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpMPU requis par la preuve de (?)OoABpCpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMPUm2 : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoABpCpMPUm3 : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Ap :: Oo :: A :: Bp :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) ((Ap :: nil) ++ (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) (nil) 4 0 1 HOoAApBpCpMPUmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpCpMPUm4 : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Bp :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Bp :: nil) 4 2 2 HOoAApBpCpMPUmtmp HOoBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoABpCpMPUM : rk(Oo :: A :: Bp :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpMPUm : rk(Oo :: A :: Bp :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoABpCpMPUeq HOoABpCpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp :: M :: P :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpMPU requis par la preuve de (?)ABpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpMPU requis par la preuve de (?)ABpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpMPU requis par la preuve de (?)ABpMPU pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpMPUM3 : rk(A :: Bp :: M :: P :: U :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: M :: P :: U :: nil) (Bp :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: M :: P :: U :: nil) ((Bp :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: M :: P :: U :: nil) (nil) 1 2 0 HBpMtmp HAMPUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpMPUm2 : rk(A :: Bp :: M :: P :: U :: nil) >= 2).
{
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: M :: P :: U :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HABpMPUm3 : rk(A :: Bp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoABpCpMPUeq : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoABpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpMPUmtmp : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoABpCpMPUeq HOoABpCpMPUm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (A :: Bp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Bp :: Cp :: A :: Bp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: A :: Bp :: M :: P :: U :: nil) ((Oo :: Bp :: Cp :: nil) ++ (A :: Bp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMPUmtmp;try rewrite HT2 in HOoABpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (A :: Bp :: M :: P :: U :: nil) (Bp :: nil) 4 1 2 HOoABpCpMPUmtmp HBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HABpMPUM : rk(A :: Bp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpMPUm : rk(A :: Bp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HABpMPUeq HABpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpM requis par la preuve de (?)BpM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpMm2 : rk(Bp :: M :: nil) >= 2).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HABpMPUeq : rk(A :: Bp :: M :: P :: U :: nil) = 3) by (apply LABpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpMPUmtmp : rk(A :: Bp :: M :: P :: U :: nil) >= 3) by (solve_hyps_min HABpMPUeq HABpMPUm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Bp :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: M :: P :: U :: nil) (Bp :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: M :: A :: M :: P :: U :: nil) ((Bp :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpMPUmtmp;try rewrite HT2 in HABpMPUmtmp.
	assert(HT := rule_2 (Bp :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 3 1 2 HABpMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HBpMM : rk(Bp :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpMeq HBpMM2).
assert(HBpMm : rk(Bp :: M ::  nil) >= 1) by (solve_hyps_min HBpMeq HBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpM *)
(* dans la couche 0 *)
Lemma LOoABpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMPU requis par la preuve de (?)OoABpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMPU requis par la preuve de (?)OoABpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMPU requis par la preuve de (?)OoABpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMPUm2 : rk(Oo :: A :: Bp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMPUm3 : rk(Oo :: A :: Bp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: P :: U :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HOoABpMPUm4 : rk(Oo :: A :: Bp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoABpCpMPUeq : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoABpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpMPUmtmp : rk(Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoABpCpMPUeq HOoABpCpMPUm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (Oo :: A :: Bp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Bp :: Cp :: Oo :: A :: Bp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: Oo :: A :: Bp :: M :: P :: U :: nil) ((Oo :: Bp :: Cp :: nil) ++ (Oo :: A :: Bp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMPUmtmp;try rewrite HT2 in HOoABpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (Oo :: A :: Bp :: M :: P :: U :: nil) (Oo :: Bp :: nil) 4 2 2 HOoABpCpMPUmtmp HOoBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HOoABpMPUM : rk(Oo :: A :: Bp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMPUm : rk(Oo :: A :: Bp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoABpMPUeq HOoABpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpM requis par la preuve de (?)OoBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpM requis par la preuve de (?)OoBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpMm2 : rk(Oo :: Bp :: M :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: M :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpMm3 : rk(Oo :: Bp :: M :: nil) >= 3).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HOoABpMPUeq : rk(Oo :: A :: Bp :: M :: P :: U :: nil) = 4) by (apply LOoABpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMPUmtmp : rk(Oo :: A :: Bp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoABpMPUeq HOoABpMPUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: Bp :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: M :: P :: U :: nil) (Oo :: Bp :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: M :: A :: M :: P :: U :: nil) ((Oo :: Bp :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpMPUmtmp;try rewrite HT2 in HOoABpMPUmtmp.
	assert(HT := rule_2 (Oo :: Bp :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 4 1 2 HOoABpMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HOoBpMM : rk(Oo :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpMeq HOoBpMM3).
assert(HOoBpMm : rk(Oo :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoBpMeq HOoBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpM *)
(* dans la couche 0 *)
Lemma LOoAApBpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMQSp requis par la preuve de (?)OoAApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMQSp requis par la preuve de (?)OoAApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMQSp requis par la preuve de (?)OoAApBpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMQSpm2 : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMQSpm3 : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMQSpm4 : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpMQSpM : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpMQSpm : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApBpMQSpeq HOoAApBpMQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpM *)
(* dans la couche 0 *)
Lemma LOoApBpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpMQSp requis par la preuve de (?)OoApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpMQSp requis par la preuve de (?)OoApBpMQSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpMQSp requis par la preuve de (?)OoApBpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMQSpm2 : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApBpMQSpM3 : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Bp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Ap :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 2 2 1 HOoApBpMtmp HApMQSpMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMQSpm3 : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoApMeq : rk(Oo :: Ap :: M :: nil) = 3) by (apply LOoApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMmtmp : rk(Oo :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoApMeq HOoApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) 3 3 HOoApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpMQSpM : rk(Oo :: Ap :: Bp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpMQSpm : rk(Oo :: Ap :: Bp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApBpMQSpeq HOoApBpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpM requis par la preuve de (?)ABpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpM requis par la preuve de (?)ABpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMm2 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMm3 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpM requis par la preuve de (?)ABpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: M ::  de rang :  3 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABpMm2 : rk(A :: Bp :: M :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpMmtmp : rk(Oo :: A :: B :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoABBpMeq HOoABBpMm3).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: A :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: Bp :: M :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMmtmp;try rewrite HT2 in HOoABBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: Bp :: M :: nil) (A :: Bp :: nil) 3 2 3 HOoABBpMmtmp HABpmtmp HOoABBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpMm3 : rk(A :: Bp :: M :: nil) >= 3).
{
	try assert(HOoApBpMQSpeq : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMQSpMtmp : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMQSpeq HOoApBpMQSpM3).
	try assert(HOoAApBpMQSpeq : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMQSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMQSpeq HOoAApBpMQSpm4).
	try assert(HBpMeq : rk(Bp :: M :: nil) = 2) by (apply LBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMmtmp : rk(Bp :: M :: nil) >= 2) by (solve_hyps_min HBpMeq HBpMm2).
	assert(Hincl : incl (Bp :: M :: nil) (list_inter (A :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) (A :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) ((A :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMQSpmtmp;try rewrite HT2 in HOoAApBpMQSpmtmp.
	assert(HT := rule_2 (A :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Bp :: M :: nil) 4 2 3 HOoAApBpMQSpmtmp HBpMmtmp HOoApBpMQSpMtmp Hincl);apply HT.
}


assert(HABpMM : rk(A :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABpMeq HABpMM3).
assert(HABpMm : rk(A :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HABpMeq HABpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpM requis par la preuve de (?)OoABpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMm2 : rk(Oo :: A :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMm3 : rk(Oo :: A :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpMm4 : rk(Oo :: A :: Bp :: M :: nil) >= 4).
{
	try assert(HOoApBpMQSpeq : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMQSpMtmp : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMQSpeq HOoApBpMQSpM3).
	try assert(HOoAApBpMQSpeq : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMQSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMQSpeq HOoAApBpMQSpm4).
	try assert(HOoBpMeq : rk(Oo :: Bp :: M :: nil) = 3) by (apply LOoBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpMmtmp : rk(Oo :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoBpMeq HOoBpMm3).
	assert(Hincl : incl (Oo :: Bp :: M :: nil) (list_inter (Oo :: A :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: A :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) ((Oo :: A :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMQSpmtmp;try rewrite HT2 in HOoAApBpMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: Bp :: M :: nil) 4 3 3 HOoAApBpMQSpmtmp HOoBpMmtmp HOoApBpMQSpMtmp Hincl);apply HT.
}


assert(HOoABpMM : rk(Oo :: A :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMm : rk(Oo :: A :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoABpMeq HOoABpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBBpM *)
(* dans la couche 0 *)
Lemma LOoBApBpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpMQSp requis par la preuve de (?)OoBApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpMQSp requis par la preuve de (?)OoBApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpMQSp requis par la preuve de (?)OoBApBpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpMQSpm2 : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpMQSpm3 : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpMQSpm4 : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBApMeq : rk(Oo :: B :: Ap :: M :: nil) = 4) by (apply LOoBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMmtmp : rk(Oo :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoBApMeq HOoBApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) 4 4 HOoBApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApBpMQSpM : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpMQSpm : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApBpMQSpeq HOoBApBpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpM requis par la preuve de (?)OoBBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpM requis par la preuve de (?)OoBBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpM requis par la preuve de (?)OoBBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpMm2 : rk(Oo :: B :: Bp :: M :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: M :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpMm3 : rk(Oo :: B :: Bp :: M :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: M :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBBpMm4 : rk(Oo :: B :: Bp :: M :: nil) >= 4).
{
	try assert(HOoApBpMQSpeq : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMQSpMtmp : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMQSpeq HOoApBpMQSpM3).
	try assert(HOoBApBpMQSpeq : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoBApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpMQSpmtmp : rk(Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApBpMQSpeq HOoBApBpMQSpm4).
	try assert(HOoBpMeq : rk(Oo :: Bp :: M :: nil) = 3) by (apply LOoBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpMmtmp : rk(Oo :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoBpMeq HOoBpMm3).
	assert(Hincl : incl (Oo :: Bp :: M :: nil) (list_inter (Oo :: B :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: B :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) ((Oo :: B :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpMQSpmtmp;try rewrite HT2 in HOoBApBpMQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: Bp :: M :: nil) 4 3 3 HOoBApBpMQSpmtmp HOoBpMmtmp HOoApBpMQSpMtmp Hincl);apply HT.
}


assert(HOoBBpMM : rk(Oo :: B :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpMm : rk(Oo :: B :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoBBpMeq HOoBBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABBpM *)
(* dans la couche 0 *)
Lemma LOoABApBpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpMQSp requis par la preuve de (?)OoABApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpMQSp requis par la preuve de (?)OoABApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpMQSp requis par la preuve de (?)OoABApBpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpMQSpm2 : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpMQSpm3 : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpMQSpm4 : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpMQSpM : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpMQSpm : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApBpMQSpeq HOoABApBpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpM requis par la preuve de (?)OoABBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMm2 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMm3 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpMm4 : rk(Oo :: A :: B :: Bp :: M :: nil) >= 4).
{
	try assert(HOoApBpMQSpeq : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMQSpMtmp : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMQSpeq HOoApBpMQSpM3).
	try assert(HOoABApBpMQSpeq : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoABApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApBpMQSpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApBpMQSpeq HOoABApBpMQSpm4).
	try assert(HOoBpMeq : rk(Oo :: Bp :: M :: nil) = 3) by (apply LOoBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpMmtmp : rk(Oo :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoBpMeq HOoBpMm3).
	assert(Hincl : incl (Oo :: Bp :: M :: nil) (list_inter (Oo :: A :: B :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpMQSpmtmp;try rewrite HT2 in HOoABApBpMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: Bp :: M :: nil) 4 3 3 HOoABApBpMQSpmtmp HOoBpMmtmp HOoApBpMQSpMtmp Hincl);apply HT.
}


assert(HOoABBpMM : rk(Oo :: A :: B :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpMm : rk(Oo :: A :: B :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoABBpMeq HOoABBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpM *)
(* dans la couche 0 *)
Lemma LOoCApBpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpMQSp requis par la preuve de (?)OoCApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpMQSp requis par la preuve de (?)OoCApBpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpMQSp requis par la preuve de (?)OoCApBpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQSpm2 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQSpm3 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpMQSpm4 : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpMQSpM : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpMQSpm : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApBpMQSpeq HOoCApBpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpM requis par la preuve de (?)CBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpM requis par la preuve de (?)CBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm2 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm3 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpM requis par la preuve de (?)CBpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: M ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpMm2 : rk(C :: Bp :: M :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpMmtmp : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoACBpMeq HOoACBpMm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: M :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMmtmp;try rewrite HT2 in HOoACBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: M :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpMmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpMm3 : rk(C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoApBpMQSpeq : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMQSpMtmp : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApBpMQSpeq HOoApBpMQSpM3).
	try assert(HOoCApBpMQSpeq : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoCApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpMQSpmtmp : rk(Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApBpMQSpeq HOoCApBpMQSpm4).
	try assert(HBpMeq : rk(Bp :: M :: nil) = 2) by (apply LBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMmtmp : rk(Bp :: M :: nil) >= 2) by (solve_hyps_min HBpMeq HBpMm2).
	assert(Hincl : incl (Bp :: M :: nil) (list_inter (C :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: M :: Q :: Sp :: nil) (C :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: M :: Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) ((C :: Bp :: M :: nil) ++ (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpMQSpmtmp;try rewrite HT2 in HOoCApBpMQSpmtmp.
	assert(HT := rule_2 (C :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Bp :: M :: nil) 4 2 3 HOoCApBpMQSpmtmp HBpMmtmp HOoApBpMQSpMtmp Hincl);apply HT.
}


assert(HCBpMM : rk(C :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpMeq HCBpMM3).
assert(HCBpMm : rk(C :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HCBpMeq HCBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACBpM *)
(* dans la couche 0 *)
Lemma LOoACBpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpMPU requis par la preuve de (?)OoACBpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpMPU requis par la preuve de (?)OoACBpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpMPU requis par la preuve de (?)OoACBpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMPUm2 : rk(Oo :: A :: C :: Bp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMPUm3 : rk(Oo :: A :: C :: Bp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: P :: U :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMPUm4 : rk(Oo :: A :: C :: Bp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: M :: P :: U :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACBpMPUM : rk(Oo :: A :: C :: Bp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpMPUm : rk(Oo :: A :: C :: Bp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoACBpMPUeq HOoACBpMPUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACBpM *)
(* dans la couche 0 *)
Lemma LOoACMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: M :: P :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACMPU requis par la preuve de (?)OoACMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACMPU requis par la preuve de (?)OoACMPU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACMPU requis par la preuve de (?)OoACMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMPUm2 : rk(Oo :: A :: C :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACMPUM3 : rk(Oo :: A :: C :: M :: P :: U :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: M :: P :: U :: nil) (Oo :: A :: C :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: M :: P :: U :: nil) ((Oo :: A :: C :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (A :: M :: P :: U :: nil) (A :: nil) 2 2 1 HOoACMtmp HAMPUMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMPUm3 : rk(Oo :: A :: C :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: C :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: C :: M :: P :: U :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACMPUM : rk(Oo :: A :: C :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACMPUm : rk(Oo :: A :: C :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoACMPUeq HOoACMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Bp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpM requis par la preuve de (?)ACBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpM requis par la preuve de (?)ACBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpM requis par la preuve de (?)OoACBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm2 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMm3 : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpM requis par la preuve de (?)ACBpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpM requis par la preuve de (?)ACBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpMm2 : rk(A :: C :: Bp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: M ::  de rang :  3 et 4 	 AiB : A :: C :: Bp ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HACBpMm3 : rk(A :: C :: Bp :: M :: nil) >= 3).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpMmtmp : rk(Oo :: A :: C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoACBpMeq HOoACBpMm3).
	try assert(HACBpeq : rk(A :: C :: Bp :: nil) = 3) by (apply LACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 3) by (solve_hyps_min HACBpeq HACBpm3).
	assert(Hincl : incl (A :: C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (A :: C :: Bp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: A :: C :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: A :: C :: Bp :: M :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (A :: C :: Bp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMmtmp;try rewrite HT2 in HOoACBpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: nil) 3 3 3 HOoACBpMmtmp HACBpmtmp HOoACBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACBpMm4 : rk(A :: C :: Bp :: M :: nil) >= 4).
{
	try assert(HOoACMPUeq : rk(Oo :: A :: C :: M :: P :: U :: nil) = 3) by (apply LOoACMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMPUMtmp : rk(Oo :: A :: C :: M :: P :: U :: nil) <= 3) by (solve_hyps_max HOoACMPUeq HOoACMPUM3).
	try assert(HOoACBpMPUeq : rk(Oo :: A :: C :: Bp :: M :: P :: U :: nil) = 4) by (apply LOoACBpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMPUmtmp : rk(Oo :: A :: C :: Bp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoACBpMPUeq HOoACBpMPUm4).
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hincl : incl (A :: C :: M :: nil) (list_inter (A :: C :: Bp :: M :: nil) (Oo :: A :: C :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: P :: U :: nil) (A :: C :: Bp :: M :: Oo :: A :: C :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: M :: Oo :: A :: C :: M :: P :: U :: nil) ((A :: C :: Bp :: M :: nil) ++ (Oo :: A :: C :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMPUmtmp;try rewrite HT2 in HOoACBpMPUmtmp.
	assert(HT := rule_2 (A :: C :: Bp :: M :: nil) (Oo :: A :: C :: M :: P :: U :: nil) (A :: C :: M :: nil) 4 3 3 HOoACBpMPUmtmp HACMmtmp HOoACMPUMtmp Hincl);apply HT.
}


assert(HACBpMM : rk(A :: C :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpMm : rk(A :: C :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HACBpMeq HACBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpM *)
(* dans constructLemma(), requis par LAApBpMPU *)
(* dans la couche 0 *)
Lemma LAApBpCpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpCpMPU requis par la preuve de (?)AApBpCpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpMPU requis par la preuve de (?)AApBpCpMPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HAApBpCpMPUm3 : rk(A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: A :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) ((Oo :: A :: nil) ++ (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (A :: nil) 4 1 2 HOoAApBpCpMPUmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpCpMPUm4 : rk(A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Ap :: Bp :: nil) 4 2 2 HOoAApBpCpMPUmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HAApBpCpMPUM : rk(A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpMPUm : rk(A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HAApBpCpMPUeq HAApBpCpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Bp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpMPU requis par la preuve de (?)AApBpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMPU requis par la preuve de (?)AApBpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMPU requis par la preuve de (?)OoAApBpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMPU requis par la preuve de (?)OoAApBpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMPUm2 : rk(Oo :: A :: Ap :: Bp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMPUm3 : rk(Oo :: A :: Ap :: Bp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: P :: U :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpMPU requis par la preuve de (?)AApBpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpMPU requis par la preuve de (?)AApBpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpMPUm2 : rk(A :: Ap :: Bp :: M :: P :: U :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: M :: P :: U :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: P :: U ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpMPUm3 : rk(A :: Ap :: Bp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: M :: P :: U :: nil) >= 3) by (solve_hyps_min HOoAApBpMPUeq HOoAApBpMPUm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMPUmtmp;try rewrite HT2 in HOoAApBpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: M :: P :: U :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpMPUmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpMPUM1. try clear HOoAApBpMPUM2. try clear HOoAApBpMPUM3. try clear HOoAApBpMPUm4. try clear HOoAApBpMPUm3. try clear HOoAApBpMPUm2. try clear HOoAApBpMPUm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HAApBpMPUm4 : rk(A :: Ap :: Bp :: M :: P :: U :: nil) >= 4).
{
	try assert(HApBpCpeq : rk(Ap :: Bp :: Cp :: nil) = 2) by (apply LApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpCpMtmp : rk(Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HApBpCpeq HApBpCpM2).
	try assert(HAApBpCpMPUeq : rk(A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpCpMPUmtmp : rk(A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HAApBpCpMPUeq HAApBpCpMPUm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Ap :: Bp :: Cp :: A :: Ap :: Bp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: A :: Ap :: Bp :: M :: P :: U :: nil) ((Ap :: Bp :: Cp :: nil) ++ (A :: Ap :: Bp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpMPUmtmp;try rewrite HT2 in HAApBpCpMPUmtmp.
	assert(HT := rule_4 (Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: M :: P :: U :: nil) (Ap :: Bp :: nil) 4 2 2 HAApBpCpMPUmtmp HApBpmtmp HApBpCpMtmp Hincl); apply HT.
}


assert(HAApBpMPUM : rk(A :: Ap :: Bp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpMPUm : rk(A :: Ap :: Bp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HAApBpMPUeq HAApBpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpM requis par la preuve de (?)ApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpM requis par la preuve de (?)ApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpMm2 : rk(Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: M :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpMm3 : rk(Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HAApBpMPUeq : rk(A :: Ap :: Bp :: M :: P :: U :: nil) = 4) by (apply LAApBpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApBpMPUmtmp : rk(A :: Ap :: Bp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HAApBpMPUeq HAApBpMPUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: Bp :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: M :: P :: U :: nil) (Ap :: Bp :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: M :: A :: M :: P :: U :: nil) ((Ap :: Bp :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpMPUmtmp;try rewrite HT2 in HAApBpMPUmtmp.
	assert(HT := rule_2 (Ap :: Bp :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 4 1 2 HAApBpMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HApBpMM : rk(Ap :: Bp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpMeq HApBpMM3).
assert(HApBpMm : rk(Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HApBpMeq HApBpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpM requis par la preuve de (?)OoApBpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMm2 : rk(Oo :: Ap :: Bp :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpMM3 : rk(Oo :: Ap :: Bp :: M :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: nil) (Oo :: Ap :: Bp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (M :: nil) (nil) 2 1 0 HOoApBpMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpMm3 : rk(Oo :: Ap :: Bp :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoApBpMQSpeq : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMQSpmtmp : rk(Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoApBpMQSpeq HOoApBpMQSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Bp :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpMQSpmtmp;try rewrite HT2 in HOoApBpMQSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HOoApBpMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoApBpMM : rk(Oo :: Ap :: Bp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpMm : rk(Oo :: Ap :: Bp :: M ::  nil) >= 1) by (solve_hyps_min HOoApBpMeq HOoApBpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpM *)
(* dans la couche 0 *)
Lemma LACpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: P :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpMPU requis par la preuve de (?)ACpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMPU requis par la preuve de (?)ACpMPU pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMPU requis par la preuve de (?)ACpMPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HACpMPUm2 : rk(A :: Cp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: A :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Cp :: M :: P :: U :: nil) (nil) 4 0 2 HOoAApBpCpMPUmtmp Hmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACpMPUM3 : rk(A :: Cp :: M :: P :: U :: nil) <= 3).
{
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: P :: U :: nil) (Cp :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: M :: P :: U :: nil) ((Cp :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: M :: P :: U :: nil) (nil) 1 2 0 HCpMtmp HAMPUMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HACpMPUm3 : rk(A :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPUeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMPUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMPUeq HOoAApCpMPUm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Cp :: A :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPUmtmp;try rewrite HT2 in HOoAApCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Cp :: M :: P :: U :: nil) (Cp :: nil) 4 1 2 HOoAApCpMPUmtmp HCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HACpMPUM : rk(A :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMPUm : rk(A :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HACpMPUeq HACpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpM requis par la preuve de (?)CpM pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpMm2 : rk(Cp :: M :: nil) >= 2).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HACpMPUeq : rk(A :: Cp :: M :: P :: U :: nil) = 3) by (apply LACpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMPUmtmp : rk(A :: Cp :: M :: P :: U :: nil) >= 3) by (solve_hyps_min HACpMPUeq HACpMPUm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Cp :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: P :: U :: nil) (Cp :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: M :: A :: M :: P :: U :: nil) ((Cp :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMPUmtmp;try rewrite HT2 in HACpMPUmtmp.
	assert(HT := rule_2 (Cp :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 3 1 2 HACpMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HCpMM : rk(Cp :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpMeq HCpMM2).
assert(HCpMm : rk(Cp :: M ::  nil) >= 1) by (solve_hyps_min HCpMeq HCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpM *)
(* dans la couche 0 *)
Lemma LOoACpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpMPU requis par la preuve de (?)OoACpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpMPU requis par la preuve de (?)OoACpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpMPU requis par la preuve de (?)OoACpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMPUm2 : rk(Oo :: A :: Cp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoACpMPUm3 : rk(Oo :: A :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: Cp :: M :: P :: U :: nil) (Oo :: nil) 4 1 2 HOoAApBpCpMPUmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoACpMPUm4 : rk(Oo :: A :: Cp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPUeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMPUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMPUeq HOoAApCpMPUm4).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Cp :: Oo :: A :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPUmtmp;try rewrite HT2 in HOoAApCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: Cp :: M :: P :: U :: nil) (Oo :: Cp :: nil) 4 2 2 HOoAApCpMPUmtmp HOoCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoACpMPUM : rk(Oo :: A :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpMPUm : rk(Oo :: A :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoACpMPUeq HOoACpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpM requis par la preuve de (?)OoCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpM requis par la preuve de (?)OoCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpMm2 : rk(Oo :: Cp :: M :: nil) >= 2).
{
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: M :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpMm3 : rk(Oo :: Cp :: M :: nil) >= 3).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HOoACpMPUeq : rk(Oo :: A :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoACpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMPUmtmp : rk(Oo :: A :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoACpMPUeq HOoACpMPUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Oo :: Cp :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: M :: P :: U :: nil) (Oo :: Cp :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: M :: A :: M :: P :: U :: nil) ((Oo :: Cp :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpMPUmtmp;try rewrite HT2 in HOoACpMPUmtmp.
	assert(HT := rule_2 (Oo :: Cp :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 4 1 2 HOoACpMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HOoCpMM : rk(Oo :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpMeq HOoCpMM3).
assert(HOoCpMm : rk(Oo :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoCpMeq HOoCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpM *)
(* dans la couche 0 *)
Lemma LOoAApCpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpMQSp requis par la preuve de (?)OoAApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpMQSp requis par la preuve de (?)OoAApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpMQSp requis par la preuve de (?)OoAApCpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMQSpm2 : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMQSpm3 : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMQSpm4 : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApCpMQSpM : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpMQSpm : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApCpMQSpeq HOoAApCpMQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpM *)
(* dans la couche 0 *)
Lemma LOoApCpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Cp :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpMQSp requis par la preuve de (?)OoApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpMQSp requis par la preuve de (?)OoApCpMQSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpMQSp requis par la preuve de (?)OoApCpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpMQSpm2 : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApCpMQSpM3 : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Cp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Ap :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: nil) 2 2 1 HOoApCpMtmp HApMQSpMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpMQSpm3 : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoApMeq : rk(Oo :: Ap :: M :: nil) = 3) by (apply LOoApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMmtmp : rk(Oo :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoApMeq HOoApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: M :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: M :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) 3 3 HOoApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpMQSpM : rk(Oo :: Ap :: Cp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpMQSpm : rk(Oo :: Ap :: Cp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApCpMQSpeq HOoApCpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpM requis par la preuve de (?)ACpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpM requis par la preuve de (?)ACpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpM requis par la preuve de (?)OoABCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpM requis par la preuve de (?)OoABCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMm2 : rk(Oo :: A :: B :: Cp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMm3 : rk(Oo :: A :: B :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpM requis par la preuve de (?)ACpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMm2 : rk(A :: Cp :: M :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMmtmp : rk(Oo :: A :: B :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoABCpMeq HOoABCpMm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMmtmp;try rewrite HT2 in HOoABCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMM1. try clear HOoABCpMM2. try clear HOoABCpMM3. try clear HOoABCpMm4. try clear HOoABCpMm3. try clear HOoABCpMm2. try clear HOoABCpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpMm3 : rk(A :: Cp :: M :: nil) >= 3).
{
	try assert(HOoApCpMQSpeq : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMQSpMtmp : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApCpMQSpeq HOoApCpMQSpM3).
	try assert(HOoAApCpMQSpeq : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMQSpmtmp : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApCpMQSpeq HOoAApCpMQSpm4).
	try assert(HCpMeq : rk(Cp :: M :: nil) = 2) by (apply LCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMmtmp : rk(Cp :: M :: nil) >= 2) by (solve_hyps_min HCpMeq HCpMm2).
	assert(Hincl : incl (Cp :: M :: nil) (list_inter (A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) (A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) ((A :: Cp :: M :: nil) ++ (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMQSpmtmp;try rewrite HT2 in HOoAApCpMQSpmtmp.
	assert(HT := rule_2 (A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) (Cp :: M :: nil) 4 2 3 HOoAApCpMQSpmtmp HCpMmtmp HOoApCpMQSpMtmp Hincl);apply HT.
}
try clear HCpMM1. try clear HCpMM2. try clear HCpMM3. try clear HCpMm4. try clear HCpMm3. try clear HCpMm2. try clear HCpMm1. 

assert(HACpMM : rk(A :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpMeq HACpMM3).
assert(HACpMm : rk(A :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACpMeq HACpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpM requis par la preuve de (?)OoACpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpM requis par la preuve de (?)OoACpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpM requis par la preuve de (?)OoACpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMm2 : rk(Oo :: A :: Cp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMm3 : rk(Oo :: A :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpMm4 : rk(Oo :: A :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpMQSpeq : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMQSpMtmp : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) <= 3) by (solve_hyps_max HOoApCpMQSpeq HOoApCpMQSpM3).
	try assert(HOoAApCpMQSpeq : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMQSpmtmp : rk(Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApCpMQSpeq HOoAApCpMQSpm4).
	try assert(HOoCpMeq : rk(Oo :: Cp :: M :: nil) = 3) by (apply LOoCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpMmtmp : rk(Oo :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoCpMeq HOoCpMm3).
	assert(Hincl : incl (Oo :: Cp :: M :: nil) (list_inter (Oo :: A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: M :: Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) ((Oo :: A :: Cp :: M :: nil) ++ (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMQSpmtmp;try rewrite HT2 in HOoAApCpMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: Cp :: M :: nil) 4 3 3 HOoAApCpMQSpmtmp HOoCpMmtmp HOoApCpMQSpMtmp Hincl);apply HT.
}


assert(HOoACpMM : rk(Oo :: A :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpMm : rk(Oo :: A :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoACpMeq HOoACpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACCpM *)
(* dans la couche 0 *)
Lemma LOoACCpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpMPU requis par la preuve de (?)OoACCpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpMPU requis par la preuve de (?)OoACCpMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpMPU requis par la preuve de (?)OoACCpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMPUm2 : rk(Oo :: A :: C :: Cp :: M :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMPUm3 : rk(Oo :: A :: C :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: P :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMPUm4 : rk(Oo :: A :: C :: Cp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoACpMeq : rk(Oo :: A :: Cp :: M :: nil) = 4) by (apply LOoACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMmtmp : rk(Oo :: A :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACpMeq HOoACpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: M :: P :: U :: nil) 4 4 HOoACpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACCpMPUM : rk(Oo :: A :: C :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpMPUm : rk(Oo :: A :: C :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoACCpMPUeq HOoACCpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMm2 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: M :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMm3 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpMm2 : rk(A :: C :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: M ::  de rang :  3 et 4 	 AiB : A :: C :: Cp ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HACCpMm3 : rk(A :: C :: Cp :: M :: nil) >= 3).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpMmtmp : rk(Oo :: A :: C :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoACCpMeq HOoACCpMm3).
	try assert(HACCpeq : rk(A :: C :: Cp :: nil) = 3) by (apply LACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 3) by (solve_hyps_min HACCpeq HACCpm3).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (A :: C :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: A :: C :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: A :: C :: Cp :: M :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (A :: C :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpMmtmp;try rewrite HT2 in HOoACCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: nil) 3 3 3 HOoACCpMmtmp HACCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpMM1. try clear HOoACCpMM2. try clear HOoACCpMM3. try clear HOoACCpMm4. try clear HOoACCpMm3. try clear HOoACCpMm2. try clear HOoACCpMm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACCpMm4 : rk(A :: C :: Cp :: M :: nil) >= 4).
{
	try assert(HOoACMPUeq : rk(Oo :: A :: C :: M :: P :: U :: nil) = 3) by (apply LOoACMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMPUMtmp : rk(Oo :: A :: C :: M :: P :: U :: nil) <= 3) by (solve_hyps_max HOoACMPUeq HOoACMPUM3).
	try assert(HOoACCpMPUeq : rk(Oo :: A :: C :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoACCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMPUmtmp : rk(Oo :: A :: C :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoACCpMPUeq HOoACCpMPUm4).
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hincl : incl (A :: C :: M :: nil) (list_inter (A :: C :: Cp :: M :: nil) (Oo :: A :: C :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: M :: P :: U :: nil) (A :: C :: Cp :: M :: Oo :: A :: C :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: M :: Oo :: A :: C :: M :: P :: U :: nil) ((A :: C :: Cp :: M :: nil) ++ (Oo :: A :: C :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpMPUmtmp;try rewrite HT2 in HOoACCpMPUmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: M :: nil) (Oo :: A :: C :: M :: P :: U :: nil) (A :: C :: M :: nil) 4 3 3 HOoACCpMPUmtmp HACMmtmp HOoACMPUMtmp Hincl);apply HT.
}


assert(HACCpMM : rk(A :: C :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpMm : rk(A :: C :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACCpMeq HACCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpM *)
(* dans la couche 0 *)
Lemma LAApCpMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Cp :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpMPU requis par la preuve de (?)AApCpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpMPU requis par la preuve de (?)AApCpMPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpMPU requis par la preuve de (?)AApCpMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApCpMPUm2 : rk(A :: Ap :: Cp :: M :: P :: U :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: M :: P :: U :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApCpMPUm3 : rk(A :: Ap :: Cp :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMPUeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApBpCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpCpMPUmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMPUeq HOoAApBpCpMPUm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMPUmtmp;try rewrite HT2 in HOoAApBpCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Cp :: M :: P :: U :: nil) (Ap :: nil) 4 1 2 HOoAApBpCpMPUmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M :: P :: U ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApCpMPUm4 : rk(A :: Ap :: Cp :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMPUeq : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoAApCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpMPUmtmp : rk(Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApCpMPUeq HOoAApCpMPUm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: P :: U :: nil) (Oo :: Ap :: Cp :: A :: Ap :: Cp :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: Cp :: M :: P :: U :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: Cp :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMPUmtmp;try rewrite HT2 in HOoAApCpMPUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: M :: P :: U :: nil) (Ap :: Cp :: nil) 4 2 2 HOoAApCpMPUmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HAApCpMPUM : rk(A :: Ap :: Cp :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpMPUm : rk(A :: Ap :: Cp :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HAApCpMPUeq HAApCpMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpM requis par la preuve de (?)ApCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpM requis par la preuve de (?)ApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpMm2 : rk(Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: M :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApCpMm3 : rk(Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HAApCpMPUeq : rk(A :: Ap :: Cp :: M :: P :: U :: nil) = 4) by (apply LAApCpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApCpMPUmtmp : rk(A :: Ap :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HAApCpMPUeq HAApCpMPUm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: Cp :: M :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: M :: P :: U :: nil) (Ap :: Cp :: M :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: M :: A :: M :: P :: U :: nil) ((Ap :: Cp :: M :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpMPUmtmp;try rewrite HT2 in HAApCpMPUmtmp.
	assert(HT := rule_2 (Ap :: Cp :: M :: nil) (A :: M :: P :: U :: nil) (M :: nil) 4 1 2 HAApCpMPUmtmp HMmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HApCpMM : rk(Ap :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpMeq HApCpMM3).
assert(HApCpMm : rk(Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HApCpMeq HApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpMm2 : rk(Oo :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Cp :: M :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApCpMM3 : rk(Oo :: Ap :: Cp :: M :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Cp :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (M :: nil) (nil) 2 1 0 HOoApCpMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApCpMm3 : rk(Oo :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoApCpMQSpeq : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) = 3) by (apply LOoApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMQSpmtmp : rk(Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoApCpMQSpeq HOoApCpMQSpm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: Ap :: Cp :: M :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Cp :: M :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: Ap :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Cp :: M :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpMQSpmtmp;try rewrite HT2 in HOoApCpMQSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Cp :: M :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 3 2 2 HOoApCpMQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoApCpMM : rk(Oo :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpMm : rk(Oo :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoApCpMeq HOoApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HNM : rk(N ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HNeq HNM1).
assert(HNm : rk(N ::  nil) >= 1) by (solve_hyps_min HNeq HNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAN *)
(* dans la couche 0 *)
Lemma LOoABpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNPT requis par la preuve de (?)OoABpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNPT requis par la preuve de (?)OoABpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNPT requis par la preuve de (?)OoABpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNPTm2 : rk(Oo :: A :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABpNPTm3 : rk(Oo :: A :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoACBpNPTeq : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNPTmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (C :: Oo :: A :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Bp :: N :: P :: T :: nil) ((C :: nil) ++ (Oo :: A :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPTmtmp;try rewrite HT2 in HOoACBpNPTmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: Bp :: N :: P :: T :: nil) (nil) 4 0 1 HOoACBpNPTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoABpNPTm4 : rk(Oo :: A :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPTeq : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNPTmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm4).
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: A :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: Oo :: A :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: A :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: A :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPTmtmp;try rewrite HT2 in HOoACBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: A :: Bp :: N :: P :: T :: nil) (Oo :: A :: nil) 4 2 2 HOoACBpNPTmtmp HOoAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoABpNPTM : rk(Oo :: A :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNPTm : rk(Oo :: A :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoABpNPTeq HOoABpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAN requis par la preuve de (?)OoAN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAN requis par la preuve de (?)OoAN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoANm2 : rk(Oo :: A :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoANm3 : rk(Oo :: A :: N :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoABpNPTeq : rk(Oo :: A :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNPTmtmp : rk(Oo :: A :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABpNPTeq HOoABpNPTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: A :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: T :: nil) (Oo :: A :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: N :: Bp :: N :: P :: T :: nil) ((Oo :: A :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPTmtmp;try rewrite HT2 in HOoABpNPTmtmp.
	assert(HT := rule_2 (Oo :: A :: N :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 4 1 2 HOoABpNPTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoANM : rk(Oo :: A :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoANeq HOoANM3).
assert(HOoANm : rk(Oo :: A :: N ::  nil) >= 1) by (solve_hyps_min HOoANeq HOoANm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBN *)
(* dans constructLemma(), requis par LBBpNPT *)
(* dans la couche 0 *)
Lemma LOoBCBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNPT requis par la preuve de (?)OoBCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNPT requis par la preuve de (?)OoBCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCBpNPTm3 : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: Oo :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNPTmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoBCBpNPTm4 : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: Oo :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: B :: nil) 4 2 2 HOoABCBpNPTmtmp HOoBmtmp HOoABMtmp Hincl); apply HT.
}


assert(HOoBCBpNPTM : rk(Oo :: B :: C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpNPTm : rk(Oo :: B :: C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBCBpNPTeq HOoBCBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: N :: P :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpNPT requis par la preuve de (?)BBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpNPT requis par la preuve de (?)BBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpNPT requis par la preuve de (?)BCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpNPT requis par la preuve de (?)BCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HBCBpNPTm2 : rk(B :: C :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: nil) (B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: nil) ++ (B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (B :: C :: Bp :: N :: P :: T :: nil) (nil) 4 0 2 HOoABCBpNPTmtmp Hmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCBpNPTm3 : rk(B :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Bp :: N :: P :: T :: nil) (B :: nil) 4 1 2 HOoABCBpNPTmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpNPT requis par la preuve de (?)BBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpNPT requis par la preuve de (?)BBpNPT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBBpNPTM3 : rk(B :: Bp :: N :: P :: T :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: P :: T :: nil) (B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: N :: P :: T :: nil) ((B :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: N :: P :: T :: nil) (nil) 1 2 0 HBMtmp HBpNPTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: N :: P :: T ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HBBpNPTm2 : rk(B :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBCBpNPTmtmp : rk(B :: C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HBCBpNPTeq HBCBpNPTm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (B :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: N :: P :: T :: nil) (C :: B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: B :: Bp :: N :: P :: T :: nil) ((C :: nil) ++ (B :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpNPTmtmp;try rewrite HT2 in HBCBpNPTmtmp.
	assert(HT := rule_4 (C :: nil) (B :: Bp :: N :: P :: T :: nil) (nil) 3 0 1 HBCBpNPTmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HBCBpNPTM1. try clear HBCBpNPTM2. try clear HBCBpNPTM3. try clear HBCBpNPTm4. try clear HBCBpNPTm3. try clear HBCBpNPTm2. try clear HBCBpNPTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HBBpNPTm3 : rk(B :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCBpNPTeq : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNPTmtmp : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNPTeq HOoBCBpNPTm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: B :: C :: B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: Bp :: N :: P :: T :: nil) ((Oo :: B :: C :: nil) ++ (B :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNPTmtmp;try rewrite HT2 in HOoBCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (B :: Bp :: N :: P :: T :: nil) (B :: nil) 4 1 2 HOoBCBpNPTmtmp HBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HBBpNPTM : rk(B :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpNPTm : rk(B :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HBBpNPTeq HBBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BN requis par la preuve de (?)BN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBNm2 : rk(B :: N :: nil) >= 2).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HBBpNPTeq : rk(B :: Bp :: N :: P :: T :: nil) = 3) by (apply LBBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpNPTmtmp : rk(B :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HBBpNPTeq HBBpNPTm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (B :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: P :: T :: nil) (B :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: N :: Bp :: N :: P :: T :: nil) ((B :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpNPTmtmp;try rewrite HT2 in HBBpNPTmtmp.
	assert(HT := rule_2 (B :: N :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 3 1 2 HBBpNPTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HBNM : rk(B :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBNeq HBNM2).
assert(HBNm : rk(B :: N ::  nil) >= 1) by (solve_hyps_min HBNeq HBNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBN *)
(* dans la couche 0 *)
Lemma LOoBBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpNPT requis par la preuve de (?)OoBBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpNPT requis par la preuve de (?)OoBBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpNPT requis par la preuve de (?)OoBBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNPTm2 : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBBpNPTm3 : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoBCBpNPTeq : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNPTmtmp : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNPTeq HOoBCBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (C :: Oo :: B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Bp :: N :: P :: T :: nil) ((C :: nil) ++ (Oo :: B :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNPTmtmp;try rewrite HT2 in HOoBCBpNPTmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil) (nil) 4 0 1 HOoBCBpNPTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: B ::  de rang :  2 et 2 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBBpNPTm4 : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoBCBpNPTeq : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNPTmtmp : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNPTeq HOoBCBpNPTm4).
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hincl : incl (Oo :: B :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: B :: C :: Oo :: B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: B :: Bp :: N :: P :: T :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: B :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNPTmtmp;try rewrite HT2 in HOoBCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil) (Oo :: B :: nil) 4 2 2 HOoBCBpNPTmtmp HOoBmtmp HOoBCMtmp Hincl); apply HT.
}


assert(HOoBBpNPTM : rk(Oo :: B :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpNPTm : rk(Oo :: B :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBBpNPTeq HOoBBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBN requis par la preuve de (?)OoBN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBN requis par la preuve de (?)OoBN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBNm2 : rk(Oo :: B :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBNm3 : rk(Oo :: B :: N :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoBBpNPTeq : rk(Oo :: B :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNPTmtmp : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBBpNPTeq HOoBBpNPTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: B :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: N :: P :: T :: nil) (Oo :: B :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: N :: Bp :: N :: P :: T :: nil) ((Oo :: B :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpNPTmtmp;try rewrite HT2 in HOoBBpNPTmtmp.
	assert(HT := rule_2 (Oo :: B :: N :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 4 1 2 HOoBBpNPTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoBNM : rk(Oo :: B :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBNeq HOoBNM3).
assert(HOoBNm : rk(Oo :: B :: N ::  nil) >= 1) by (solve_hyps_min HOoBNeq HOoBNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABN *)
(* dans constructLemma(), requis par LABBpNPT *)
(* dans la couche 0 *)
Lemma LABCBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCBpNPT requis par la preuve de (?)ABCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpNPT requis par la preuve de (?)ABCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HABCBpNPTm3 : rk(A :: B :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: nil) (A :: B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: A :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: A :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: nil) ++ (A :: B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (A :: B :: C :: Bp :: N :: P :: T :: nil) (A :: nil) 4 1 2 HOoABCBpNPTmtmp HAmtmp HOoAMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCBpNPTm4 : rk(A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: A :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Bp :: N :: P :: T :: nil) (A :: B :: nil) 4 2 2 HOoABCBpNPTmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCBpNPTM : rk(A :: B :: C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpNPTm : rk(A :: B :: C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HABCBpNPTeq HABCBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpNPT requis par la preuve de (?)ABBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpNPT requis par la preuve de (?)ABBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpNPT requis par la preuve de (?)ABBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpNPTm2 : rk(A :: B :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Bp :: N :: P :: T :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABBpNPTm3 : rk(A :: B :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCBpNPTeq : rk(A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCBpNPTmtmp : rk(A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HABCBpNPTeq HABCBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: N :: P :: T :: nil) (C :: A :: B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Bp :: N :: P :: T :: nil) ((C :: nil) ++ (A :: B :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpNPTmtmp;try rewrite HT2 in HABCBpNPTmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Bp :: N :: P :: T :: nil) (nil) 4 0 1 HABCBpNPTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABBpNPTm4 : rk(A :: B :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCBpNPTeq : rk(A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCBpNPTmtmp : rk(A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HABCBpNPTeq HABCBpNPTm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: N :: P :: T :: nil) (A :: B :: C :: A :: B :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Bp :: N :: P :: T :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpNPTmtmp;try rewrite HT2 in HABCBpNPTmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Bp :: N :: P :: T :: nil) (A :: B :: nil) 4 2 2 HABCBpNPTmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABBpNPTM : rk(A :: B :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpNPTm : rk(A :: B :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HABBpNPTeq HABBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABN requis par la preuve de (?)ABN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABN requis par la preuve de (?)ABN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABNm2 : rk(A :: B :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABNm3 : rk(A :: B :: N :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HABBpNPTeq : rk(A :: B :: Bp :: N :: P :: T :: nil) = 4) by (apply LABBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABBpNPTmtmp : rk(A :: B :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HABBpNPTeq HABBpNPTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (A :: B :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: N :: P :: T :: nil) (A :: B :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: N :: Bp :: N :: P :: T :: nil) ((A :: B :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpNPTmtmp;try rewrite HT2 in HABBpNPTmtmp.
	assert(HT := rule_2 (A :: B :: N :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 4 1 2 HABBpNPTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HABNM : rk(A :: B :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABNeq HABNM3).
assert(HABNm : rk(A :: B :: N ::  nil) >= 1) by (solve_hyps_min HABNeq HABNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABN *)
(* dans la couche 0 *)
Lemma LOoABApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQSp requis par la preuve de (?)OoABApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQSp requis par la preuve de (?)OoABApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQSp requis par la preuve de (?)OoABApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMNQSpM : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMNQSpm : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApMNQSpeq HOoABApMNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABN *)
(* dans la couche 0 *)
Lemma LOoAApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMNQSp requis par la preuve de (?)OoAApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMNQSp requis par la preuve de (?)OoAApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMNQSp requis par la preuve de (?)OoAApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpm2 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpm3 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpm4 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMNQSpM : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMNQSpm : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApMNQSpeq HOoAApMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABN requis par la preuve de (?)OoABN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABN requis par la preuve de (?)OoABN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABN requis par la preuve de (?)OoABN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNm2 : rk(Oo :: A :: B :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABNM3 : rk(Oo :: A :: B :: N :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: nil) (Oo :: A :: B :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: nil) ((Oo :: A :: B :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (N :: nil) (nil) 2 1 0 HOoABMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABNm3 : rk(Oo :: A :: B :: N :: nil) >= 3).
{
	try assert(HOoAApMNQSpeq : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoAApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMNQSpMtmp : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMNQSpeq HOoAApMNQSpM4).
	try assert(HOoABApMNQSpeq : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMNQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMNQSpeq HOoABApMNQSpm4).
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hincl : incl (Oo :: A :: N :: nil) (list_inter (Oo :: A :: B :: N :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: A :: B :: N :: Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) ((Oo :: A :: B :: N :: nil) ++ (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQSpmtmp;try rewrite HT2 in HOoABApMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: N :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: A :: N :: nil) 4 3 4 HOoABApMNQSpmtmp HOoANmtmp HOoAApMNQSpMtmp Hincl);apply HT.
}


assert(HOoABNM : rk(Oo :: A :: B :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABNm : rk(Oo :: A :: B :: N ::  nil) >= 1) by (solve_hyps_min HOoABNeq HOoABNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCN *)
(* dans la couche 0 *)
Lemma LCBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: P :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpNPT requis par la preuve de (?)CBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNPT requis par la preuve de (?)CBpNPT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNPT requis par la preuve de (?)CBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HCBpNPTm2 : rk(C :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (C :: Bp :: N :: P :: T :: nil) (nil) 4 0 2 HOoABCBpNPTmtmp Hmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCBpNPTM3 : rk(C :: Bp :: N :: P :: T :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: P :: T :: nil) (C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: P :: T :: nil) ((C :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Bp :: N :: P :: T :: nil) (nil) 1 2 0 HCMtmp HBpNPTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HCBpNPTm3 : rk(C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPTeq : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNPTmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: nil) ++ (C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPTmtmp;try rewrite HT2 in HOoACBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (C :: Bp :: N :: P :: T :: nil) (C :: nil) 4 1 2 HOoACBpNPTmtmp HCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HCBpNPTM : rk(C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNPTm : rk(C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HCBpNPTeq HCBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CN requis par la preuve de (?)CN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCNm2 : rk(C :: N :: nil) >= 2).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HCBpNPTeq : rk(C :: Bp :: N :: P :: T :: nil) = 3) by (apply LCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNPTmtmp : rk(C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HCBpNPTeq HCBpNPTm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (C :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: P :: T :: nil) (C :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: N :: Bp :: N :: P :: T :: nil) ((C :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpNPTmtmp;try rewrite HT2 in HCBpNPTmtmp.
	assert(HT := rule_2 (C :: N :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 3 1 2 HCBpNPTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HCNM : rk(C :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCNeq HCNM2).
assert(HCNm : rk(C :: N ::  nil) >= 1) by (solve_hyps_min HCNeq HCNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCN *)
(* dans la couche 0 *)
Lemma LOoCBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNPT requis par la preuve de (?)OoBCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCBpNPTm3 : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: Oo :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNPTmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: P :: T ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNPTm2 : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCBpNPTmtmp : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HOoBCBpNPTeq HOoBCBpNPTm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: B :: Oo :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Bp :: N :: P :: T :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNPTmtmp;try rewrite HT2 in HOoBCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 3 1 2 HOoBCBpNPTmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNPTm3 : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: Oo :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNPTmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: C ::  de rang :  2 et 2 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoCBpNPTm4 : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPTeq : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNPTmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm4).
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hincl : incl (Oo :: C :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: Oo :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPTmtmp;try rewrite HT2 in HOoACBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: C :: nil) 4 2 2 HOoACBpNPTmtmp HOoCmtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoCBpNPTM : rk(Oo :: C :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpNPTm : rk(Oo :: C :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoCBpNPTeq HOoCBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCN requis par la preuve de (?)OoCN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCN requis par la preuve de (?)OoCN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCNm2 : rk(Oo :: C :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCNm3 : rk(Oo :: C :: N :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoCBpNPTeq : rk(Oo :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCBpNPTmtmp : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoCBpNPTeq HOoCBpNPTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: C :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: C :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: N :: Bp :: N :: P :: T :: nil) ((Oo :: C :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpNPTmtmp;try rewrite HT2 in HOoCBpNPTmtmp.
	assert(HT := rule_2 (Oo :: C :: N :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 4 1 2 HOoCBpNPTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoCNM : rk(Oo :: C :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCNeq HOoCNM3).
assert(HOoCNm : rk(Oo :: C :: N ::  nil) >= 1) by (solve_hyps_min HOoCNeq HOoCNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApN *)
(* dans constructLemma(), requis par LBApNQV *)
(* dans constructLemma(), requis par LOoBApCpNQV *)
(* dans la couche 0 *)
Lemma LOoBApBpCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoBApBpCpNQVM : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpCpNQVm : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpNQV requis par la preuve de (?)OoBApCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpNQV requis par la preuve de (?)OoBApCpNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpNQV requis par la preuve de (?)OoBApCpNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpNQVm2 : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpNQVm3 : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBApCpNQVm4 : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: nil) 4 2 2 HOoBApBpCpNQVmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoBApCpNQVM : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpNQVm : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBApCpNQVeq HOoBApCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: N :: Q :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApNQV requis par la preuve de (?)BApNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApNQV requis par la preuve de (?)BApNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BNQV requis par la preuve de (?)BApNQV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApNQV requis par la preuve de (?)BApNQV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBApNQVM3 : rk(B :: Ap :: N :: Q :: V :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: N :: Q :: V :: nil) (Ap :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: N :: Q :: V :: nil) ((Ap :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: N :: Q :: V :: nil) (nil) 1 2 0 HApMtmp HBNQVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApNQVm2 : rk(B :: Ap :: N :: Q :: V :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: N :: Q :: V :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HBApNQVm3 : rk(B :: Ap :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNQVeq : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNQVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNQVeq HOoBApCpNQVm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (B :: Ap :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Cp :: B :: Ap :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: B :: Ap :: N :: Q :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (B :: Ap :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNQVmtmp;try rewrite HT2 in HOoBApCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (B :: Ap :: N :: Q :: V :: nil) (Ap :: nil) 4 1 2 HOoBApCpNQVmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HBApNQVM : rk(B :: Ap :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApNQVm : rk(B :: Ap :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBApNQVeq HBApNQVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApN *)
(* dans la couche 0 *)
Lemma LBNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: N :: Q :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HBNQVM : rk(B :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBNQVm : rk(B :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBNQVeq HBNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApN requis par la preuve de (?)ApN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApNm2 : rk(Ap :: N :: nil) >= 2).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBApNQVeq : rk(B :: Ap :: N :: Q :: V :: nil) = 3) by (apply LBApNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApNQVmtmp : rk(B :: Ap :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HBApNQVeq HBApNQVm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Ap :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: N :: Q :: V :: nil) (Ap :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: N :: B :: N :: Q :: V :: nil) ((Ap :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApNQVmtmp;try rewrite HT2 in HBApNQVmtmp.
	assert(HT := rule_2 (Ap :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 3 1 2 HBApNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HApNM : rk(Ap :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApNeq HApNM2).
assert(HApNm : rk(Ap :: N ::  nil) >= 1) by (solve_hyps_min HApNeq HApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApN *)
(* dans la couche 0 *)
Lemma LOoBApNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApNQV requis par la preuve de (?)OoBApNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApNQV requis par la preuve de (?)OoBApNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApNQV requis par la preuve de (?)OoBApNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNQVm2 : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNQVm3 : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoBApNQVm4 : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNQVeq : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNQVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNQVeq HOoBApCpNQVm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: B :: Ap :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Cp :: Oo :: B :: Ap :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: B :: Ap :: N :: Q :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: B :: Ap :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNQVmtmp;try rewrite HT2 in HOoBApCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: B :: Ap :: N :: Q :: V :: nil) (Oo :: Ap :: nil) 4 2 2 HOoBApCpNQVmtmp HOoApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoBApNQVM : rk(Oo :: B :: Ap :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApNQVm : rk(Oo :: B :: Ap :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBApNQVeq HOoBApNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApN requis par la preuve de (?)OoApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApN requis par la preuve de (?)OoApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApNm2 : rk(Oo :: Ap :: N :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: N :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApNm3 : rk(Oo :: Ap :: N :: nil) >= 3).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HOoBApNQVeq : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) = 4) by (apply LOoBApNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNQVmtmp : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApNQVeq HOoBApNQVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: Ap :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: N :: Q :: V :: nil) (Oo :: Ap :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: N :: B :: N :: Q :: V :: nil) ((Oo :: Ap :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApNQVmtmp;try rewrite HT2 in HOoBApNQVmtmp.
	assert(HT := rule_2 (Oo :: Ap :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 4 1 2 HOoBApNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HOoApNM : rk(Oo :: Ap :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApNeq HOoApNM3).
assert(HOoApNm : rk(Oo :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoApNeq HOoApNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApN requis par la preuve de (?)BApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApN requis par la preuve de (?)BApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm2 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm3 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApN requis par la preuve de (?)BApN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApNm2 : rk(B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoABApNeq HOoABApNm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNmtmp;try rewrite HT2 in HOoABApNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: N :: nil) (B :: Ap :: nil) 3 2 3 HOoABApNmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApNm3 : rk(B :: Ap :: N :: nil) >= 3).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBApNQVeq : rk(B :: Ap :: N :: Q :: V :: nil) = 3) by (apply LBApNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApNQVmtmp : rk(B :: Ap :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HBApNQVeq HBApNQVm3).
	try assert(HBNeq : rk(B :: N :: nil) = 2) by (apply LBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNmtmp : rk(B :: N :: nil) >= 2) by (solve_hyps_min HBNeq HBNm2).
	assert(Hincl : incl (B :: N :: nil) (list_inter (B :: Ap :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: N :: Q :: V :: nil) (B :: Ap :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: N :: B :: N :: Q :: V :: nil) ((B :: Ap :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApNQVmtmp;try rewrite HT2 in HBApNQVmtmp.
	assert(HT := rule_2 (B :: Ap :: N :: nil) (B :: N :: Q :: V :: nil) (B :: N :: nil) 3 2 2 HBApNQVmtmp HBNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HBApNM : rk(B :: Ap :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApNeq HBApNM3).
assert(HBApNm : rk(B :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HBApNeq HBApNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApN requis par la preuve de (?)OoBApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoBApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm2 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm3 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApN requis par la preuve de (?)OoBApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApN requis par la preuve de (?)OoBApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNm2 : rk(Oo :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApNm3 : rk(Oo :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoABApNeq HOoABApNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNmtmp;try rewrite HT2 in HOoABApNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApNm4 : rk(Oo :: B :: Ap :: N :: nil) >= 4).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HOoBApNQVeq : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) = 4) by (apply LOoBApNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNQVmtmp : rk(Oo :: B :: Ap :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApNQVeq HOoBApNQVm4).
	try assert(HBNeq : rk(B :: N :: nil) = 2) by (apply LBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNmtmp : rk(B :: N :: nil) >= 2) by (solve_hyps_min HBNeq HBNm2).
	assert(Hincl : incl (B :: N :: nil) (list_inter (Oo :: B :: Ap :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: N :: Q :: V :: nil) (Oo :: B :: Ap :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: N :: B :: N :: Q :: V :: nil) ((Oo :: B :: Ap :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApNQVmtmp;try rewrite HT2 in HOoBApNQVmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: N :: nil) (B :: N :: Q :: V :: nil) (B :: N :: nil) 4 2 2 HOoBApNQVmtmp HBNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HOoBApNM : rk(Oo :: B :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApNm : rk(Oo :: B :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoBApNeq HOoBApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApN *)
(* dans la couche 0 *)
Lemma LOoABApNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNQV requis par la preuve de (?)OoABApNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNQV requis par la preuve de (?)OoABApNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNQV requis par la preuve de (?)OoABApNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQVm2 : rk(Oo :: A :: B :: Ap :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQVm3 : rk(Oo :: A :: B :: Ap :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: V :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQVm4 : rk(Oo :: A :: B :: Ap :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: N :: Q :: V :: nil) 4 4 HOoBApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApNQVM : rk(Oo :: A :: B :: Ap :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApNQVm : rk(Oo :: A :: B :: Ap :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoABApNQVeq HOoABApNQVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApN *)
(* dans la couche 0 *)
Lemma LOoABNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: N :: Q :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABNQV requis par la preuve de (?)OoABNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABNQV requis par la preuve de (?)OoABNQV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABNQV requis par la preuve de (?)OoABNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQVm2 : rk(Oo :: A :: B :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: Q :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABNQVM3 : rk(Oo :: A :: B :: N :: Q :: V :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: Q :: V :: nil) (Oo :: A :: B :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: N :: Q :: V :: nil) ((Oo :: A :: B :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: N :: Q :: V :: nil) (B :: nil) 2 2 1 HOoABMtmp HBNQVMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNQVm3 : rk(Oo :: A :: B :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: Q :: V :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


assert(HOoABNQVM : rk(Oo :: A :: B :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABNQVm : rk(Oo :: A :: B :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoABNQVeq HOoABNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApN requis par la preuve de (?)ABApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApN requis par la preuve de (?)ABApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm2 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm3 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApN requis par la preuve de (?)ABApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApN requis par la preuve de (?)ABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNm2 : rk(A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApNm3 : rk(A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoABApNeq HOoABApNm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNmtmp;try rewrite HT2 in HOoABApNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApNmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApNm4 : rk(A :: B :: Ap :: N :: nil) >= 4).
{
	try assert(HOoABNQVeq : rk(Oo :: A :: B :: N :: Q :: V :: nil) = 3) by (apply LOoABNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNQVMtmp : rk(Oo :: A :: B :: N :: Q :: V :: nil) <= 3) by (solve_hyps_max HOoABNQVeq HOoABNQVM3).
	try assert(HOoABApNQVeq : rk(Oo :: A :: B :: Ap :: N :: Q :: V :: nil) = 4) by (apply LOoABApNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNQVmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoABApNQVeq HOoABApNQVm4).
	try assert(HABNeq : rk(A :: B :: N :: nil) = 3) by (apply LABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABNmtmp : rk(A :: B :: N :: nil) >= 3) by (solve_hyps_min HABNeq HABNm3).
	assert(Hincl : incl (A :: B :: N :: nil) (list_inter (A :: B :: Ap :: N :: nil) (Oo :: A :: B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: V :: nil) (A :: B :: Ap :: N :: Oo :: A :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: N :: Oo :: A :: B :: N :: Q :: V :: nil) ((A :: B :: Ap :: N :: nil) ++ (Oo :: A :: B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQVmtmp;try rewrite HT2 in HOoABApNQVmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: N :: nil) (Oo :: A :: B :: N :: Q :: V :: nil) (A :: B :: N :: nil) 4 3 3 HOoABApNQVmtmp HABNmtmp HOoABNQVMtmp Hincl);apply HT.
}


assert(HABApNM : rk(A :: B :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApNm : rk(A :: B :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HABApNeq HABApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABApN *)
(* dans la couche 0 *)
Lemma LOoBApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApMNQSp requis par la preuve de (?)OoBApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApMNQSp requis par la preuve de (?)OoBApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApMNQSp requis par la preuve de (?)OoBApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNQSpm2 : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNQSpm3 : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNQSpm4 : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBApMeq : rk(Oo :: B :: Ap :: M :: nil) = 4) by (apply LOoBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMmtmp : rk(Oo :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoBApMeq HOoBApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: M :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HOoBApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApMNQSpM : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMNQSpm : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApMNQSpeq HOoBApMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApN requis par la preuve de (?)OoABApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm2 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNm3 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABApNm4 : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4).
{
	try assert(HOoBApMNQSpeq : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNQSpMtmp : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoBApMNQSpeq HOoBApMNQSpM4).
	try assert(HOoABApMNQSpeq : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMNQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMNQSpeq HOoABApMNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: A :: B :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: A :: B :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) ((Oo :: A :: B :: Ap :: N :: nil) ++ (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQSpmtmp;try rewrite HT2 in HOoABApMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoABApMNQSpmtmp HOoBApNmtmp HOoBApMNQSpMtmp Hincl);apply HT.
}


assert(HOoABApNM : rk(Oo :: A :: B :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApNm : rk(Oo :: A :: B :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoABApNeq HOoABApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApN *)
(* dans la couche 0 *)
Lemma LOoBCApNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNQV requis par la preuve de (?)OoBCApNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNQV requis par la preuve de (?)OoBCApNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNQV requis par la preuve de (?)OoBCApNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNQVm2 : rk(Oo :: B :: C :: Ap :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNQVm3 : rk(Oo :: B :: C :: Ap :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Q :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNQVm4 : rk(Oo :: B :: C :: Ap :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Q :: V :: nil) 4 4 HOoBApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCApNQVM : rk(Oo :: B :: C :: Ap :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNQVm : rk(Oo :: B :: C :: Ap :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBCApNQVeq HOoBCApNQVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApN *)
(* dans la couche 0 *)
Lemma LOoBCNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: N :: Q :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCNQV requis par la preuve de (?)OoBCNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCNQV requis par la preuve de (?)OoBCNQV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCNQV requis par la preuve de (?)OoBCNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCNQVm2 : rk(Oo :: B :: C :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBCNQVM3 : rk(Oo :: B :: C :: N :: Q :: V :: nil) <= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: C :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: N :: Q :: V :: nil) (Oo :: B :: C :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: B :: N :: Q :: V :: nil) ((Oo :: B :: C :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: nil) (B :: N :: Q :: V :: nil) (B :: nil) 2 2 1 HOoBCMtmp HBNQVMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCNQVm3 : rk(Oo :: B :: C :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBNeq : rk(Oo :: B :: N :: nil) = 3) by (apply LOoBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBNmtmp : rk(Oo :: B :: N :: nil) >= 3) by (solve_hyps_min HOoBNeq HOoBNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: N :: nil) (Oo :: B :: C :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: N :: nil) (Oo :: B :: C :: N :: Q :: V :: nil) 3 3 HOoBNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCNQVM : rk(Oo :: B :: C :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCNQVm : rk(Oo :: B :: C :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBCNQVeq HOoBCNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApN requis par la preuve de (?)OoCApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm2 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm3 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApN requis par la preuve de (?)OoCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApN requis par la preuve de (?)OoCApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNm2 : rk(Oo :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: N ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApNm3 : rk(Oo :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApNmtmp : rk(Oo :: A :: C :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoACApNeq HOoACApNm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: N :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApNmtmp;try rewrite HT2 in HOoACApNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApNmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApNm4 : rk(Oo :: C :: Ap :: N :: nil) >= 4).
{
	try assert(HOoBCNQVeq : rk(Oo :: B :: C :: N :: Q :: V :: nil) = 3) by (apply LOoBCNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCNQVMtmp : rk(Oo :: B :: C :: N :: Q :: V :: nil) <= 3) by (solve_hyps_max HOoBCNQVeq HOoBCNQVM3).
	try assert(HOoBCApNQVeq : rk(Oo :: B :: C :: Ap :: N :: Q :: V :: nil) = 4) by (apply LOoBCApNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNQVmtmp : rk(Oo :: B :: C :: Ap :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBCApNQVeq HOoBCApNQVm4).
	try assert(HOoCNeq : rk(Oo :: C :: N :: nil) = 3) by (apply LOoCN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCNmtmp : rk(Oo :: C :: N :: nil) >= 3) by (solve_hyps_min HOoCNeq HOoCNm3).
	assert(Hincl : incl (Oo :: C :: N :: nil) (list_inter (Oo :: C :: Ap :: N :: nil) (Oo :: B :: C :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: N :: Q :: V :: nil) (Oo :: C :: Ap :: N :: Oo :: B :: C :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: N :: Oo :: B :: C :: N :: Q :: V :: nil) ((Oo :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApNQVmtmp;try rewrite HT2 in HOoBCApNQVmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: N :: nil) (Oo :: B :: C :: N :: Q :: V :: nil) (Oo :: C :: N :: nil) 4 3 3 HOoBCApNQVmtmp HOoCNmtmp HOoBCNQVMtmp Hincl);apply HT.
}


assert(HOoCApNM : rk(Oo :: C :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApNm : rk(Oo :: C :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoCApNeq HOoCApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACApN *)
(* dans la couche 0 *)
Lemma LOoACApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMNQSp requis par la preuve de (?)OoACApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMNQSp requis par la preuve de (?)OoACApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMNQSp requis par la preuve de (?)OoACApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNQSpm2 : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNQSpm3 : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNQSpm4 : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApMNQSpM : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMNQSpm : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACApMNQSpeq HOoACApMNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACApN *)
(* dans la couche 0 *)
Lemma LOoCApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMNQSp requis par la preuve de (?)OoCApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMNQSp requis par la preuve de (?)OoCApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMNQSp requis par la preuve de (?)OoCApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNQSpm2 : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNQSpm3 : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNQSpm4 : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApMNQSpM : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMNQSpm : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApMNQSpeq HOoCApMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApN requis par la preuve de (?)OoACApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm2 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNm3 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACApNm4 : rk(Oo :: A :: C :: Ap :: N :: nil) >= 4).
{
	try assert(HOoCApMNQSpeq : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoCApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMNQSpMtmp : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoCApMNQSpeq HOoCApMNQSpM4).
	try assert(HOoACApMNQSpeq : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoACApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMNQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMNQSpeq HOoACApMNQSpm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMNQSpmtmp;try rewrite HT2 in HOoACApMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoACApMNQSpmtmp HOoCApNmtmp HOoCApMNQSpMtmp Hincl);apply HT.
}


assert(HOoACApNM : rk(Oo :: A :: C :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApNm : rk(Oo :: A :: C :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoACApNeq HOoACApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApN *)
(* dans la couche 0 *)
Lemma LOoBCApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApMNQSp requis par la preuve de (?)OoBCApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApMNQSp requis par la preuve de (?)OoBCApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApMNQSp requis par la preuve de (?)OoBCApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMNQSpm2 : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMNQSpm3 : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApMNQSpm4 : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBApMeq : rk(Oo :: B :: Ap :: M :: nil) = 4) by (apply LOoBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMmtmp : rk(Oo :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoBApMeq HOoBApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HOoBApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCApMNQSpM : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApMNQSpm : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBCApMNQSpeq HOoBCApMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApN requis par la preuve de (?)OoBCApN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApN requis par la preuve de (?)OoBCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApN requis par la preuve de (?)OoABCApN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApN requis par la preuve de (?)OoABCApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNm2 : rk(Oo :: A :: B :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNm3 : rk(Oo :: A :: B :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApN requis par la preuve de (?)OoBCApN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApN requis par la preuve de (?)OoBCApN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNm2 : rk(Oo :: B :: C :: Ap :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCApNm3 : rk(Oo :: B :: C :: Ap :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApNmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoABCApNeq HOoABCApNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: C :: Ap :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNmtmp;try rewrite HT2 in HOoABCApNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABCApNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApNM1. try clear HOoABCApNM2. try clear HOoABCApNM3. try clear HOoABCApNm4. try clear HOoABCApNm3. try clear HOoABCApNm2. try clear HOoABCApNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBCApNm4 : rk(Oo :: B :: C :: Ap :: N :: nil) >= 4).
{
	try assert(HOoBApMNQSpeq : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNQSpMtmp : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoBApMNQSpeq HOoBApMNQSpM4).
	try assert(HOoBCApMNQSpeq : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBCApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApMNQSpmtmp : rk(Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCApMNQSpeq HOoBCApMNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApMNQSpmtmp;try rewrite HT2 in HOoBCApMNQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoBCApMNQSpmtmp HOoBApNmtmp HOoBApMNQSpMtmp Hincl);apply HT.
}


assert(HOoBCApNM : rk(Oo :: B :: C :: Ap :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNm : rk(Oo :: B :: C :: Ap :: N ::  nil) >= 1) by (solve_hyps_min HOoBCApNeq HOoBCApNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpN *)
(* dans constructLemma(), requis par LBBpNQV *)
(* dans la couche 0 *)
Lemma LOoBBpCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpNQV requis par la preuve de (?)OoBBpCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpNQV requis par la preuve de (?)OoBBpCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpNQV requis par la preuve de (?)OoBBpCpNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNQVm2 : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap ::   de rang : 1 et 1 *)
assert(HOoBBpCpNQVm3 : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Ap :: Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) ((Ap :: nil) ++ (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Ap :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) (nil) 4 0 1 HOoBApBpCpNQVmtmp Hmtmp HApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBBpCpNQVm4 : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBApBpCpNQVmtmp HOoBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HOoBBpCpNQVM : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpNQVm : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBBpCpNQVeq HOoBBpCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: N :: Q :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpNQV requis par la preuve de (?)BBpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpNQV requis par la preuve de (?)BBpNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpNQV requis par la preuve de (?)BBpNQV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBBpNQVM3 : rk(B :: Bp :: N :: Q :: V :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: Q :: V :: nil) (Bp :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: N :: Q :: V :: nil) ((Bp :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (B :: N :: Q :: V :: nil) (nil) 1 2 0 HBpMtmp HBNQVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpNQVm2 : rk(B :: Bp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: N :: Q :: V :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpNQVm3 : rk(B :: Bp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoBBpCpNQVeq : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpNQVmtmp : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBBpCpNQVeq HOoBBpCpNQVm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Bp :: Cp :: B :: Bp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: N :: Q :: V :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNQVmtmp;try rewrite HT2 in HOoBBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: N :: Q :: V :: nil) (Bp :: nil) 4 1 2 HOoBBpCpNQVmtmp HBpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HBBpNQVM : rk(B :: Bp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpNQVm : rk(B :: Bp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBBpNQVeq HBBpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpN requis par la preuve de (?)BpN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpNm2 : rk(Bp :: N :: nil) >= 2).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBBpNQVeq : rk(B :: Bp :: N :: Q :: V :: nil) = 3) by (apply LBBpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpNQVmtmp : rk(B :: Bp :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HBBpNQVeq HBBpNQVm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: N :: Q :: V :: nil) (Bp :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: B :: N :: Q :: V :: nil) ((Bp :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpNQVmtmp;try rewrite HT2 in HBBpNQVmtmp.
	assert(HT := rule_2 (Bp :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 3 1 2 HBBpNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HBpNM : rk(Bp :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpNeq HBpNM2).
assert(HBpNm : rk(Bp :: N ::  nil) >= 1) by (solve_hyps_min HBpNeq HBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpN *)
(* dans la couche 0 *)
Lemma LOoBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: N :: P :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpNPT requis par la preuve de (?)OoBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpNPT requis par la preuve de (?)OoBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNPT requis par la preuve de (?)OoBCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A ::   de rang : 2 et 2 *)
assert(HOoBCBpNPTm3 : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMtmp : rk(Oo :: A :: nil) <= 2) by (solve_hyps_max HOoAeq HOoAM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: Oo :: B :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Oo :: B :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: nil) ++ (Oo :: B :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: nil) (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNPTmtmp HOomtmp HOoAMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpNPT requis par la preuve de (?)OoCBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: P :: T ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNPTm2 : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	assert(HOoBCBpNPTmtmp : rk(Oo :: B :: C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HOoBCBpNPTeq HOoBCBpNPTm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: B :: Oo :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Oo :: C :: Bp :: N :: P :: T :: nil) ((Oo :: B :: nil) ++ (Oo :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNPTmtmp;try rewrite HT2 in HOoBCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 3 1 2 HOoBCBpNPTmtmp HOomtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HOoCBpNPTm3 : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCBpNPTeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNPTeq HOoABCBpNPTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: Oo :: C :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: C :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: C :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPTmtmp;try rewrite HT2 in HOoABCBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: nil) 4 1 2 HOoABCBpNPTmtmp HOomtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpNPT requis par la preuve de (?)OoBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpNPT requis par la preuve de (?)OoBpNPT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBpNPTM3 : rk(Oo :: Bp :: N :: P :: T :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: N :: P :: T :: nil) (Oo :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: N :: P :: T :: nil) ((Oo :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Bp :: N :: P :: T :: nil) (nil) 1 2 0 HOoMtmp HBpNPTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: N :: P :: T ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoBpNPTm2 : rk(Oo :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoCBpNPTmtmp : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HOoCBpNPTeq HOoCBpNPTm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: N :: P :: T :: nil) (C :: Oo :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: Bp :: N :: P :: T :: nil) ((C :: nil) ++ (Oo :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpNPTmtmp;try rewrite HT2 in HOoCBpNPTmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: Bp :: N :: P :: T :: nil) (nil) 3 0 1 HOoCBpNPTmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoBpNPTm3 : rk(Oo :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACBpNPTeq : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoACBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNPTmtmp : rk(Oo :: A :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoACBpNPTeq HOoACBpNPTm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: Oo :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNPTmtmp;try rewrite HT2 in HOoACBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: Bp :: N :: P :: T :: nil) (Oo :: nil) 4 1 2 HOoACBpNPTmtmp HOomtmp HOoACMtmp Hincl); apply HT.
}


assert(HOoBpNPTM : rk(Oo :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpNPTm : rk(Oo :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBpNPTeq HOoBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpN requis par la preuve de (?)OoBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpN requis par la preuve de (?)OoBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpNm2 : rk(Oo :: Bp :: N :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: N :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpNm3 : rk(Oo :: Bp :: N :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoBpNPTeq : rk(Oo :: Bp :: N :: P :: T :: nil) = 3) by (apply LOoBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpNPTmtmp : rk(Oo :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HOoBpNPTeq HOoBpNPTm3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: N :: P :: T :: nil) (Oo :: Bp :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: N :: Bp :: N :: P :: T :: nil) ((Oo :: Bp :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpNPTmtmp;try rewrite HT2 in HOoBpNPTmtmp.
	assert(HT := rule_2 (Oo :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil) (Bp :: N :: nil) 3 2 2 HOoBpNPTmtmp HBpNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoBpNM : rk(Oo :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpNeq HOoBpNM3).
assert(HOoBpNm : rk(Oo :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBpNeq HOoBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpN requis par la preuve de (?)OoABpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpN requis par la preuve de (?)OoABpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpN requis par la preuve de (?)OoABpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNm2 : rk(Oo :: A :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNm3 : rk(Oo :: A :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpNm4 : rk(Oo :: A :: Bp :: N :: nil) >= 4).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoABpNPTeq : rk(Oo :: A :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNPTmtmp : rk(Oo :: A :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABpNPTeq HOoABpNPTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: T :: nil) (Oo :: A :: Bp :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: N :: Bp :: N :: P :: T :: nil) ((Oo :: A :: Bp :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPTmtmp;try rewrite HT2 in HOoABpNPTmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil) (Bp :: N :: nil) 4 2 2 HOoABpNPTmtmp HBpNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoABpNM : rk(Oo :: A :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNm : rk(Oo :: A :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABpNeq HOoABpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpN requis par la preuve de (?)OoBBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpN requis par la preuve de (?)OoBBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpN requis par la preuve de (?)OoBBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNm2 : rk(Oo :: B :: Bp :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNm3 : rk(Oo :: B :: Bp :: N :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: N :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBBpNm4 : rk(Oo :: B :: Bp :: N :: nil) >= 4).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoBBpNPTeq : rk(Oo :: B :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNPTmtmp : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBBpNPTeq HOoBBpNPTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: B :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: N :: P :: T :: nil) (Oo :: B :: Bp :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: N :: Bp :: N :: P :: T :: nil) ((Oo :: B :: Bp :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpNPTmtmp;try rewrite HT2 in HOoBBpNPTmtmp.
	assert(HT := rule_2 (Oo :: B :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil) (Bp :: N :: nil) 4 2 2 HOoBBpNPTmtmp HBpNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoBBpNM : rk(Oo :: B :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpNm : rk(Oo :: B :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBBpNeq HOoBBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABBpN *)
(* dans la couche 0 *)
Lemma LOoABBpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNQSp requis par la preuve de (?)OoABBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNQSp requis par la preuve de (?)OoABBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNQSp requis par la preuve de (?)OoABBpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNQSpm2 : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNQSpm3 : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNQSpm4 : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpMNQSpM : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpMNQSpm : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABBpMNQSpeq HOoABBpMNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABBpN *)
(* dans la couche 0 *)
Lemma LOoABpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMNQSp requis par la preuve de (?)OoABpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMNQSp requis par la preuve de (?)OoABpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMNQSp requis par la preuve de (?)OoABpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNQSpm2 : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNQSpm3 : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNQSpm4 : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpMNQSpM : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMNQSpm : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpMNQSpeq HOoABpMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm2 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm3 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABBpNm4 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4).
{
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpMtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMNQSpeq HOoABpMNQSpM4).
	try assert(HOoABBpMNQSpeq : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABBpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMNQSpmtmp : rk(Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABBpMNQSpeq HOoABBpMNQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: B :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMNQSpmtmp;try rewrite HT2 in HOoABBpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABBpMNQSpmtmp HOoABpNmtmp HOoABpMNQSpMtmp Hincl);apply HT.
}


assert(HOoABBpNM : rk(Oo :: A :: B :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNm : rk(Oo :: A :: B :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABBpNeq HOoABBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpN requis par la preuve de (?)CBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpN requis par la preuve de (?)CBpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNm2 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNm3 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpN requis par la preuve de (?)CBpN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNm2 : rk(C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNmtmp : rk(Oo :: A :: C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoACBpNeq HOoACBpNm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNmtmp;try rewrite HT2 in HOoACBpNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCBpNm3 : rk(C :: Bp :: N :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HCBpNPTeq : rk(C :: Bp :: N :: P :: T :: nil) = 3) by (apply LCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNPTmtmp : rk(C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HCBpNPTeq HCBpNPTm3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (C :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: P :: T :: nil) (C :: Bp :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: Bp :: N :: P :: T :: nil) ((C :: Bp :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpNPTmtmp;try rewrite HT2 in HCBpNPTmtmp.
	assert(HT := rule_2 (C :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil) (Bp :: N :: nil) 3 2 2 HCBpNPTmtmp HBpNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HCBpNM : rk(C :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCBpNeq HCBpNM3).
assert(HCBpNm : rk(C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HCBpNeq HCBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpN requis par la preuve de (?)OoCBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpN requis par la preuve de (?)OoCBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpN requis par la preuve de (?)OoCBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCBpNm2 : rk(Oo :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Bp :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCBpNm3 : rk(Oo :: C :: Bp :: N :: nil) >= 3).
{
	try assert(HOoCBpeq : rk(Oo :: C :: Bp :: nil) = 3) by (apply LOoCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCBpmtmp : rk(Oo :: C :: Bp :: nil) >= 3) by (solve_hyps_min HOoCBpeq HOoCBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Bp :: nil) (Oo :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Bp :: nil) (Oo :: C :: Bp :: N :: nil) 3 3 HOoCBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCBpNm4 : rk(Oo :: C :: Bp :: N :: nil) >= 4).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoCBpNPTeq : rk(Oo :: C :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCBpNPTmtmp : rk(Oo :: C :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoCBpNPTeq HOoCBpNPTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: C :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: N :: P :: T :: nil) (Oo :: C :: Bp :: N :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: N :: Bp :: N :: P :: T :: nil) ((Oo :: C :: Bp :: N :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpNPTmtmp;try rewrite HT2 in HOoCBpNPTmtmp.
	assert(HT := rule_2 (Oo :: C :: Bp :: N :: nil) (Bp :: N :: P :: T :: nil) (Bp :: N :: nil) 4 2 2 HOoCBpNPTmtmp HBpNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoCBpNM : rk(Oo :: C :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpNm : rk(Oo :: C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoCBpNeq HOoCBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACBpN *)
(* dans la couche 0 *)
Lemma LOoACBpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpMNQSp requis par la preuve de (?)OoACBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpMNQSp requis par la preuve de (?)OoACBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpMNQSp requis par la preuve de (?)OoACBpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMNQSpm2 : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMNQSpm3 : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpMNQSpm4 : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACBpMNQSpM : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpMNQSpm : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACBpMNQSpeq HOoACBpMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpN requis par la preuve de (?)OoACBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNm2 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNm3 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACBpNm4 : rk(Oo :: A :: C :: Bp :: N :: nil) >= 4).
{
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpMtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMNQSpeq HOoABpMNQSpM4).
	try assert(HOoACBpMNQSpeq : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoACBpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMNQSpmtmp : rk(Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACBpMNQSpeq HOoACBpMNQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: C :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) ((Oo :: A :: C :: Bp :: N :: nil) ++ (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpMNQSpmtmp;try rewrite HT2 in HOoACBpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoACBpMNQSpmtmp HOoABpNmtmp HOoABpMNQSpMtmp Hincl);apply HT.
}


assert(HOoACBpNM : rk(Oo :: A :: C :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACBpNm : rk(Oo :: A :: C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoACBpNeq HOoACBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCBpN *)
(* dans la couche 0 *)
Lemma LOoBCBpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpMNQSp requis par la preuve de (?)OoBCBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpMNQSp requis par la preuve de (?)OoBCBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpMNQSp requis par la preuve de (?)OoBCBpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpMNQSpm2 : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpMNQSpm3 : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpMNQSpm4 : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBBpMeq : rk(Oo :: B :: Bp :: M :: nil) = 4) by (apply LOoBBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpMmtmp : rk(Oo :: B :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoBBpMeq HOoBBpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: M :: nil) (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: M :: nil) (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoBBpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCBpMNQSpM : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpMNQSpm : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBCBpMNQSpeq HOoBCBpMNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCBpN *)
(* dans la couche 0 *)
Lemma LOoBBpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpMNQSp requis par la preuve de (?)OoBBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpMNQSp requis par la preuve de (?)OoBBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpMNQSp requis par la preuve de (?)OoBBpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpMNQSpm2 : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpMNQSpm3 : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpMNQSpm4 : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBBpMeq : rk(Oo :: B :: Bp :: M :: nil) = 4) by (apply LOoBBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpMmtmp : rk(Oo :: B :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoBBpMeq HOoBBpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: M :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: M :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoBBpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBBpMNQSpM : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpMNQSpm : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBBpMNQSpeq HOoBBpMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpN requis par la preuve de (?)OoBCBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpN requis par la preuve de (?)OoBCBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpN requis par la preuve de (?)OoBCBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNm2 : rk(Oo :: B :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Bp :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNm3 : rk(Oo :: B :: C :: Bp :: N :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: N :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBCBpNm4 : rk(Oo :: B :: C :: Bp :: N :: nil) >= 4).
{
	try assert(HOoBBpMNQSpeq : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBBpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpMNQSpMtmp : rk(Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoBBpMNQSpeq HOoBBpMNQSpM4).
	try assert(HOoBCBpMNQSpeq : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBCBpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpMNQSpmtmp : rk(Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBCBpMNQSpeq HOoBCBpMNQSpm4).
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (list_inter (Oo :: B :: C :: Bp :: N :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: B :: C :: Bp :: N :: Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: N :: Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) ((Oo :: B :: C :: Bp :: N :: nil) ++ (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpMNQSpmtmp;try rewrite HT2 in HOoBCBpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: Bp :: N :: nil) (Oo :: B :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Bp :: N :: nil) 4 4 4 HOoBCBpMNQSpmtmp HOoBBpNmtmp HOoBBpMNQSpMtmp Hincl);apply HT.
}


assert(HOoBCBpNM : rk(Oo :: B :: C :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpNm : rk(Oo :: B :: C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBCBpNeq HOoBCBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCBpN *)
(* dans la couche 0 *)
Lemma LOoABCBpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCBpMNQSp requis par la preuve de (?)OoABCBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpMNQSp requis par la preuve de (?)OoABCBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpMNQSp requis par la preuve de (?)OoABCBpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpMNQSpm2 : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpMNQSpm3 : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpMNQSpm4 : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpMNQSpM : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpMNQSpm : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABCBpMNQSpeq HOoABCBpMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCBpN requis par la preuve de (?)OoABCBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpN requis par la preuve de (?)OoABCBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpN requis par la preuve de (?)OoABCBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNm2 : rk(Oo :: A :: B :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNm3 : rk(Oo :: A :: B :: C :: Bp :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCBpNm4 : rk(Oo :: A :: B :: C :: Bp :: N :: nil) >= 4).
{
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpMtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMNQSpeq HOoABpMNQSpM4).
	try assert(HOoABCBpMNQSpeq : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABCBpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpMNQSpmtmp : rk(Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCBpMNQSpeq HOoABCBpMNQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: B :: C :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) ((Oo :: A :: B :: C :: Bp :: N :: nil) ++ (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpMNQSpmtmp;try rewrite HT2 in HOoABCBpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABCBpMNQSpmtmp HOoABpNmtmp HOoABpMNQSpMtmp Hincl);apply HT.
}


assert(HOoABCBpNM : rk(Oo :: A :: B :: C :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNm : rk(Oo :: A :: B :: C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABCBpNeq HOoABCBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpN *)
(* dans constructLemma(), requis par LBApBpNQV *)
(* dans la couche 0 *)
Lemma LBApBpCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApBpCpNQV requis par la preuve de (?)BApBpCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpCpNQV requis par la preuve de (?)BApBpCpNQV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HBApBpCpNQVm3 : rk(B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: nil) (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: B :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) ((Oo :: B :: nil) ++ (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (B :: nil) 4 1 2 HOoBApBpCpNQVmtmp HBmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBApBpCpNQVm4 : rk(B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Ap :: Bp :: nil) 4 2 2 HOoBApBpCpNQVmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HBApBpCpNQVM : rk(B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpCpNQVm : rk(B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBApBpCpNQVeq HBApBpCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApBpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: Bp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApBpNQV requis par la preuve de (?)BApBpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpNQV requis par la preuve de (?)BApBpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpNQV requis par la preuve de (?)OoBApBpNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpNQV requis par la preuve de (?)OoBApBpNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNQVm2 : rk(Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNQVm3 : rk(Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApBpNQV requis par la preuve de (?)BApBpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpNQV requis par la preuve de (?)BApBpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpNQV requis par la preuve de (?)OoABApBpNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpNQV requis par la preuve de (?)OoABApBpNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNQVm2 : rk(Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNQVm3 : rk(Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpNQV requis par la preuve de (?)BApBpNQV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: N :: Q :: V ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApBpNQVm2 : rk(B :: Ap :: Bp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpNQVmtmp : rk(Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HOoABApBpNQVeq HOoABApBpNQVm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: Bp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: N :: Q :: V :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: Bp :: N :: Q :: V :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: Bp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpNQVmtmp;try rewrite HT2 in HOoABApBpNQVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: Bp :: N :: Q :: V :: nil) (B :: Ap :: nil) 3 2 3 HOoABApBpNQVmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApBpNQVM1. try clear HOoABApBpNQVM2. try clear HOoABApBpNQVM3. try clear HOoABApBpNQVm4. try clear HOoABApBpNQVm3. try clear HOoABApBpNQVm2. try clear HOoABApBpNQVm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: N :: Q :: V ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBApBpNQVm3 : rk(B :: Ap :: Bp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoBApBpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HOoBApBpNQVeq HOoBApBpNQVm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Ap :: Bp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Ap :: Bp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpNQVmtmp;try rewrite HT2 in HOoBApBpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Ap :: Bp :: N :: Q :: V :: nil) (Ap :: Bp :: nil) 3 2 2 HOoBApBpNQVmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoBApBpNQVM1. try clear HOoBApBpNQVM2. try clear HOoBApBpNQVM3. try clear HOoBApBpNQVm4. try clear HOoBApBpNQVm3. try clear HOoBApBpNQVm2. try clear HOoBApBpNQVm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBApBpNQVm4 : rk(B :: Ap :: Bp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HApBpCpeq : rk(Ap :: Bp :: Cp :: nil) = 2) by (apply LApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpCpMtmp : rk(Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HApBpCpeq HApBpCpM2).
	try assert(HBApBpCpNQVeq : rk(B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApBpCpNQVmtmp : rk(B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HBApBpCpNQVeq HBApBpCpNQVm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: Cp :: nil) (B :: Ap :: Bp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Ap :: Bp :: Cp :: B :: Ap :: Bp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: B :: Ap :: Bp :: N :: Q :: V :: nil) ((Ap :: Bp :: Cp :: nil) ++ (B :: Ap :: Bp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpCpNQVmtmp;try rewrite HT2 in HBApBpCpNQVmtmp.
	assert(HT := rule_4 (Ap :: Bp :: Cp :: nil) (B :: Ap :: Bp :: N :: Q :: V :: nil) (Ap :: Bp :: nil) 4 2 2 HBApBpCpNQVmtmp HApBpmtmp HApBpCpMtmp Hincl); apply HT.
}


assert(HBApBpNQVM : rk(B :: Ap :: Bp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpNQVm : rk(B :: Ap :: Bp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBApBpNQVeq HBApBpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNm2 : rk(Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpNm3 : rk(Ap :: Bp :: N :: nil) >= 3).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBApBpNQVeq : rk(B :: Ap :: Bp :: N :: Q :: V :: nil) = 4) by (apply LBApBpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApBpNQVmtmp : rk(B :: Ap :: Bp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HBApBpNQVeq HBApBpNQVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Ap :: Bp :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: N :: Q :: V :: nil) (Ap :: Bp :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: N :: B :: N :: Q :: V :: nil) ((Ap :: Bp :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpNQVmtmp;try rewrite HT2 in HBApBpNQVmtmp.
	assert(HT := rule_2 (Ap :: Bp :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 4 1 2 HBApBpNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HApBpNM : rk(Ap :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpNeq HApBpNM3).
assert(HApBpNm : rk(Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HApBpNeq HApBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpN *)
(* dans la couche 0 *)
Lemma LOoAApBpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpMNQSp requis par la preuve de (?)OoAApBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpMNQSp requis par la preuve de (?)OoAApBpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpMNQSp requis par la preuve de (?)OoAApBpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNQSpm2 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNQSpm3 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpMNQSpm4 : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpMNQSpM : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpMNQSpm : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApBpMNQSpeq HOoAApBpMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Ap :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNm2 : rk(Oo :: Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpNM3 : rk(Oo :: Ap :: Bp :: N :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: nil) (Oo :: Ap :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (N :: nil) (nil) 2 1 0 HOoApBpMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpNm3 : rk(Oo :: Ap :: Bp :: N :: nil) >= 3).
{
	try assert(HOoAApMNQSpeq : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoAApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMNQSpMtmp : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMNQSpeq HOoAApMNQSpM4).
	try assert(HOoAApBpMNQSpeq : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoAApBpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMNQSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMNQSpeq HOoAApBpMNQSpm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: Ap :: Bp :: N :: Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMNQSpmtmp;try rewrite HT2 in HOoAApBpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: N :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoAApBpMNQSpmtmp HOoApNmtmp HOoAApMNQSpMtmp Hincl);apply HT.
}


assert(HOoApBpNM : rk(Oo :: Ap :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpNm : rk(Oo :: Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoApBpNeq HOoApBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpN *)
(* dans la couche 0 *)
Lemma LBCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: N :: Q :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpNQV requis par la preuve de (?)BCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpNQV requis par la preuve de (?)BCpNQV pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpNQV requis par la preuve de (?)BCpNQV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBCpNQVm2 : rk(B :: Cp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: B :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Cp :: N :: Q :: V :: nil) (nil) 4 0 2 HOoBApBpCpNQVmtmp Hmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCpNQVM3 : rk(B :: Cp :: N :: Q :: V :: nil) <= 3).
{
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: N :: Q :: V :: nil) (Cp :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: B :: N :: Q :: V :: nil) ((Cp :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (B :: N :: Q :: V :: nil) (nil) 1 2 0 HCpMtmp HBNQVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HBCpNQVm3 : rk(B :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNQVeq : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNQVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNQVeq HOoBApCpNQVm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (B :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Cp :: B :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: B :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (B :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNQVmtmp;try rewrite HT2 in HOoBApCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (B :: Cp :: N :: Q :: V :: nil) (Cp :: nil) 4 1 2 HOoBApCpNQVmtmp HCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HBCpNQVM : rk(B :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpNQVm : rk(B :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBCpNQVeq HBCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpN requis par la preuve de (?)CpN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpNm2 : rk(Cp :: N :: nil) >= 2).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBCpNQVeq : rk(B :: Cp :: N :: Q :: V :: nil) = 3) by (apply LBCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNQVmtmp : rk(B :: Cp :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HBCpNQVeq HBCpNQVm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Cp :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: N :: Q :: V :: nil) (Cp :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: N :: B :: N :: Q :: V :: nil) ((Cp :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpNQVmtmp;try rewrite HT2 in HBCpNQVmtmp.
	assert(HT := rule_2 (Cp :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 3 1 2 HBCpNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HCpNM : rk(Cp :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpNeq HCpNM2).
assert(HCpNm : rk(Cp :: N ::  nil) >= 1) by (solve_hyps_min HCpNeq HCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpN *)
(* dans la couche 0 *)
Lemma LOoBCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpNQV requis par la preuve de (?)OoBCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpNQV requis par la preuve de (?)OoBCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpNQV requis par la preuve de (?)OoBCpNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpNQVm2 : rk(Oo :: B :: Cp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Cp :: N :: Q :: V :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBCpNQVm3 : rk(Oo :: B :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: B :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: Oo :: B :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: B :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: B :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: B :: Cp :: N :: Q :: V :: nil) (Oo :: nil) 4 1 2 HOoBApBpCpNQVmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoBCpNQVm4 : rk(Oo :: B :: Cp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBApCpNQVeq : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApCpNQVmtmp : rk(Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApCpNQVeq HOoBApCpNQVm4).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: B :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Cp :: Oo :: B :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: B :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: B :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpNQVmtmp;try rewrite HT2 in HOoBApCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: B :: Cp :: N :: Q :: V :: nil) (Oo :: Cp :: nil) 4 2 2 HOoBApCpNQVmtmp HOoCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoBCpNQVM : rk(Oo :: B :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpNQVm : rk(Oo :: B :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoBCpNQVeq HOoBCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpN requis par la preuve de (?)OoCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpN requis par la preuve de (?)OoCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpNm2 : rk(Oo :: Cp :: N :: nil) >= 2).
{
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: N :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpNm3 : rk(Oo :: Cp :: N :: nil) >= 3).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HOoBCpNQVeq : rk(Oo :: B :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCpNQVmtmp : rk(Oo :: B :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBCpNQVeq HOoBCpNQVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Oo :: Cp :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: N :: Q :: V :: nil) (Oo :: Cp :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: N :: B :: N :: Q :: V :: nil) ((Oo :: Cp :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpNQVmtmp;try rewrite HT2 in HOoBCpNQVmtmp.
	assert(HT := rule_2 (Oo :: Cp :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 4 1 2 HOoBCpNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HOoCpNM : rk(Oo :: Cp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpNeq HOoCpNM3).
assert(HOoCpNm : rk(Oo :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HOoCpNeq HOoCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpN *)
(* dans la couche 0 *)
Lemma LOoABpCpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: Cp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpNPT requis par la preuve de (?)OoABpCpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpNPT requis par la preuve de (?)OoABpCpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpNPT requis par la preuve de (?)OoABpCpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpNPTm2 : rk(Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpNPTm3 : rk(Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpNPTm4 : rk(Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpCpNPTM : rk(Oo :: A :: Bp :: Cp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpNPTm : rk(Oo :: A :: Bp :: Cp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoABpCpNPTeq HOoABpCpNPTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpN *)
(* dans la couche 0 *)
Lemma LOoBpCpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: Cp :: N :: P :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCpNPT requis par la preuve de (?)OoBpCpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpCpNPT requis par la preuve de (?)OoBpCpNPT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpCpNPT requis par la preuve de (?)OoBpCpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpNPTm2 : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBpCpNPTM3 : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) <= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: N :: P :: T :: nil) (Oo :: Bp :: Cp :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: Bp :: N :: P :: T :: nil) ((Oo :: Bp :: Cp :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Bp :: Cp :: nil) (Bp :: N :: P :: T :: nil) (Bp :: nil) 2 2 1 HOoBpCpMtmp HBpNPTMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpNPTm3 : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoBpNeq : rk(Oo :: Bp :: N :: nil) = 3) by (apply LOoBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpNmtmp : rk(Oo :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoBpNeq HOoBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: N :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: N :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil) 3 3 HOoBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBpCpNPTM : rk(Oo :: Bp :: Cp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpCpNPTm : rk(Oo :: Bp :: Cp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBpCpNPTeq HOoBpCpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpN requis par la preuve de (?)OoACpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpN requis par la preuve de (?)OoACpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpN requis par la preuve de (?)OoACpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpNm2 : rk(Oo :: A :: Cp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpNm3 : rk(Oo :: A :: Cp :: N :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: N :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpNm4 : rk(Oo :: A :: Cp :: N :: nil) >= 4).
{
	try assert(HOoBpCpNPTeq : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) = 3) by (apply LOoBpCpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpNPTMtmp : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) <= 3) by (solve_hyps_max HOoBpCpNPTeq HOoBpCpNPTM3).
	try assert(HOoABpCpNPTeq : rk(Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) = 4) by (apply LOoABpCpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpNPTmtmp : rk(Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABpCpNPTeq HOoABpCpNPTm4).
	try assert(HOoCpNeq : rk(Oo :: Cp :: N :: nil) = 3) by (apply LOoCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCpNmtmp : rk(Oo :: Cp :: N :: nil) >= 3) by (solve_hyps_min HOoCpNeq HOoCpNm3).
	assert(Hincl : incl (Oo :: Cp :: N :: nil) (list_inter (Oo :: A :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: N :: P :: T :: nil) (Oo :: A :: Cp :: N :: Oo :: Bp :: Cp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: N :: Oo :: Bp :: Cp :: N :: P :: T :: nil) ((Oo :: A :: Cp :: N :: nil) ++ (Oo :: Bp :: Cp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpNPTmtmp;try rewrite HT2 in HOoABpCpNPTmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil) (Oo :: Cp :: N :: nil) 4 3 3 HOoABpCpNPTmtmp HOoCpNmtmp HOoBpCpNPTMtmp Hincl);apply HT.
}


assert(HOoACpNM : rk(Oo :: A :: Cp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpNm : rk(Oo :: A :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HOoACpNeq HOoACpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCpN *)
(* dans la couche 0 *)
Lemma LOoBBpCpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: Cp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpNPT requis par la preuve de (?)OoBBpCpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpNPT requis par la preuve de (?)OoBBpCpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpNPT requis par la preuve de (?)OoBBpCpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNPTm2 : rk(Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNPTm3 : rk(Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpNPTm4 : rk(Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBBpCpNPTM : rk(Oo :: B :: Bp :: Cp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpNPTm : rk(Oo :: B :: Bp :: Cp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBBpCpNPTeq HOoBBpCpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpN requis par la preuve de (?)BCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpN requis par la preuve de (?)BCpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm2 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm3 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCpN requis par la preuve de (?)BCpN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: N ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpNm2 : rk(B :: Cp :: N :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpNmtmp : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HOoABCpNeq HOoABCpNm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: N :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpNmtmp;try rewrite HT2 in HOoABCpNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: N :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpNmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCpNm3 : rk(B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoBpCpNPTeq : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) = 3) by (apply LOoBpCpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpNPTMtmp : rk(Oo :: Bp :: Cp :: N :: P :: T :: nil) <= 3) by (solve_hyps_max HOoBpCpNPTeq HOoBpCpNPTM3).
	try assert(HOoBBpCpNPTeq : rk(Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) = 4) by (apply LOoBBpCpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpNPTmtmp : rk(Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBBpCpNPTeq HOoBBpCpNPTm4).
	try assert(HCpNeq : rk(Cp :: N :: nil) = 2) by (apply LCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpNmtmp : rk(Cp :: N :: nil) >= 2) by (solve_hyps_min HCpNeq HCpNm2).
	assert(Hincl : incl (Cp :: N :: nil) (list_inter (B :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: P :: T :: nil) (B :: Cp :: N :: Oo :: Bp :: Cp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: N :: Oo :: Bp :: Cp :: N :: P :: T :: nil) ((B :: Cp :: N :: nil) ++ (Oo :: Bp :: Cp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNPTmtmp;try rewrite HT2 in HOoBBpCpNPTmtmp.
	assert(HT := rule_2 (B :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: P :: T :: nil) (Cp :: N :: nil) 4 2 3 HOoBBpCpNPTmtmp HCpNmtmp HOoBpCpNPTMtmp Hincl);apply HT.
}
try clear HCpNM1. try clear HCpNM2. try clear HCpNM3. try clear HCpNm4. try clear HCpNm3. try clear HCpNm2. try clear HCpNm1. 

assert(HBCpNM : rk(B :: Cp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCpNeq HBCpNM3).
assert(HBCpNm : rk(B :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HBCpNeq HBCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCpN *)
(* dans la couche 0 *)
Lemma LOoABCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpNQV requis par la preuve de (?)OoABCpNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpNQV requis par la preuve de (?)OoABCpNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpNQV requis par la preuve de (?)OoABCpNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNQVm2 : rk(Oo :: A :: B :: Cp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: Q :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNQVm3 : rk(Oo :: A :: B :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: Q :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNQVm4 : rk(Oo :: A :: B :: Cp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoACpNeq : rk(Oo :: A :: Cp :: N :: nil) = 4) by (apply LOoACpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpNmtmp : rk(Oo :: A :: Cp :: N :: nil) >= 4) by (solve_hyps_min HOoACpNeq HOoACpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: N :: Q :: V :: nil) 4 4 HOoACpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCpNQVM : rk(Oo :: A :: B :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpNQVm : rk(Oo :: A :: B :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HOoABCpNQVeq HOoABCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCpN requis par la preuve de (?)ABCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpN requis par la preuve de (?)ABCpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpN requis par la preuve de (?)OoABCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm2 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpNm3 : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: N :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpN requis par la preuve de (?)ABCpN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpN requis par la preuve de (?)ABCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpNm2 : rk(A :: B :: Cp :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: N ::  de rang :  3 et 4 	 AiB : A :: B :: Cp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HABCpNm3 : rk(A :: B :: Cp :: N :: nil) >= 3).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpNmtmp : rk(Oo :: A :: B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HOoABCpNeq HOoABCpNm3).
	try assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: B :: Cp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: N :: nil) (Oo :: A :: B :: Cp :: A :: B :: Cp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: B :: Cp :: N :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: B :: Cp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpNmtmp;try rewrite HT2 in HOoABCpNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: B :: Cp :: N :: nil) (A :: B :: Cp :: nil) 3 3 3 HOoABCpNmtmp HABCpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCpNm4 : rk(A :: B :: Cp :: N :: nil) >= 4).
{
	try assert(HOoABNQVeq : rk(Oo :: A :: B :: N :: Q :: V :: nil) = 3) by (apply LOoABNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNQVMtmp : rk(Oo :: A :: B :: N :: Q :: V :: nil) <= 3) by (solve_hyps_max HOoABNQVeq HOoABNQVM3).
	try assert(HOoABCpNQVeq : rk(Oo :: A :: B :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoABCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpNQVmtmp : rk(Oo :: A :: B :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoABCpNQVeq HOoABCpNQVm4).
	try assert(HABNeq : rk(A :: B :: N :: nil) = 3) by (apply LABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABNmtmp : rk(A :: B :: N :: nil) >= 3) by (solve_hyps_min HABNeq HABNm3).
	assert(Hincl : incl (A :: B :: N :: nil) (list_inter (A :: B :: Cp :: N :: nil) (Oo :: A :: B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: N :: Q :: V :: nil) (A :: B :: Cp :: N :: Oo :: A :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: N :: Oo :: A :: B :: N :: Q :: V :: nil) ((A :: B :: Cp :: N :: nil) ++ (Oo :: A :: B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpNQVmtmp;try rewrite HT2 in HOoABCpNQVmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: N :: nil) (Oo :: A :: B :: N :: Q :: V :: nil) (A :: B :: N :: nil) 4 3 3 HOoABCpNQVmtmp HABNmtmp HOoABNQVMtmp Hincl);apply HT.
}


assert(HABCpNM : rk(A :: B :: Cp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpNm : rk(A :: B :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HABCpNeq HABCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpCpN *)
(* dans la couche 0 *)
Lemma LBBpCpNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: Cp :: N :: Q :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpNQV requis par la preuve de (?)BBpCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpNQV requis par la preuve de (?)BBpCpNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpNQV requis par la preuve de (?)BBpCpNQV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 2 et 2 *)
assert(HBBpCpNQVm2 : rk(B :: Bp :: Cp :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (B :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: B :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: B :: Bp :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: nil) ++ (B :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (B :: Bp :: Cp :: N :: Q :: V :: nil) (nil) 4 0 2 HOoBApBpCpNQVmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBBpCpNQVm3 : rk(B :: Bp :: Cp :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoBApBpCpNQVeq : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBApBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApBpCpNQVmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBApBpCpNQVeq HOoBApBpCpNQVm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (B :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Ap :: Bp :: B :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: B :: Bp :: Cp :: N :: Q :: V :: nil) ((Oo :: Ap :: Bp :: nil) ++ (B :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpNQVmtmp;try rewrite HT2 in HOoBApBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (B :: Bp :: Cp :: N :: Q :: V :: nil) (Bp :: nil) 4 1 2 HOoBApBpCpNQVmtmp HBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: N :: Q :: V ::  de rang :  4 et 4 	 AiB : Bp :: Cp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpCpNQVm4 : rk(B :: Bp :: Cp :: N :: Q :: V :: nil) >= 4).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HOoBBpCpNQVeq : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LOoBBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpNQVmtmp : rk(Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HOoBBpCpNQVeq HOoBBpCpNQVm4).
	try assert(HBpCpeq : rk(Bp :: Cp :: nil) = 2) by (apply LBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpmtmp : rk(Bp :: Cp :: nil) >= 2) by (solve_hyps_min HBpCpeq HBpCpm2).
	assert(Hincl : incl (Bp :: Cp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: N :: Q :: V :: nil) (Oo :: Bp :: Cp :: B :: Bp :: Cp :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: Cp :: N :: Q :: V :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: Cp :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpNQVmtmp;try rewrite HT2 in HOoBBpCpNQVmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: N :: Q :: V :: nil) (Bp :: Cp :: nil) 4 2 2 HOoBBpCpNQVmtmp HBpCpmtmp HOoBpCpMtmp Hincl); apply HT.
}


assert(HBBpCpNQVM : rk(B :: Bp :: Cp :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpNQVm : rk(B :: Bp :: Cp :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBBpCpNQVeq HBBpCpNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpCpN requis par la preuve de (?)BpCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpCpN requis par la preuve de (?)BpCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpCpNm2 : rk(Bp :: Cp :: N :: nil) >= 2).
{
	try assert(HBpCpeq : rk(Bp :: Cp :: nil) = 2) by (apply LBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpmtmp : rk(Bp :: Cp :: nil) >= 2) by (solve_hyps_min HBpCpeq HBpCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Cp :: nil) (Bp :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Cp :: nil) (Bp :: Cp :: N :: nil) 2 2 HBpCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpCpNm3 : rk(Bp :: Cp :: N :: nil) >= 3).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBBpCpNQVeq : rk(B :: Bp :: Cp :: N :: Q :: V :: nil) = 4) by (apply LBBpCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpCpNQVmtmp : rk(B :: Bp :: Cp :: N :: Q :: V :: nil) >= 4) by (solve_hyps_min HBBpCpNQVeq HBBpCpNQVm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: Cp :: N :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: N :: Q :: V :: nil) (Bp :: Cp :: N :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: N :: B :: N :: Q :: V :: nil) ((Bp :: Cp :: N :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpNQVmtmp;try rewrite HT2 in HBBpCpNQVmtmp.
	assert(HT := rule_2 (Bp :: Cp :: N :: nil) (B :: N :: Q :: V :: nil) (N :: nil) 4 1 2 HBBpCpNQVmtmp HNmtmp HBNQVMtmp Hincl);apply HT.
}


assert(HBpCpNM : rk(Bp :: Cp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpCpNeq HBpCpNM3).
assert(HBpCpNm : rk(Bp :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HBpCpNeq HBpCpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpCpN *)
(* dans la couche 0 *)
Lemma LOoABpCpMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpCpMNQSp requis par la preuve de (?)OoABpCpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpCpMNQSp requis par la preuve de (?)OoABpCpMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpCpMNQSp requis par la preuve de (?)OoABpCpMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMNQSpm2 : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMNQSpm3 : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpCpMNQSpm4 : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpCpMNQSpM : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpCpMNQSpm : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpCpMNQSpeq HOoABpCpMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpCpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: Bp :: Cp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCpN requis par la preuve de (?)OoBpCpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpCpN requis par la preuve de (?)OoBpCpN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpCpN requis par la preuve de (?)OoBpCpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpNm2 : rk(Oo :: Bp :: Cp :: N :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: N :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBpCpNM3 : rk(Oo :: Bp :: Cp :: N :: nil) <= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Bp :: Cp :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: N :: nil) (Oo :: Bp :: Cp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: N :: nil) ((Oo :: Bp :: Cp :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Bp :: Cp :: nil) (N :: nil) (nil) 2 1 0 HOoBpCpMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpCpNm3 : rk(Oo :: Bp :: Cp :: N :: nil) >= 3).
{
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpMtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMNQSpeq HOoABpMNQSpM4).
	try assert(HOoABpCpMNQSpeq : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpCpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpCpMNQSpmtmp : rk(Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABpCpMNQSpeq HOoABpCpMNQSpm4).
	try assert(HOoBpNeq : rk(Oo :: Bp :: N :: nil) = 3) by (apply LOoBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpNmtmp : rk(Oo :: Bp :: N :: nil) >= 3) by (solve_hyps_min HOoBpNeq HOoBpNm3).
	assert(Hincl : incl (Oo :: Bp :: N :: nil) (list_inter (Oo :: Bp :: Cp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: Cp :: M :: N :: Q :: Sp :: nil) (Oo :: Bp :: Cp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: N :: Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) ((Oo :: Bp :: Cp :: N :: nil) ++ (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpCpMNQSpmtmp;try rewrite HT2 in HOoABpCpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: Bp :: Cp :: N :: nil) (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: Bp :: N :: nil) 4 3 4 HOoABpCpMNQSpmtmp HOoBpNmtmp HOoABpMNQSpMtmp Hincl);apply HT.
}


assert(HOoBpCpNM : rk(Oo :: Bp :: Cp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpCpNm : rk(Oo :: Bp :: Cp :: N ::  nil) >= 1) by (solve_hyps_min HOoBpCpNeq HOoBpCpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApMN requis par la preuve de (?)OoBApMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMN requis par la preuve de (?)OoBApMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMN requis par la preuve de (?)OoABApMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMN requis par la preuve de (?)OoABApMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNm2 : rk(Oo :: A :: B :: Ap :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNm3 : rk(Oo :: A :: B :: Ap :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApMN requis par la preuve de (?)OoBApMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApMN requis par la preuve de (?)OoBApMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApMNm2 : rk(Oo :: B :: Ap :: M :: N :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: M :: N :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApMNm3 : rk(Oo :: B :: Ap :: M :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMNmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: nil) >= 3) by (solve_hyps_min HOoABApMNeq HOoABApMNm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: M :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNmtmp;try rewrite HT2 in HOoABApMNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: M :: N :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApMNmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApMNm4 : rk(Oo :: B :: Ap :: M :: N :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoBApMNQSpeq : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNQSpmtmp : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApMNQSpeq HOoBApMNQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: B :: Ap :: M :: N :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: M :: N :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: M :: N :: Ap :: M :: Q :: Sp :: nil) ((Oo :: B :: Ap :: M :: N :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMNQSpmtmp;try rewrite HT2 in HOoBApMNQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: M :: N :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoBApMNQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoBApMNM : rk(Oo :: B :: Ap :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApMNm : rk(Oo :: B :: Ap :: M :: N ::  nil) >= 1) by (solve_hyps_min HOoBApMNeq HOoBApMNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApMN *)
(* dans la couche 0 *)
Lemma LABApMNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: M :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApMNQSp requis par la preuve de (?)ABApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApMNQSp requis par la preuve de (?)ABApMNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApMNQSp requis par la preuve de (?)ABApMNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNQSpm2 : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNQSpm3 : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNQSpm4 : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HABApMeq : rk(A :: B :: Ap :: M :: nil) = 4) by (apply LABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMmtmp : rk(A :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HABApMeq HABApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: M :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: M :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: nil) 4 4 HABApMmtmp Hcomp Hincl);apply HT.
}


assert(HABApMNQSpM : rk(A :: B :: Ap :: M :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMNQSpm : rk(A :: B :: Ap :: M :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HABApMNQSpeq HABApMNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApMN requis par la preuve de (?)ABApMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMN requis par la preuve de (?)ABApMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMN requis par la preuve de (?)OoABApMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMN requis par la preuve de (?)OoABApMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNm2 : rk(Oo :: A :: B :: Ap :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNm3 : rk(Oo :: A :: B :: Ap :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApMN requis par la preuve de (?)ABApMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApMN requis par la preuve de (?)ABApMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNm2 : rk(A :: B :: Ap :: M :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApMNm3 : rk(A :: B :: Ap :: M :: N :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMNmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: nil) >= 3) by (solve_hyps_min HOoABApMNeq HOoABApMNm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: M :: N :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNmtmp;try rewrite HT2 in HOoABApMNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: M :: N :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApMNmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApMNm4 : rk(A :: B :: Ap :: M :: N :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HABApMNQSpeq : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LABApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMNQSpmtmp : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApMNQSpeq HABApMNQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (A :: B :: Ap :: M :: N :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: N :: Q :: Sp :: nil) (A :: B :: Ap :: M :: N :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: M :: N :: Ap :: M :: Q :: Sp :: nil) ((A :: B :: Ap :: M :: N :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMNQSpmtmp;try rewrite HT2 in HABApMNQSpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: M :: N :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HABApMNQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HABApMNM : rk(A :: B :: Ap :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMNm : rk(A :: B :: Ap :: M :: N ::  nil) >= 1) by (solve_hyps_min HABApMNeq HABApMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApMN requis par la preuve de (?)OoCApMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMN requis par la preuve de (?)OoCApMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMN requis par la preuve de (?)OoACApMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMN requis par la preuve de (?)OoACApMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNm2 : rk(Oo :: A :: C :: Ap :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNm3 : rk(Oo :: A :: C :: Ap :: M :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApMN requis par la preuve de (?)OoCApMN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApMN requis par la preuve de (?)OoCApMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApMNm2 : rk(Oo :: C :: Ap :: M :: N :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: M :: N :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: N ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApMNm3 : rk(Oo :: C :: Ap :: M :: N :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMNmtmp : rk(Oo :: A :: C :: Ap :: M :: N :: nil) >= 3) by (solve_hyps_min HOoACApMNeq HOoACApMNm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: N :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: M :: N :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: M :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMNmtmp;try rewrite HT2 in HOoACApMNmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: M :: N :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApMNmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMNM1. try clear HOoACApMNM2. try clear HOoACApMNM3. try clear HOoACApMNm4. try clear HOoACApMNm3. try clear HOoACApMNm2. try clear HOoACApMNm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCApMNm4 : rk(Oo :: C :: Ap :: M :: N :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoCApMNQSpeq : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoCApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMNQSpmtmp : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApMNQSpeq HOoCApMNQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: C :: Ap :: M :: N :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: M :: N :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: M :: N :: Ap :: M :: Q :: Sp :: nil) ((Oo :: C :: Ap :: M :: N :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMNQSpmtmp;try rewrite HT2 in HOoCApMNQSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: M :: N :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: M :: nil) 4 2 2 HOoCApMNQSpmtmp HApMmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoCApMNM : rk(Oo :: C :: Ap :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApMNm : rk(Oo :: C :: Ap :: M :: N ::  nil) >= 1) by (solve_hyps_min HOoCApMNeq HOoCApMNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpMN *)
(* dans la couche 0 *)
Lemma LOoABpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMQSp requis par la preuve de (?)OoABpMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMQSp requis par la preuve de (?)OoABpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMQSp requis par la preuve de (?)OoABpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMQSpm2 : rk(Oo :: A :: Bp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMQSpm3 : rk(Oo :: A :: Bp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HOoABpMQSpm4 : rk(Oo :: A :: Bp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	try assert(HOoAApBpMQSpeq : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApBpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApBpMQSpmtmp : rk(Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApBpMQSpeq HOoAApBpMQSpm4).
	try assert(HOoBpMeq : rk(Oo :: Bp :: M :: nil) = 3) by (apply LOoBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpMmtmp : rk(Oo :: Bp :: M :: nil) >= 3) by (solve_hyps_min HOoBpMeq HOoBpMm3).
	assert(Hincl : incl (Oo :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Bp :: M :: Oo :: A :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: Oo :: A :: Bp :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (Oo :: A :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpMQSpmtmp;try rewrite HT2 in HOoAApBpMQSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil) (Oo :: Bp :: M :: nil) 4 3 3 HOoAApBpMQSpmtmp HOoBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}


assert(HOoABpMQSpM : rk(Oo :: A :: Bp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMQSpm : rk(Oo :: A :: Bp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpMQSpeq HOoABpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpMN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: M :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpMN requis par la preuve de (?)OoABpMN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpMN requis par la preuve de (?)OoABpMN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpMN requis par la preuve de (?)OoABpMN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNm2 : rk(Oo :: A :: Bp :: M :: N :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: M :: N :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpMNm3 : rk(Oo :: A :: Bp :: M :: N :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: M :: N :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpMNm4 : rk(Oo :: A :: Bp :: M :: N :: nil) >= 4).
{
	try assert(HOoABpMQSpeq : rk(Oo :: A :: Bp :: M :: Q :: Sp :: nil) = 4) by (apply LOoABpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMQSpMtmp : rk(Oo :: A :: Bp :: M :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpMQSpeq HOoABpMQSpM4).
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpmtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABpMNQSpeq HOoABpMNQSpm4).
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (list_inter (Oo :: A :: Bp :: M :: N :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: M :: N :: Oo :: A :: Bp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: M :: N :: Oo :: A :: Bp :: M :: Q :: Sp :: nil) ((Oo :: A :: Bp :: M :: N :: nil) ++ (Oo :: A :: Bp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpMNQSpmtmp;try rewrite HT2 in HOoABpMNQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: M :: N :: nil) (Oo :: A :: Bp :: M :: Q :: Sp :: nil) (Oo :: A :: Bp :: M :: nil) 4 4 4 HOoABpMNQSpmtmp HOoABpMmtmp HOoABpMQSpMtmp Hincl);apply HT.
}


assert(HOoABpMNM : rk(Oo :: A :: Bp :: M :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpMNm : rk(Oo :: A :: Bp :: M :: N ::  nil) >= 1) by (solve_hyps_min HOoABpMNeq HOoABpMNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(P ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HPM : rk(P ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HPeq HPM1).
assert(HPm : rk(P ::  nil) >= 1) by (solve_hyps_min HPeq HPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNP requis par la preuve de (?)BpNP pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)BpNP pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABCBpNPQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABCBpNPQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABCBpNPQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNPQSpm2 : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNPQSpm3 : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNPQSpm4 : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNmtmp : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABBpNeq HOoABBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) 4 4 HOoABBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNPQSpm2 : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNPQSpm3 : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Bp :: N ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: Bp :: N ::   de rang : 4 et 4 *)
assert(HOoABpNPQSpm4 : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABCBpNeq : rk(Oo :: A :: B :: C :: Bp :: N :: nil) = 4) by (apply LOoABCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNMtmp : rk(Oo :: A :: B :: C :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABCBpNeq HOoABCBpNM4).
	assert(HOoABCBpNPQSpmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCBpNPQSpeq HOoABCBpNPQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) (Oo :: A :: B :: C :: Bp :: N :: Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) ((Oo :: A :: B :: C :: Bp :: N :: nil) ++ (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPQSpmtmp;try rewrite HT2 in HOoABCBpNPQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABCBpNPQSpmtmp HOoABpNmtmp HOoABCBpNMtmp Hincl); apply HT.
}
try clear HOoABCBpNPQSpM1. try clear HOoABCBpNPQSpM2. try clear HOoABCBpNPQSpM3. try clear HOoABCBpNPQSpm4. try clear HOoABCBpNPQSpm3. try clear HOoABCBpNPQSpm2. try clear HOoABCBpNPQSpm1. 

(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)BpNP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)OoABpNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)OoABpNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)OoABpNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNQSpm2 : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNQSpm3 : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Bp :: N ::  de rang :  4 et 4 	 A : Oo :: A :: Bp :: M :: N ::   de rang : 4 et 4 *)
assert(HOoABpNQSpm4 : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMNeq : rk(Oo :: A :: Bp :: M :: N :: nil) = 4) by (apply LOoABpMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNMtmp : rk(Oo :: A :: Bp :: M :: N :: nil) <= 4) by (solve_hyps_max HOoABpMNeq HOoABpMNM4).
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpmtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABpMNQSpeq HOoABpMNQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: Bp :: M :: N :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: M :: N :: Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: M :: N :: Oo :: A :: Bp :: N :: Q :: Sp :: nil) ((Oo :: A :: Bp :: M :: N :: nil) ++ (Oo :: A :: Bp :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpMNQSpmtmp;try rewrite HT2 in HOoABpMNQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Bp :: M :: N :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABpMNQSpmtmp HOoABpNmtmp HOoABpMNMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpNP requis par la preuve de (?)BpNP pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HBpNPm2 : rk(Bp :: N :: P :: nil) >= 2).
{
	assert(HOoABpNQSpMtmp : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) <= 4) by (solve_hyps_max HOoABpNQSpeq HOoABpNQSpM4).
	assert(HOoABpNPQSpmtmp : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABpNPQSpeq HOoABpNPQSpm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Bp :: N :: P :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) (Bp :: N :: P :: Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: P :: Oo :: A :: Bp :: N :: Q :: Sp :: nil) ((Bp :: N :: P :: nil) ++ (Oo :: A :: Bp :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPQSpmtmp;try rewrite HT2 in HOoABpNPQSpmtmp.
	assert(HT := rule_2 (Bp :: N :: P :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) (Bp :: N :: nil) 4 2 4 HOoABpNPQSpmtmp HBpNmtmp HOoABpNQSpMtmp Hincl);apply HT.
}
try clear HOoABpNQSpM1. try clear HOoABpNQSpM2. try clear HOoABpNQSpM3. try clear HOoABpNQSpm4. try clear HOoABpNQSpm3. try clear HOoABpNQSpm2. try clear HOoABpNQSpm1. try clear HOoABpNPQSpM1. try clear HOoABpNPQSpM2. try clear HOoABpNPQSpM3. try clear HOoABpNPQSpm4. try clear HOoABpNPQSpm3. try clear HOoABpNPQSpm2. try clear HOoABpNPQSpm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpNPM2 : rk(Bp :: N :: P :: nil) <= 2).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: N :: P :: nil) (Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Bp :: N :: P :: nil) (Bp :: N :: P :: T :: nil) 2 2 HBpNPTMtmp Hcomp Hincl);apply HT.
}


assert(HBpNPM : rk(Bp :: N :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpNPeq HBpNPM3).
assert(HBpNPm : rk(Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HBpNPeq HBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Q ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HQM : rk(Q ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HQeq HQM1).
assert(HQm : rk(Q ::  nil) >= 1) by (solve_hyps_min HQeq HQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAQ requis par la preuve de (?)OoAQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAQ requis par la preuve de (?)OoAQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAQm2 : rk(Oo :: A :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAQm3 : rk(Oo :: A :: Q :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Oo :: A :: Q :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Q :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Q :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: Q :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Q :: nil) (Ap :: M :: Q :: Sp :: nil) (Q :: nil) 4 1 2 HOoAApMQSpmtmp HQmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoAQM : rk(Oo :: A :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAQeq HOoAQM3).
assert(HOoAQm : rk(Oo :: A :: Q ::  nil) >= 1) by (solve_hyps_min HOoAQeq HOoAQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABQ requis par la preuve de (?)OoABQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABQ requis par la preuve de (?)OoABQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABQ requis par la preuve de (?)OoABQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABQm2 : rk(Oo :: A :: B :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABQM3 : rk(Oo :: A :: B :: Q :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Q :: nil) (Oo :: A :: B :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Q :: nil) ((Oo :: A :: B :: nil) ++ (Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Q :: nil) (nil) 2 1 0 HOoABMtmp HQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABQm3 : rk(Oo :: A :: B :: Q :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoABApMQSpeq : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMQSpeq HOoABApMQSpm4).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Oo :: A :: B :: Q :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: B :: Q :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Q :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: B :: Q :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQSpmtmp;try rewrite HT2 in HOoABApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Q :: nil) (Ap :: M :: Q :: Sp :: nil) (Q :: nil) 4 1 2 HOoABApMQSpmtmp HQmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoABQM : rk(Oo :: A :: B :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABQm : rk(Oo :: A :: B :: Q ::  nil) >= 1) by (solve_hyps_min HOoABQeq HOoABQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMQ requis par la preuve de (?)ApMQ pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)ApMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm2 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm3 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApMQ requis par la preuve de (?)ApMQ pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HApMQm2 : rk(Ap :: M :: Q :: nil) >= 2).
{
	assert(HOoAApMSpMtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMSpeq HOoAApMSpM4).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Ap :: M :: Q :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Ap :: M :: Q :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: Oo :: A :: Ap :: M :: Sp :: nil) ((Ap :: M :: Q :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_2 (Ap :: M :: Q :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 4 HOoAApMQSpmtmp HApMmtmp HOoAApMSpMtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApMQM2 : rk(Ap :: M :: Q :: nil) <= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: M :: Q :: nil) (Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: M :: Q :: nil) (Ap :: M :: Q :: Sp :: nil) 2 2 HApMQSpMtmp Hcomp Hincl);apply HT.
}


assert(HApMQM : rk(Ap :: M :: Q ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMQeq HApMQM3).
assert(HApMQm : rk(Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HApMQeq HApMQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApMQ *)
(* dans la couche 0 *)
Lemma LOoAApMQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm2 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm3 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQm2 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQm3 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoAApMQm4 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 4).
{
	assert(HOoAApMSpMtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMSpeq HOoAApMSpM4).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Ap :: M :: Q :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Q :: Oo :: A :: Ap :: M :: Sp :: nil) ((Oo :: A :: Ap :: M :: Q :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: Ap :: M :: nil) 4 4 4 HOoAApMQSpmtmp HOoAApMmtmp HOoAApMSpMtmp Hincl);apply HT.
}


assert(HOoAApMQM : rk(Oo :: A :: Ap :: M :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMQm : rk(Oo :: A :: Ap :: M :: Q ::  nil) >= 1) by (solve_hyps_min HOoAApMQeq HOoAApMQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApNQ *)
(* dans la couche 0 *)
Lemma LOoBApNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApNQSp requis par la preuve de (?)OoBApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApNQSp requis par la preuve de (?)OoBApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApNQSp requis par la preuve de (?)OoBApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNQSpm2 : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNQSpm3 : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: Sp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: Ap :: M :: N ::   de rang : 4 et 4 *)
assert(HOoBApNQSpm4 : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBApMNeq : rk(Oo :: B :: Ap :: M :: N :: nil) = 4) by (apply LOoBApMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNMtmp : rk(Oo :: B :: Ap :: M :: N :: nil) <= 4) by (solve_hyps_max HOoBApMNeq HOoBApMNM4).
	try assert(HOoBApMNQSpeq : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoBApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNQSpmtmp : rk(Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApMNQSpeq HOoBApMNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: Ap :: M :: N :: nil) (Oo :: B :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: M :: N :: Oo :: B :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: M :: N :: Oo :: B :: Ap :: N :: Q :: Sp :: nil) ((Oo :: B :: Ap :: M :: N :: nil) ++ (Oo :: B :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApMNQSpmtmp;try rewrite HT2 in HOoBApMNQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: M :: N :: nil) (Oo :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoBApMNQSpmtmp HOoBApNmtmp HOoBApMNMtmp Hincl); apply HT.
}


assert(HOoBApNQSpM : rk(Oo :: B :: Ap :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApNQSpm : rk(Oo :: B :: Ap :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApNQSpeq HOoBApNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApNQ *)
(* dans la couche 0 *)
Lemma LOoBApNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Ap :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApNSp requis par la preuve de (?)OoBApNQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoBApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm2 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm3 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApNSp requis par la preuve de (?)OoBApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApNSp requis par la preuve de (?)OoBApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNSpm2 : rk(Oo :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Sp :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApNSpm3 : rk(Oo :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: Sp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNSpmtmp;try rewrite HT2 in HOoABApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Sp :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApNSpmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApNQ requis par la preuve de (?)OoBApNQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoBApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoABApNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoABApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQm2 : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQm3 : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApNQ requis par la preuve de (?)OoBApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApNQ requis par la preuve de (?)OoBApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNQm2 : rk(Oo :: B :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Q ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApNQm3 : rk(Oo :: B :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNQmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoABApNQeq HOoABApNQm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: Q :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQmtmp;try rewrite HT2 in HOoABApNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApNQmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoBApNQm4 : rk(Oo :: B :: Ap :: N :: Q :: nil) >= 4).
{
	assert(HOoBApNSpMtmp : rk(Oo :: B :: Ap :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoBApNSpeq HOoBApNSpM4).
	try assert(HOoBApNQSpeq : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoBApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNQSpmtmp : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApNQSpeq HOoBApNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: Ap :: N :: Q :: nil) (Oo :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: Q :: Oo :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: N :: Q :: Oo :: B :: Ap :: N :: Sp :: nil) ((Oo :: B :: Ap :: N :: Q :: nil) ++ (Oo :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApNQSpmtmp;try rewrite HT2 in HOoBApNQSpmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: N :: Q :: nil) (Oo :: B :: Ap :: N :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoBApNQSpmtmp HOoBApNmtmp HOoBApNSpMtmp Hincl);apply HT.
}
try clear HOoBApNSpM1. try clear HOoBApNSpM2. try clear HOoBApNSpM3. try clear HOoBApNSpm4. try clear HOoBApNSpm3. try clear HOoBApNSpm2. try clear HOoBApNSpm1. 

assert(HOoBApNQM : rk(Oo :: B :: Ap :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApNQm : rk(Oo :: B :: Ap :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoBApNQeq HOoBApNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApNQ *)
(* dans la couche 0 *)
Lemma LABApNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApNQSp requis par la preuve de (?)ABApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApNQSp requis par la preuve de (?)ABApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApNQSp requis par la preuve de (?)ABApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNQSpm2 : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: N :: Q :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNQSpm3 : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Q :: Sp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap :: N ::  de rang :  4 et 4 	 A : A :: B :: Ap :: M :: N ::   de rang : 4 et 4 *)
assert(HABApNQSpm4 : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HABApMNeq : rk(A :: B :: Ap :: M :: N :: nil) = 4) by (apply LABApMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMNMtmp : rk(A :: B :: Ap :: M :: N :: nil) <= 4) by (solve_hyps_max HABApMNeq HABApMNM4).
	try assert(HABApMNQSpeq : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LABApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMNQSpmtmp : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApMNQSpeq HABApMNQSpm4).
	try assert(HABApNeq : rk(A :: B :: Ap :: N :: nil) = 4) by (apply LABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNmtmp : rk(A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HABApNeq HABApNm4).
	assert(Hincl : incl (A :: B :: Ap :: N :: nil) (list_inter (A :: B :: Ap :: M :: N :: nil) (A :: B :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: N :: Q :: Sp :: nil) (A :: B :: Ap :: M :: N :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: M :: N :: A :: B :: Ap :: N :: Q :: Sp :: nil) ((A :: B :: Ap :: M :: N :: nil) ++ (A :: B :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMNQSpmtmp;try rewrite HT2 in HABApMNQSpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: M :: N :: nil) (A :: B :: Ap :: N :: Q :: Sp :: nil) (A :: B :: Ap :: N :: nil) 4 4 4 HABApMNQSpmtmp HABApNmtmp HABApMNMtmp Hincl); apply HT.
}


assert(HABApNQSpM : rk(A :: B :: Ap :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApNQSpm : rk(A :: B :: Ap :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HABApNQSpeq HABApNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApNQ *)
(* dans la couche 0 *)
Lemma LABApNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm2 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm3 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNSpm2 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: N :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApNSpm3 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Sp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNSpmtmp;try rewrite HT2 in HOoABApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Sp :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApNSpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApNQ requis par la preuve de (?)ABApNQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)ABApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoABApNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoABApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQm2 : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQm3 : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApNQ requis par la preuve de (?)ABApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApNQ requis par la preuve de (?)ABApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNQm2 : rk(A :: B :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: N :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Q ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApNQm3 : rk(A :: B :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNQmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoABApNQeq HOoABApNQm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Q :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQmtmp;try rewrite HT2 in HOoABApNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApNQmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABApNQm4 : rk(A :: B :: Ap :: N :: Q :: nil) >= 4).
{
	assert(HABApNSpMtmp : rk(A :: B :: Ap :: N :: Sp :: nil) <= 4) by (solve_hyps_max HABApNSpeq HABApNSpM4).
	try assert(HABApNQSpeq : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LABApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNQSpmtmp : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApNQSpeq HABApNQSpm4).
	try assert(HABApNeq : rk(A :: B :: Ap :: N :: nil) = 4) by (apply LABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNmtmp : rk(A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HABApNeq HABApNm4).
	assert(Hincl : incl (A :: B :: Ap :: N :: nil) (list_inter (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: N :: Q :: Sp :: nil) (A :: B :: Ap :: N :: Q :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: N :: Q :: A :: B :: Ap :: N :: Sp :: nil) ((A :: B :: Ap :: N :: Q :: nil) ++ (A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApNQSpmtmp;try rewrite HT2 in HABApNQSpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: N :: Sp :: nil) (A :: B :: Ap :: N :: nil) 4 4 4 HABApNQSpmtmp HABApNmtmp HABApNSpMtmp Hincl);apply HT.
}


assert(HABApNQM : rk(A :: B :: Ap :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApNQm : rk(A :: B :: Ap :: N :: Q ::  nil) >= 1) by (solve_hyps_min HABApNQeq HABApNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApNQ *)
(* dans la couche 0 *)
Lemma LOoCApNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApNQSp requis par la preuve de (?)OoCApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApNQSp requis par la preuve de (?)OoCApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApNQSp requis par la preuve de (?)OoCApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNQSpm2 : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Q :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNQSpm3 : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Q :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: C :: Ap :: M :: N ::   de rang : 4 et 4 *)
assert(HOoCApNQSpm4 : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoCApMNeq : rk(Oo :: C :: Ap :: M :: N :: nil) = 4) by (apply LOoCApMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMNMtmp : rk(Oo :: C :: Ap :: M :: N :: nil) <= 4) by (solve_hyps_max HOoCApMNeq HOoCApMNM4).
	try assert(HOoCApMNQSpeq : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoCApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMNQSpmtmp : rk(Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApMNQSpeq HOoCApMNQSpm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: C :: Ap :: M :: N :: nil) (Oo :: C :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: M :: N :: Oo :: C :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: M :: N :: Oo :: C :: Ap :: N :: Q :: Sp :: nil) ((Oo :: C :: Ap :: M :: N :: nil) ++ (Oo :: C :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApMNQSpmtmp;try rewrite HT2 in HOoCApMNQSpmtmp.
	assert(HT := rule_4 (Oo :: C :: Ap :: M :: N :: nil) (Oo :: C :: Ap :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoCApMNQSpmtmp HOoCApNmtmp HOoCApMNMtmp Hincl); apply HT.
}


assert(HOoCApNQSpM : rk(Oo :: C :: Ap :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApNQSpm : rk(Oo :: C :: Ap :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApNQSpeq HOoCApNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApNQ *)
(* dans la couche 0 *)
Lemma LOoCApNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApNSp requis par la preuve de (?)OoCApNQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApNSp requis par la preuve de (?)OoCApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApNSp requis par la preuve de (?)OoACApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApNSp requis par la preuve de (?)OoACApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNSpm2 : rk(Oo :: A :: C :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNSpm3 : rk(Oo :: A :: C :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApNSp requis par la preuve de (?)OoCApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApNSp requis par la preuve de (?)OoCApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNSpm2 : rk(Oo :: C :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApNSpm3 : rk(Oo :: C :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApNSpmtmp : rk(Oo :: A :: C :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoACApNSpeq HOoACApNSpm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: N :: Sp :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Sp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApNSpmtmp;try rewrite HT2 in HOoACApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Sp :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApNSpmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApNSpM1. try clear HOoACApNSpM2. try clear HOoACApNSpM3. try clear HOoACApNSpm4. try clear HOoACApNSpm3. try clear HOoACApNSpm2. try clear HOoACApNSpm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApNQ requis par la preuve de (?)OoCApNQ pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApNQ requis par la preuve de (?)OoCApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApNQ requis par la preuve de (?)OoACApNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApNQ requis par la preuve de (?)OoACApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNQm2 : rk(Oo :: A :: C :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNQm3 : rk(Oo :: A :: C :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApNQ requis par la preuve de (?)OoCApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApNQ requis par la preuve de (?)OoCApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNQm2 : rk(Oo :: C :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Q :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: N :: Q ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApNQm3 : rk(Oo :: C :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApNQmtmp : rk(Oo :: A :: C :: Ap :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoACApNQeq HOoACApNQm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: N :: Q :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Q :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApNQmtmp;try rewrite HT2 in HOoACApNQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Q :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApNQmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApNQM1. try clear HOoACApNQM2. try clear HOoACApNQM3. try clear HOoACApNQm4. try clear HOoACApNQm3. try clear HOoACApNQm2. try clear HOoACApNQm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoCApNQm4 : rk(Oo :: C :: Ap :: N :: Q :: nil) >= 4).
{
	assert(HOoCApNSpMtmp : rk(Oo :: C :: Ap :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoCApNSpeq HOoCApNSpM4).
	try assert(HOoCApNQSpeq : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoCApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNQSpmtmp : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApNQSpeq HOoCApNQSpm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: C :: Ap :: N :: Q :: nil) (Oo :: C :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: N :: Q :: Oo :: C :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: N :: Q :: Oo :: C :: Ap :: N :: Sp :: nil) ((Oo :: C :: Ap :: N :: Q :: nil) ++ (Oo :: C :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApNQSpmtmp;try rewrite HT2 in HOoCApNQSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Ap :: N :: Q :: nil) (Oo :: C :: Ap :: N :: Sp :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoCApNQSpmtmp HOoCApNmtmp HOoCApNSpMtmp Hincl);apply HT.
}


assert(HOoCApNQM : rk(Oo :: C :: Ap :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApNQm : rk(Oo :: C :: Ap :: N :: Q ::  nil) >= 1) by (solve_hyps_min HOoCApNQeq HOoCApNQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Sp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HSpM : rk(Sp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HSpeq HSpM1).
assert(HSpm : rk(Sp ::  nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoASp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoASp requis par la preuve de (?)OoASp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoASp requis par la preuve de (?)OoASp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoASpm2 : rk(Oo :: A :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoASpm3 : rk(Oo :: A :: Sp :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Oo :: A :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Sp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Sp :: Ap :: M :: Q :: Sp :: nil) ((Oo :: A :: Sp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_2 (Oo :: A :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil) (Sp :: nil) 4 1 2 HOoAApMQSpmtmp HSpmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HOoASpM : rk(Oo :: A :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoASpeq HOoASpM3).
assert(HOoASpm : rk(Oo :: A :: Sp ::  nil) >= 1) by (solve_hyps_min HOoASpeq HOoASpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABSp *)
(* dans la couche 0 *)
Lemma LOoABApMSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSp requis par la preuve de (?)OoABApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSp requis par la preuve de (?)OoABApMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSp requis par la preuve de (?)OoABApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap :: M ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: M :: Q ::   de rang : 4 et 4 *)
assert(HOoABApMSpm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQMtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) <= 4) by (solve_hyps_max HOoAApMQeq HOoAApMQM4).
	try assert(HOoABApMQSpeq : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoABApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMQSpeq HOoABApMQSpm4).
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Ap :: M :: Q :: Oo :: A :: B :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Q :: Oo :: A :: B :: Ap :: M :: Sp :: nil) ((Oo :: A :: Ap :: M :: Q :: nil) ++ (Oo :: A :: B :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMQSpmtmp;try rewrite HT2 in HOoABApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: nil) (Oo :: A :: Ap :: M :: nil) 4 4 4 HOoABApMQSpmtmp HOoAApMmtmp HOoAApMQMtmp Hincl); apply HT.
}


assert(HOoABApMSpM : rk(Oo :: A :: B :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMSpm : rk(Oo :: A :: B :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApMSpeq HOoABApMSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABSp *)
(* dans la couche 0 *)
Lemma LOoAApMSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMSp requis par la preuve de (?)OoAApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm2 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMSpm3 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap :: M ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: M :: Q ::   de rang : 4 et 4 *)
assert(HOoAApMSpm4 : rk(Oo :: A :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQMtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) <= 4) by (solve_hyps_max HOoAApMQeq HOoAApMQM4).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Ap :: M :: Q :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Q :: Oo :: A :: Ap :: M :: Sp :: nil) ((Oo :: A :: Ap :: M :: Q :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: Ap :: M :: nil) 4 4 4 HOoAApMQSpmtmp HOoAApMmtmp HOoAApMQMtmp Hincl); apply HT.
}


assert(HOoAApMSpM : rk(Oo :: A :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMSpm : rk(Oo :: A :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApMSpeq HOoAApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABSp requis par la preuve de (?)OoABSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABSp requis par la preuve de (?)OoABSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABSp requis par la preuve de (?)OoABSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABSpm2 : rk(Oo :: A :: B :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABSpM3 : rk(Oo :: A :: B :: Sp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpMtmp : rk(Sp :: nil) <= 1) by (solve_hyps_max HSpeq HSpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Sp :: nil) (Oo :: A :: B :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Sp :: nil) ((Oo :: A :: B :: nil) ++ (Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Sp :: nil) (nil) 2 1 0 HOoABMtmp HSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABSpm3 : rk(Oo :: A :: B :: Sp :: nil) >= 3).
{
	try assert(HOoAApMSpeq : rk(Oo :: A :: Ap :: M :: Sp :: nil) = 4) by (apply LOoAApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMSpMtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMSpeq HOoAApMSpM4).
	try assert(HOoABApMSpeq : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) = 4) by (apply LOoABApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMSpmtmp : rk(Oo :: A :: B :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMSpeq HOoABApMSpm4).
	try assert(HOoASpeq : rk(Oo :: A :: Sp :: nil) = 3) by (apply LOoASp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoASpmtmp : rk(Oo :: A :: Sp :: nil) >= 3) by (solve_hyps_min HOoASpeq HOoASpm3).
	assert(Hincl : incl (Oo :: A :: Sp :: nil) (list_inter (Oo :: A :: B :: Sp :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Sp :: nil) (Oo :: A :: B :: Sp :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Sp :: Oo :: A :: Ap :: M :: Sp :: nil) ((Oo :: A :: B :: Sp :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMSpmtmp;try rewrite HT2 in HOoABApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Sp :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: Sp :: nil) 4 3 4 HOoABApMSpmtmp HOoASpmtmp HOoAApMSpMtmp Hincl);apply HT.
}


assert(HOoABSpM : rk(Oo :: A :: B :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABSpm : rk(Oo :: A :: B :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABSpeq HOoABSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CSp requis par la preuve de (?)CSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCSpm2 : rk(C :: Sp :: nil) >= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HCApMQSpeq : rk(C :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMQSpmtmp : rk(C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HCApMQSpeq HCApMQSpm3).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (C :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: Sp :: nil) (C :: Sp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: Ap :: M :: Q :: Sp :: nil) ((C :: Sp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMQSpmtmp;try rewrite HT2 in HCApMQSpmtmp.
	assert(HT := rule_2 (C :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil) (Sp :: nil) 3 1 2 HCApMQSpmtmp HSpmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HCSpM : rk(C :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCSpeq HCSpM2).
assert(HCSpm : rk(C :: Sp ::  nil) >= 1) by (solve_hyps_min HCSpeq HCSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACSp *)
(* dans la couche 0 *)
Lemma LOoACApMSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMSp requis par la preuve de (?)OoACApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMSp requis par la preuve de (?)OoACApMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMSp requis par la preuve de (?)OoACApMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpm2 : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpm3 : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap :: M ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: M :: Q ::   de rang : 4 et 4 *)
assert(HOoACApMSpm4 : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4).
{
	try assert(HOoAApMQeq : rk(Oo :: A :: Ap :: M :: Q :: nil) = 4) by (apply LOoAApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQMtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) <= 4) by (solve_hyps_max HOoAApMQeq HOoAApMQM4).
	try assert(HOoACApMQSpeq : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoACApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMQSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMQSpeq HOoACApMQSpm4).
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Ap :: M :: Q :: Oo :: A :: C :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Q :: Oo :: A :: C :: Ap :: M :: Sp :: nil) ((Oo :: A :: Ap :: M :: Q :: nil) ++ (Oo :: A :: C :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMQSpmtmp;try rewrite HT2 in HOoACApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: M :: Q :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: Ap :: M :: nil) 4 4 4 HOoACApMQSpmtmp HOoAApMmtmp HOoAApMQMtmp Hincl); apply HT.
}


assert(HOoACApMSpM : rk(Oo :: A :: C :: Ap :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMSpm : rk(Oo :: A :: C :: Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACSp requis par la preuve de (?)OoACSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACSp requis par la preuve de (?)OoACSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACSp requis par la preuve de (?)OoACSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACSpm2 : rk(Oo :: A :: C :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACSpM3 : rk(Oo :: A :: C :: Sp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpMtmp : rk(Sp :: nil) <= 1) by (solve_hyps_max HSpeq HSpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Sp :: nil) (Oo :: A :: C :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Sp :: nil) ((Oo :: A :: C :: nil) ++ (Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Sp :: nil) (nil) 2 1 0 HOoACMtmp HSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACSpm3 : rk(Oo :: A :: C :: Sp :: nil) >= 3).
{
	try assert(HOoAApMSpeq : rk(Oo :: A :: Ap :: M :: Sp :: nil) = 4) by (apply LOoAApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMSpMtmp : rk(Oo :: A :: Ap :: M :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApMSpeq HOoAApMSpM4).
	try assert(HOoACApMSpeq : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) = 4) by (apply LOoACApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMSpmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: nil) >= 4) by (solve_hyps_min HOoACApMSpeq HOoACApMSpm4).
	try assert(HOoASpeq : rk(Oo :: A :: Sp :: nil) = 3) by (apply LOoASp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoASpmtmp : rk(Oo :: A :: Sp :: nil) >= 3) by (solve_hyps_min HOoASpeq HOoASpm3).
	assert(Hincl : incl (Oo :: A :: Sp :: nil) (list_inter (Oo :: A :: C :: Sp :: nil) (Oo :: A :: Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: nil) (Oo :: A :: C :: Sp :: Oo :: A :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Sp :: Oo :: A :: Ap :: M :: Sp :: nil) ((Oo :: A :: C :: Sp :: nil) ++ (Oo :: A :: Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpmtmp;try rewrite HT2 in HOoACApMSpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Sp :: nil) (Oo :: A :: Ap :: M :: Sp :: nil) (Oo :: A :: Sp :: nil) 4 3 4 HOoACApMSpmtmp HOoASpmtmp HOoAApMSpMtmp Hincl);apply HT.
}


assert(HOoACSpM : rk(Oo :: A :: C :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACSpm : rk(Oo :: A :: C :: Sp ::  nil) >= 1) by (solve_hyps_min HOoACSpeq HOoACSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApSp *)
(* dans constructLemma(), requis par LCApSpT *)
(* dans constructLemma(), requis par LOoCApCpSpT *)
(* dans la couche 0 *)
Lemma LOoCApBpCpSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HOoCApBpCpSpTM : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpSpTm : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpSpTeq HOoCApBpCpSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApCpSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Cp :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpSpT requis par la preuve de (?)OoCApCpSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpSpT requis par la preuve de (?)OoCApCpSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpSpT requis par la preuve de (?)OoCApCpSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpSpTm2 : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpSpTm3 : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoCApCpSpTm4 : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 4).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoCApBpCpSpTeq : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T :: nil) = 4) by (apply LOoCApBpCpSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpCpSpTmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApBpCpSpTeq HOoCApBpCpSpTm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: Sp :: T :: nil) (Oo :: Ap :: Bp :: Oo :: C :: Ap :: Cp :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: C :: Ap :: Cp :: Sp :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Cp :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpSpTmtmp;try rewrite HT2 in HOoCApBpCpSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) (Oo :: Ap :: nil) 4 2 2 HOoCApBpCpSpTmtmp HOoApmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoCApBpCpSpTM1. try clear HOoCApBpCpSpTM2. try clear HOoCApBpCpSpTM3. try clear HOoCApBpCpSpTm4. try clear HOoCApBpCpSpTm3. try clear HOoCApBpCpSpTm2. try clear HOoCApBpCpSpTm1. 

assert(HOoCApCpSpTM : rk(Oo :: C :: Ap :: Cp :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpSpTm : rk(Oo :: C :: Ap :: Cp :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoCApCpSpTeq HOoCApCpSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApSpT requis par la preuve de (?)CApSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApSpT requis par la preuve de (?)CApSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CSpT requis par la preuve de (?)CApSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApSpT requis par la preuve de (?)CApSpT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HCApSpTM3 : rk(C :: Ap :: Sp :: T :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Sp :: T :: nil) (Ap :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: C :: Sp :: T :: nil) ((Ap :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (C :: Sp :: T :: nil) (nil) 1 2 0 HApMtmp HCSpTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApSpTm2 : rk(C :: Ap :: Sp :: T :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: nil) (C :: Ap :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: nil) (C :: Ap :: Sp :: T :: nil) 2 2 HCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HCApSpTm3 : rk(C :: Ap :: Sp :: T :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoCApCpSpTeq : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) = 4) by (apply LOoCApCpSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApCpSpTmtmp : rk(Oo :: C :: Ap :: Cp :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApCpSpTeq HOoCApCpSpTm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (C :: Ap :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: Sp :: T :: nil) (Oo :: Ap :: Cp :: C :: Ap :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: C :: Ap :: Sp :: T :: nil) ((Oo :: Ap :: Cp :: nil) ++ (C :: Ap :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpSpTmtmp;try rewrite HT2 in HOoCApCpSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (C :: Ap :: Sp :: T :: nil) (Ap :: nil) 4 1 2 HOoCApCpSpTmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HCApSpTM : rk(C :: Ap :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApSpTm : rk(C :: Ap :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCApSpTeq HCApSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApSp *)
(* dans la couche 0 *)
Lemma LCSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Sp :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HCSpTM : rk(C :: Sp :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCSpTeq HCSpTM3).
assert(HCSpTm : rk(C :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCSpTeq HCSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApSp requis par la preuve de (?)ApSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApSpm2 : rk(Ap :: Sp :: nil) >= 2).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HCApSpTeq : rk(C :: Ap :: Sp :: T :: nil) = 3) by (apply LCApSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApSpTmtmp : rk(C :: Ap :: Sp :: T :: nil) >= 3) by (solve_hyps_min HCApSpTeq HCApSpTm3).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Ap :: Sp :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Sp :: T :: nil) (Ap :: Sp :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Sp :: C :: Sp :: T :: nil) ((Ap :: Sp :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApSpTmtmp;try rewrite HT2 in HCApSpTmtmp.
	assert(HT := rule_2 (Ap :: Sp :: nil) (C :: Sp :: T :: nil) (Sp :: nil) 3 1 2 HCApSpTmtmp HSpmtmp HCSpTMtmp Hincl);apply HT.
}


assert(HApSpM : rk(Ap :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApSpeq HApSpM2).
assert(HApSpm : rk(Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HApSpeq HApSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApSp requis par la preuve de (?)OoACApSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApSp requis par la preuve de (?)OoACApSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpm2 : rk(Oo :: A :: C :: Ap :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpm3 : rk(Oo :: A :: C :: Ap :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Sp ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApSpm2 : rk(C :: Ap :: Sp :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApSpmtmp : rk(Oo :: A :: C :: Ap :: Sp :: nil) >= 3) by (solve_hyps_min HOoACApSpeq HOoACApSpm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Sp :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApSpmtmp;try rewrite HT2 in HOoACApSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: nil) (C :: Ap :: nil) 3 2 3 HOoACApSpmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApSpM1. try clear HOoACApSpM2. try clear HOoACApSpM3. try clear HOoACApSpm4. try clear HOoACApSpm3. try clear HOoACApSpm2. try clear HOoACApSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApSpm3 : rk(C :: Ap :: Sp :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HCApMQSpeq : rk(C :: Ap :: M :: Q :: Sp :: nil) = 3) by (apply LCApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMQSpmtmp : rk(C :: Ap :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HCApMQSpeq HCApMQSpm3).
	try assert(HApSpeq : rk(Ap :: Sp :: nil) = 2) by (apply LApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApSpmtmp : rk(Ap :: Sp :: nil) >= 2) by (solve_hyps_min HApSpeq HApSpm2).
	assert(Hincl : incl (Ap :: Sp :: nil) (list_inter (C :: Ap :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Q :: Sp :: nil) (C :: Ap :: Sp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Sp :: Ap :: M :: Q :: Sp :: nil) ((C :: Ap :: Sp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMQSpmtmp;try rewrite HT2 in HCApMQSpmtmp.
	assert(HT := rule_2 (C :: Ap :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil) (Ap :: Sp :: nil) 3 2 2 HCApMQSpmtmp HApSpmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HCApSpM : rk(C :: Ap :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApSpeq HCApSpM3).
assert(HCApSpm : rk(C :: Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HCApSpeq HCApSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCCpSp *)
(* dans constructLemma(), requis par LCApCpMQSp *)
(* dans la couche 0 *)
Lemma LOoCApCpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpMQSp requis par la preuve de (?)OoCApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpMQSp requis par la preuve de (?)OoCApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpMQSp requis par la preuve de (?)OoCApCpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMQSpm2 : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMQSpm3 : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMQSpm4 : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoCApMeq : rk(Oo :: C :: Ap :: M :: nil) = 4) by (apply LOoCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApMmtmp : rk(Oo :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoCApMeq HOoCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: M :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 4 4 HOoCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApCpMQSpM : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpMQSpm : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApCpMQSpeq HOoCApCpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApCpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Cp :: M :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApCpMQSp requis par la preuve de (?)CApCpMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpMQSp requis par la preuve de (?)CApCpMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpMQSp requis par la preuve de (?)OoCApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpMQSp requis par la preuve de (?)OoCApCpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMQSpm2 : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpMQSpm3 : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApCpMQSp requis par la preuve de (?)CApCpMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApCpMQSp requis par la preuve de (?)CApCpMQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCpMQSp requis par la preuve de (?)OoACApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCpMQSp requis par la preuve de (?)OoACApCpMQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpMQSpm2 : rk(Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpMQSpm3 : rk(Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApCpMQSp requis par la preuve de (?)CApCpMQSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApCpMQSpm2 : rk(C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApCpMQSpmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoACApCpMQSpeq HOoACApCpMQSpm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMQSpmtmp;try rewrite HT2 in HOoACApCpMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Cp :: M :: Q :: Sp :: nil) (C :: Ap :: nil) 3 2 3 HOoACApCpMQSpmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApCpMQSpM1. try clear HOoACApCpMQSpM2. try clear HOoACApCpMQSpM3. try clear HOoACApCpMQSpm4. try clear HOoACApCpMQSpm3. try clear HOoACApCpMQSpm2. try clear HOoACApCpMQSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: M :: Q :: Sp ::  de rang :  3 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HCApCpMQSpm3 : rk(C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	assert(HOoCApCpMQSpmtmp : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HOoCApCpMQSpeq HOoCApCpMQSpm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (C :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Cp :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Cp :: nil) ++ (C :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpMQSpmtmp;try rewrite HT2 in HOoCApCpMQSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (C :: Ap :: Cp :: M :: Q :: Sp :: nil) (Ap :: Cp :: nil) 3 2 2 HOoCApCpMQSpmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Ap :: Cp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Cp :: M ::   de rang : 3 et 3 *)
assert(HCApCpMQSpm4 : rk(C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoApCpMeq : rk(Oo :: Ap :: Cp :: M :: nil) = 3) by (apply LOoApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMMtmp : rk(Oo :: Ap :: Cp :: M :: nil) <= 3) by (solve_hyps_max HOoApCpMeq HOoApCpMM3).
	try assert(HOoCApCpMQSpeq : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) = 4) by (apply LOoCApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApCpMQSpmtmp : rk(Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApCpMQSpeq HOoCApCpMQSpm4).
	try assert(HApCpMeq : rk(Ap :: Cp :: M :: nil) = 3) by (apply LApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpMmtmp : rk(Ap :: Cp :: M :: nil) >= 3) by (solve_hyps_min HApCpMeq HApCpMm3).
	assert(Hincl : incl (Ap :: Cp :: M :: nil) (list_inter (Oo :: Ap :: Cp :: M :: nil) (C :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) (Oo :: Ap :: Cp :: M :: C :: Ap :: Cp :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: C :: Ap :: Cp :: M :: Q :: Sp :: nil) ((Oo :: Ap :: Cp :: M :: nil) ++ (C :: Ap :: Cp :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpMQSpmtmp;try rewrite HT2 in HOoCApCpMQSpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: M :: nil) (C :: Ap :: Cp :: M :: Q :: Sp :: nil) (Ap :: Cp :: M :: nil) 4 3 3 HOoCApCpMQSpmtmp HApCpMmtmp HOoApCpMMtmp Hincl); apply HT.
}
try clear HOoCApCpMQSpM1. try clear HOoCApCpMQSpM2. try clear HOoCApCpMQSpM3. try clear HOoCApCpMQSpm4. try clear HOoCApCpMQSpm3. try clear HOoCApCpMQSpm2. try clear HOoCApCpMQSpm1. 

assert(HCApCpMQSpM : rk(C :: Ap :: Cp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApCpMQSpm : rk(C :: Ap :: Cp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HCApCpMQSpeq HCApCpMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CCpSp requis par la preuve de (?)CCpSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSp requis par la preuve de (?)CCpSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSp requis par la preuve de (?)OoACCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSp requis par la preuve de (?)OoACCpSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpm2 : rk(Oo :: A :: C :: Cp :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpm3 : rk(Oo :: A :: C :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CCpSp requis par la preuve de (?)CCpSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpm2 : rk(C :: Cp :: Sp :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpmtmp : rk(Oo :: A :: C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HOoACCpSpeq HOoACCpSpm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpmtmp;try rewrite HT2 in HOoACCpSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpM1. try clear HOoACCpSpM2. try clear HOoACCpSpM3. try clear HOoACCpSpm4. try clear HOoACCpSpm3. try clear HOoACCpSpm2. try clear HOoACCpSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCCpSpm3 : rk(C :: Cp :: Sp :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HCApCpMQSpeq : rk(C :: Ap :: Cp :: M :: Q :: Sp :: nil) = 4) by (apply LCApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApCpMQSpmtmp : rk(C :: Ap :: Cp :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HCApCpMQSpeq HCApCpMQSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (C :: Cp :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: M :: Q :: Sp :: nil) (C :: Cp :: Sp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Sp :: Ap :: M :: Q :: Sp :: nil) ((C :: Cp :: Sp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApCpMQSpmtmp;try rewrite HT2 in HCApCpMQSpmtmp.
	assert(HT := rule_2 (C :: Cp :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil) (Sp :: nil) 4 1 2 HCApCpMQSpmtmp HSpmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HCCpSpM : rk(C :: Cp :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCCpSpeq HCCpSpM3).
assert(HCCpSpm : rk(C :: Cp :: Sp ::  nil) >= 1) by (solve_hyps_min HCCpSpeq HCCpSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMSp requis par la preuve de (?)ApMSp pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)ApMSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMQ requis par la preuve de (?)OoAApMQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQm2 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMQm3 : rk(Oo :: A :: Ap :: M :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApMSp requis par la preuve de (?)ApMSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: M :: Q ::   de rang : 3 et 4 *)
assert(HApMSpm2 : rk(Ap :: M :: Sp :: nil) >= 2).
{
	assert(HOoAApMQMtmp : rk(Oo :: A :: Ap :: M :: Q :: nil) <= 4) by (solve_hyps_max HOoAApMQeq HOoAApMQM4).
	try assert(HOoAApMQSpeq : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) = 4) by (apply LOoAApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMQSpmtmp : rk(Oo :: A :: Ap :: M :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApMQSpeq HOoAApMQSpm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: Ap :: M :: Q :: nil) (Ap :: M :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: Q :: Sp :: nil) (Oo :: A :: Ap :: M :: Q :: Ap :: M :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: M :: Q :: Ap :: M :: Sp :: nil) ((Oo :: A :: Ap :: M :: Q :: nil) ++ (Ap :: M :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMQSpmtmp;try rewrite HT2 in HOoAApMQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: M :: Q :: nil) (Ap :: M :: Sp :: nil) (Ap :: M :: nil) 4 2 4 HOoAApMQSpmtmp HApMmtmp HOoAApMQMtmp Hincl); apply HT.
}
try clear HOoAApMQM1. try clear HOoAApMQM2. try clear HOoAApMQM3. try clear HOoAApMQm4. try clear HOoAApMQm3. try clear HOoAApMQm2. try clear HOoAApMQm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApMSpM2 : rk(Ap :: M :: Sp :: nil) <= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: M :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: M :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil) 2 2 HApMQSpMtmp Hcomp Hincl);apply HT.
}


assert(HApMSpM : rk(Ap :: M :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMSpeq HApMSpM3).
assert(HApMSpm : rk(Ap :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HApMSpeq HApMSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LNSp *)
(* dans constructLemma(), requis par LBpNPSpT *)
(* dans constructLemma(), requis par LApBpMNPSpT *)
(* dans la couche 0 *)
Lemma LApBpMNPQSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HApBpMNPQSpTM : rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpMNPQSpTm : rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HApBpMNPQSpTeq HApBpMNPQSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpMNPSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: M :: N :: P :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpMNPSpT requis par la preuve de (?)ApBpMNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApBpMNPSpT requis par la preuve de (?)ApBpMNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpMNPSpT requis par la preuve de (?)OoApBpMNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpMNPSpT requis par la preuve de (?)OoApBpMNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMNPSpTm2 : rk(Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpMNPSpTm3 : rk(Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoApMeq : rk(Oo :: Ap :: M :: nil) = 3) by (apply LOoApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApMmtmp : rk(Oo :: Ap :: M :: nil) >= 3) by (solve_hyps_min HOoApMeq HOoApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: M :: nil) (Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) 3 3 HOoApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpMNPSpT requis par la preuve de (?)ApBpMNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpMNPSpT requis par la preuve de (?)ApBpMNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpMNPSpTm2 : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T ::  de rang :  3 et 4 	 AiB : Ap :: Bp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: M ::   de rang : 3 et 3 *)
assert(HApBpMNPSpTm3 : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoApBpMeq : rk(Oo :: Ap :: Bp :: M :: nil) = 3) by (apply LOoApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMMtmp : rk(Oo :: Ap :: Bp :: M :: nil) <= 3) by (solve_hyps_max HOoApBpMeq HOoApBpMM3).
	assert(HOoApBpMNPSpTmtmp : rk(Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 3) by (solve_hyps_min HOoApBpMNPSpTeq HOoApBpMNPSpTm3).
	try assert(HApBpMeq : rk(Ap :: Bp :: M :: nil) = 3) by (apply LApBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMmtmp : rk(Ap :: Bp :: M :: nil) >= 3) by (solve_hyps_min HApBpMeq HApBpMm3).
	assert(Hincl : incl (Ap :: Bp :: M :: nil) (list_inter (Oo :: Ap :: Bp :: M :: nil) (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) (Oo :: Ap :: Bp :: M :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: M :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) ((Oo :: Ap :: Bp :: M :: nil) ++ (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpMNPSpTmtmp;try rewrite HT2 in HOoApBpMNPSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: M :: nil) (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) (Ap :: Bp :: M :: nil) 3 3 3 HOoApBpMNPSpTmtmp HApBpMmtmp HOoApBpMMtmp Hincl); apply HT.
}
try clear HOoApBpMNPSpTM1. try clear HOoApBpMNPSpTM2. try clear HOoApBpMNPSpTM3. try clear HOoApBpMNPSpTm4. try clear HOoApBpMNPSpTm3. try clear HOoApBpMNPSpTm2. try clear HOoApBpMNPSpTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Ap :: M :: Q ::   de rang : 2 et 2 *)
assert(HApBpMNPSpTm4 : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HApBpMNPQSpTeq : rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T :: nil) = 4) by (apply LApBpMNPQSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNPQSpTmtmp : rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNPQSpTeq HApBpMNPQSpTm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Ap :: M :: Q :: nil) (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Q :: Sp :: T :: nil) (Ap :: M :: Q :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) ((Ap :: M :: Q :: nil) ++ (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPQSpTmtmp;try rewrite HT2 in HApBpMNPQSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Q :: nil) (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) (Ap :: M :: nil) 4 2 2 HApBpMNPQSpTmtmp HApMmtmp HApMQMtmp Hincl); apply HT.
}


assert(HApBpMNPSpTM : rk(Ap :: Bp :: M :: N :: P :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpMNPSpTm : rk(Ap :: Bp :: M :: N :: P :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HApBpMNPSpTeq HApBpMNPSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpNPSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: P :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNPSpT requis par la preuve de (?)BpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpNPSpT requis par la preuve de (?)BpNPSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)BpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)OoABBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)OoABBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)OoABBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPSpTm2 : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPSpTm3 : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPSpTm4 : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpNPSpT requis par la preuve de (?)BpNPSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: N ::   de rang : 4 et 4 *)
assert(HBpNPSpTm2 : rk(Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNMtmp : rk(Oo :: A :: B :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABBpNeq HOoABBpNM4).
	assert(HOoABBpNPSpTmtmp : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABBpNPSpTeq HOoABBpNPSpTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: A :: B :: Bp :: N :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Bp :: N :: P :: Sp :: T :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNPSpTmtmp;try rewrite HT2 in HOoABBpNPSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: P :: Sp :: T :: nil) (Bp :: N :: nil) 4 2 4 HOoABBpNPSpTmtmp HBpNmtmp HOoABBpNMtmp Hincl); apply HT.
}
try clear HOoABBpNPSpTM1. try clear HOoABBpNPSpTM2. try clear HOoABBpNPSpTM3. try clear HOoABBpNPSpTm4. try clear HOoABBpNPSpTm3. try clear HOoABBpNPSpTm2. try clear HOoABBpNPSpTm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpNPSpTM3 : rk(Bp :: N :: P :: Sp :: T :: nil) <= 3).
{
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpMtmp : rk(Sp :: nil) <= 1) by (solve_hyps_max HSpeq HSpM1).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Sp :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: N :: P :: Sp :: T :: nil) (Sp :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Sp :: Bp :: N :: P :: T :: nil) ((Sp :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Sp :: nil) (Bp :: N :: P :: T :: nil) (nil) 1 2 0 HSpMtmp HBpNPTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : Sp ::  de rang :  1 et 1 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HBpNPSpTm3 : rk(Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApBpMNPSpTeq : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) = 4) by (apply LApBpMNPSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNPSpTmtmp : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNPSpTeq HApBpMNPSpTm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Ap :: M :: Sp :: nil) (Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) (Ap :: M :: Sp :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: Bp :: N :: P :: Sp :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPSpTmtmp;try rewrite HT2 in HApBpMNPSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (Bp :: N :: P :: Sp :: T :: nil) (Sp :: nil) 4 1 2 HApBpMNPSpTmtmp HSpmtmp HApMSpMtmp Hincl); apply HT.
}


assert(HBpNPSpTM : rk(Bp :: N :: P :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpNPSpTm : rk(Bp :: N :: P :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HBpNPSpTeq HBpNPSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NSp requis par la preuve de (?)NSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HNSpm2 : rk(N :: Sp :: nil) >= 2).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HBpNPSpTeq : rk(Bp :: N :: P :: Sp :: T :: nil) = 3) by (apply LBpNPSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPSpTmtmp : rk(Bp :: N :: P :: Sp :: T :: nil) >= 3) by (solve_hyps_min HBpNPSpTeq HBpNPSpTm3).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (N :: Sp :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: N :: P :: Sp :: T :: nil) (N :: Sp :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: Sp :: Bp :: N :: P :: T :: nil) ((N :: Sp :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpNPSpTmtmp;try rewrite HT2 in HBpNPSpTmtmp.
	assert(HT := rule_2 (N :: Sp :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 3 1 2 HBpNPSpTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HNSpM : rk(N :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNSpeq HNSpM2).
assert(HNSpm : rk(N :: Sp ::  nil) >= 1) by (solve_hyps_min HNSpeq HNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCNSp *)
(* dans la couche 0 *)
Lemma LBCApMNQSpV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMNQSpV requis par la preuve de (?)BCApMNQSpV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMNQSpV requis par la preuve de (?)BCApMNQSpV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMNQSpV requis par la preuve de (?)BCApMNQSpV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMNQSpVm2 : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMNQSpVm3 : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 3).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) 3 3 HBCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMNQSpVm4 : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


assert(HBCApMNQSpVM : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApMNQSpVm : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V ::  nil) >= 1) by (solve_hyps_min HBCApMNQSpVeq HBCApMNQSpVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCNSp *)
(* dans constructLemma(), requis par LBApMNQSpV *)
(* dans la couche 0 *)
Lemma LBApMNQV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: M :: N :: Q :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApMNQV requis par la preuve de (?)BApMNQV pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApMNQV requis par la preuve de (?)BApMNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQV requis par la preuve de (?)BApMNQV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQV requis par la preuve de (?)OoABApMNQV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQV requis par la preuve de (?)OoABApMNQV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQVm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQVm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApMNQV requis par la preuve de (?)BApMNQV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q :: V ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApMNQVm2 : rk(B :: Ap :: M :: N :: Q :: V :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMNQVmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HOoABApMNQVeq HOoABApMNQVm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: V :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: M :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: M :: N :: Q :: V :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: M :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQVmtmp;try rewrite HT2 in HOoABApMNQVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: N :: Q :: V :: nil) (B :: Ap :: nil) 3 2 3 HOoABApMNQVmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApMNQVM1. try clear HOoABApMNQVM2. try clear HOoABApMNQVM3. try clear HOoABApMNQVm4. try clear HOoABApMNQVm3. try clear HOoABApMNQVm2. try clear HOoABApMNQVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApMNQVm3 : rk(B :: Ap :: M :: N :: Q :: V :: nil) >= 3).
{
	try assert(HBApMeq : rk(B :: Ap :: M :: nil) = 3) by (apply LBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMmtmp : rk(B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HBApMeq HBApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: M :: nil) (B :: Ap :: M :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: M :: nil) (B :: Ap :: M :: N :: Q :: V :: nil) 3 3 HBApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBApMNQVM3 : rk(B :: Ap :: M :: N :: Q :: V :: nil) <= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HQmtmp : rk(Q :: nil) >= 1) by (solve_hyps_min HQeq HQm1).
	assert(Hincl : incl (Q :: nil) (list_inter (Ap :: M :: Q :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: N :: Q :: V :: nil) (Ap :: M :: Q :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: B :: N :: Q :: V :: nil) ((Ap :: M :: Q :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Q :: nil) (B :: N :: Q :: V :: nil) (Q :: nil) 2 2 1 HApMQMtmp HBNQVMtmp HQmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBApMNQVM : rk(B :: Ap :: M :: N :: Q :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApMNQVm : rk(B :: Ap :: M :: N :: Q :: V ::  nil) >= 1) by (solve_hyps_min HBApMNQVeq HBApMNQVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApMNQSpV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: M :: N :: Q :: Sp :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApMNQSpV requis par la preuve de (?)BApMNQSpV pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApMNQSpV requis par la preuve de (?)BApMNQSpV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQSpV requis par la preuve de (?)BApMNQSpV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQSpV requis par la preuve de (?)OoABApMNQSpV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQSpV requis par la preuve de (?)OoABApMNQSpV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpVm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpVm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApMNQSpV requis par la preuve de (?)BApMNQSpV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApMNQSpVm2 : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApMNQSpVmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 3) by (solve_hyps_min HOoABApMNQSpVeq HOoABApMNQSpVm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: M :: N :: Q :: Sp :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQSpVmtmp;try rewrite HT2 in HOoABApMNQSpVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil) (B :: Ap :: nil) 3 2 3 HOoABApMNQSpVmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApMNQSpVM1. try clear HOoABApMNQSpVM2. try clear HOoABApMNQSpVM3. try clear HOoABApMNQSpVm4. try clear HOoABApMNQSpVm3. try clear HOoABApMNQSpVm2. try clear HOoABApMNQSpVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApMNQSpVm3 : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 3).
{
	try assert(HBApMeq : rk(B :: Ap :: M :: nil) = 3) by (apply LBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMmtmp : rk(B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HBApMeq HBApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: M :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: M :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 3 3 HBApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBApMNQSpVM3 : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) <= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HBApMNQVeq : rk(B :: Ap :: M :: N :: Q :: V :: nil) = 3) by (apply LBApMNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMNQVMtmp : rk(B :: Ap :: M :: N :: Q :: V :: nil) <= 3) by (solve_hyps_max HBApMNQVeq HBApMNQVM3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Ap :: M :: Sp :: nil) (B :: Ap :: M :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: M :: N :: Q :: Sp :: V :: nil) (Ap :: M :: Sp :: B :: Ap :: M :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: B :: Ap :: M :: N :: Q :: V :: nil) ((Ap :: M :: Sp :: nil) ++ (B :: Ap :: M :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Sp :: nil) (B :: Ap :: M :: N :: Q :: V :: nil) (Ap :: M :: nil) 2 3 2 HApMSpMtmp HBApMNQVMtmp HApMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBApMNQSpVM : rk(B :: Ap :: M :: N :: Q :: Sp :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApMNQSpVm : rk(B :: Ap :: M :: N :: Q :: Sp :: V ::  nil) >= 1) by (solve_hyps_min HBApMNQSpVeq HBApMNQSpVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: N :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CNSp requis par la preuve de (?)CNSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApNQ requis par la preuve de (?)CNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApNQ requis par la preuve de (?)OoCApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApNQ requis par la preuve de (?)OoACApNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApNQ requis par la preuve de (?)OoACApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNQm2 : rk(Oo :: A :: C :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNQm3 : rk(Oo :: A :: C :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApNQ requis par la preuve de (?)OoCApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApNQ requis par la preuve de (?)OoCApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNQm2 : rk(Oo :: C :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Q :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: N :: Q ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApNQm3 : rk(Oo :: C :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApNQmtmp : rk(Oo :: A :: C :: Ap :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoACApNQeq HOoACApNQm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: N :: Q :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Q :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApNQmtmp;try rewrite HT2 in HOoACApNQmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Q :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApNQmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApNQM1. try clear HOoACApNQM2. try clear HOoACApNQM3. try clear HOoACApNQm4. try clear HOoACApNQm3. try clear HOoACApNQm2. try clear HOoACApNQm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CNSp requis par la preuve de (?)CNSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : Oo :: C :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : C :: N ::  de rang :  2 et 2 	 A : Oo :: C :: Ap :: N :: Q ::   de rang : 3 et 4 *)
assert(HCNSpm2 : rk(C :: N :: Sp :: nil) >= 2).
{
	assert(HOoCApNQMtmp : rk(Oo :: C :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HOoCApNQeq HOoCApNQM4).
	try assert(HOoCApNQSpeq : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoCApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNQSpmtmp : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApNQSpeq HOoCApNQSpm4).
	try assert(HCNeq : rk(C :: N :: nil) = 2) by (apply LCN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCNmtmp : rk(C :: N :: nil) >= 2) by (solve_hyps_min HCNeq HCNm2).
	assert(Hincl : incl (C :: N :: nil) (list_inter (Oo :: C :: Ap :: N :: Q :: nil) (C :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: N :: Q :: C :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: N :: Q :: C :: N :: Sp :: nil) ((Oo :: C :: Ap :: N :: Q :: nil) ++ (C :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApNQSpmtmp;try rewrite HT2 in HOoCApNQSpmtmp.
	assert(HT := rule_4 (Oo :: C :: Ap :: N :: Q :: nil) (C :: N :: Sp :: nil) (C :: N :: nil) 4 2 4 HOoCApNQSpmtmp HCNmtmp HOoCApNQMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCNSpm3 : rk(C :: N :: Sp :: nil) >= 3).
{
	try assert(HBApMNQSpVeq : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) = 3) by (apply LBApMNQSpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMNQSpVMtmp : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) <= 3) by (solve_hyps_max HBApMNQSpVeq HBApMNQSpVM3).
	try assert(HBCApMNQSpVeq : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) = 4) by (apply LBCApMNQSpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApMNQSpVmtmp : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 4) by (solve_hyps_min HBCApMNQSpVeq HBCApMNQSpVm4).
	try assert(HNSpeq : rk(N :: Sp :: nil) = 2) by (apply LNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNSpmtmp : rk(N :: Sp :: nil) >= 2) by (solve_hyps_min HNSpeq HNSpm2).
	assert(Hincl : incl (N :: Sp :: nil) (list_inter (C :: N :: Sp :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: N :: Q :: Sp :: V :: nil) (C :: N :: Sp :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: N :: Sp :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) ((C :: N :: Sp :: nil) ++ (B :: Ap :: M :: N :: Q :: Sp :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMNQSpVmtmp;try rewrite HT2 in HBCApMNQSpVmtmp.
	assert(HT := rule_2 (C :: N :: Sp :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil) (N :: Sp :: nil) 4 2 3 HBCApMNQSpVmtmp HNSpmtmp HBApMNQSpVMtmp Hincl);apply HT.
}
try clear HNSpM1. try clear HNSpM2. try clear HNSpM3. try clear HNSpm4. try clear HNSpm3. try clear HNSpm2. try clear HNSpm1. 

assert(HCNSpM : rk(C :: N :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCNSpeq HCNSpM3).
assert(HCNSpm : rk(C :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HCNSpeq HCNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApNSp *)
(* dans la couche 0 *)
Lemma LApBpNPSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: Bp :: N :: P :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpNPSpT requis par la preuve de (?)ApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApBpNPSpT requis par la preuve de (?)ApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoABCApBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoABCApBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoABCApBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPSpTm2 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPSpTm3 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPSpTm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNPSpTm2 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNPSpTm3 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApBpNPSpTm4 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	assert(HOoABCApBpNPSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApBpNPSpTeq HOoABCApBpNPSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpNPSpTmtmp;try rewrite HT2 in HOoABCApBpNPSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApBpNPSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}
try clear HOoABCApBpNPSpTM1. try clear HOoABCApBpNPSpTM2. try clear HOoABCApBpNPSpTM3. try clear HOoABCApBpNPSpTm4. try clear HOoABCApBpNPSpTm3. try clear HOoABCApBpNPSpTm2. try clear HOoABCApBpNPSpTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpNPSpT requis par la preuve de (?)OoApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpNPSpT requis par la preuve de (?)OoApBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNPSpTm2 : rk(Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: N ::  de rang :  3 et 3 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoApBpNPSpTm3 : rk(Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	assert(HOoBCApBpNPSpTmtmp : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoBCApBpNPSpTeq HOoBCApBpNPSpTm4).
	try assert(HOoApNeq : rk(Oo :: Ap :: N :: nil) = 3) by (apply LOoApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApNmtmp : rk(Oo :: Ap :: N :: nil) >= 3) by (solve_hyps_min HOoApNeq HOoApNm3).
	assert(Hincl : incl (Oo :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpNPSpTmtmp;try rewrite HT2 in HOoBCApBpNPSpTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: Ap :: N :: nil) 4 3 4 HOoBCApBpNPSpTmtmp HOoApNmtmp HOoBCApNMtmp Hincl); apply HT.
}
try clear HOoBCApBpNPSpTM1. try clear HOoBCApBpNPSpTM2. try clear HOoBCApBpNPSpTM3. try clear HOoBCApBpNPSpTm4. try clear HOoBCApBpNPSpTm3. try clear HOoBCApBpNPSpTm2. try clear HOoBCApBpNPSpTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpNPSpT requis par la preuve de (?)ApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpNPSpT requis par la preuve de (?)ApBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNPSpTm2 : rk(Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: N :: P :: Sp :: T ::  de rang :  3 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HApBpNPSpTm3 : rk(Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	assert(HOoApBpNPSpTmtmp : rk(Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3) by (solve_hyps_min HOoApBpNPSpTeq HOoApBpNPSpTm3).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: Ap :: Bp :: N :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: Ap :: Bp :: N :: P :: Sp :: T :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpNPSpTmtmp;try rewrite HT2 in HOoApBpNPSpTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (Ap :: Bp :: N :: P :: Sp :: T :: nil) (Ap :: Bp :: N :: nil) 3 3 3 HOoApBpNPSpTmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoApBpNPSpTM1. try clear HOoApBpNPSpTM2. try clear HOoApBpNPSpTM3. try clear HOoApBpNPSpTm4. try clear HOoApBpNPSpTm3. try clear HOoApBpNPSpTm2. try clear HOoApBpNPSpTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: Sp ::  de rang :  2 et 2 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HApBpNPSpTm4 : rk(Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApBpMNPSpTeq : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) = 4) by (apply LApBpMNPSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNPSpTmtmp : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNPSpTeq HApBpMNPSpTm4).
	try assert(HApSpeq : rk(Ap :: Sp :: nil) = 2) by (apply LApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApSpmtmp : rk(Ap :: Sp :: nil) >= 2) by (solve_hyps_min HApSpeq HApSpm2).
	assert(Hincl : incl (Ap :: Sp :: nil) (list_inter (Ap :: M :: Sp :: nil) (Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) (Ap :: M :: Sp :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: Ap :: Bp :: N :: P :: Sp :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPSpTmtmp;try rewrite HT2 in HApBpMNPSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (Ap :: Bp :: N :: P :: Sp :: T :: nil) (Ap :: Sp :: nil) 4 2 2 HApBpMNPSpTmtmp HApSpmtmp HApMSpMtmp Hincl); apply HT.
}
try clear HApSpM1. try clear HApSpM2. try clear HApSpM3. try clear HApSpm4. try clear HApSpm3. try clear HApSpm2. try clear HApSpm1. 

assert(HApBpNPSpTM : rk(Ap :: Bp :: N :: P :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpNPSpTm : rk(Ap :: Bp :: N :: P :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HApBpNPSpTeq HApBpNPSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: N :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApNSp requis par la preuve de (?)ApNSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)ApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoABApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoABApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoABApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQSpm2 : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQSpm3 : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: Ap :: M :: N ::   de rang : 4 et 4 *)
assert(HOoABApNQSpm4 : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBApMNeq : rk(Oo :: B :: Ap :: M :: N :: nil) = 4) by (apply LOoBApMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNMtmp : rk(Oo :: B :: Ap :: M :: N :: nil) <= 4) by (solve_hyps_max HOoBApMNeq HOoBApMNM4).
	try assert(HOoABApMNQSpeq : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMNQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMNQSpeq HOoABApMNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: Ap :: M :: N :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: M :: N :: Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: M :: N :: Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) ((Oo :: B :: Ap :: M :: N :: nil) ++ (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQSpmtmp;try rewrite HT2 in HOoABApMNQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: M :: N :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoABApMNQSpmtmp HOoBApNmtmp HOoBApMNMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNQSpm2 : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNQSpm3 : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Q ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Q ::   de rang : 3 et 3 *)
assert(HOoAApNQSpm4 : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABQeq : rk(Oo :: A :: B :: Q :: nil) = 3) by (apply LOoABQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABQMtmp : rk(Oo :: A :: B :: Q :: nil) <= 3) by (solve_hyps_max HOoABQeq HOoABQM3).
	assert(HOoABApNQSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApNQSpeq HOoABApNQSpm4).
	try assert(HOoAQeq : rk(Oo :: A :: Q :: nil) = 3) by (apply LOoAQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAQmtmp : rk(Oo :: A :: Q :: nil) >= 3) by (solve_hyps_min HOoAQeq HOoAQm3).
	assert(Hincl : incl (Oo :: A :: Q :: nil) (list_inter (Oo :: A :: B :: Q :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: A :: B :: Q :: Oo :: A :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Q :: Oo :: A :: Ap :: N :: Q :: Sp :: nil) ((Oo :: A :: B :: Q :: nil) ++ (Oo :: A :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQSpmtmp;try rewrite HT2 in HOoABApNQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Q :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil) (Oo :: A :: Q :: nil) 4 3 3 HOoABApNQSpmtmp HOoAQmtmp HOoABQMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApNQ requis par la preuve de (?)ApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApNQ requis par la preuve de (?)OoAApNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApNQ requis par la preuve de (?)OoAApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNQm2 : rk(Oo :: A :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNQm3 : rk(Oo :: A :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApNSp requis par la preuve de (?)ApNSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Ap :: N ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: N :: Q ::   de rang : 3 et 4 *)
assert(HApNSpm2 : rk(Ap :: N :: Sp :: nil) >= 2).
{
	assert(HOoAApNQMtmp : rk(Oo :: A :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HOoAApNQeq HOoAApNQM4).
	assert(HOoAApNQSpmtmp : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoAApNQSpeq HOoAApNQSpm4).
	try assert(HApNeq : rk(Ap :: N :: nil) = 2) by (apply LApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApNmtmp : rk(Ap :: N :: nil) >= 2) by (solve_hyps_min HApNeq HApNm2).
	assert(Hincl : incl (Ap :: N :: nil) (list_inter (Oo :: A :: Ap :: N :: Q :: nil) (Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: N :: Q :: Sp :: nil) (Oo :: A :: Ap :: N :: Q :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: N :: Q :: Ap :: N :: Sp :: nil) ((Oo :: A :: Ap :: N :: Q :: nil) ++ (Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApNQSpmtmp;try rewrite HT2 in HOoAApNQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: N :: Q :: nil) (Ap :: N :: Sp :: nil) (Ap :: N :: nil) 4 2 4 HOoAApNQSpmtmp HApNmtmp HOoAApNQMtmp Hincl); apply HT.
}
try clear HOoAApNQM1. try clear HOoAApNQM2. try clear HOoAApNQM3. try clear HOoAApNQm4. try clear HOoAApNQm3. try clear HOoAApNQm2. try clear HOoAApNQm1. try clear HApNM1. try clear HApNM2. try clear HApNM3. try clear HApNm4. try clear HApNm3. try clear HApNm2. try clear HApNm1. try clear HOoAApNQSpM1. try clear HOoAApNQSpM2. try clear HOoAApNQSpM3. try clear HOoAApNQSpm4. try clear HOoAApNQSpm3. try clear HOoAApNQSpm2. try clear HOoAApNQSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApNSpm3 : rk(Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HApBpNPSpTeq : rk(Ap :: Bp :: N :: P :: Sp :: T :: nil) = 4) by (apply LApBpNPSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNPSpTmtmp : rk(Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpNPSpTeq HApBpNPSpTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Ap :: N :: Sp :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: N :: P :: Sp :: T :: nil) (Ap :: N :: Sp :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: N :: Sp :: Bp :: N :: P :: T :: nil) ((Ap :: N :: Sp :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpNPSpTmtmp;try rewrite HT2 in HApBpNPSpTmtmp.
	assert(HT := rule_2 (Ap :: N :: Sp :: nil) (Bp :: N :: P :: T :: nil) (N :: nil) 4 1 2 HApBpNPSpTmtmp HNmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HApNSpM : rk(Ap :: N :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApNSpeq HApNSpM3).
assert(HApNSpm : rk(Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HApNSpeq HApNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApNSp *)
(* dans la couche 0 *)
Lemma LABApMNQSpV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApMNQSpV requis par la preuve de (?)ABApMNQSpV pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApMNQSpV requis par la preuve de (?)ABApMNQSpV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApMNQSpV requis par la preuve de (?)ABApMNQSpV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNQSpVm2 : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNQSpVm3 : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 3).
{
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApMNQSpVm4 : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 4).
{
	try assert(HABApMeq : rk(A :: B :: Ap :: M :: nil) = 4) by (apply LABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMmtmp : rk(A :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HABApMeq HABApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: M :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: M :: nil) (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 4 4 HABApMmtmp Hcomp Hincl);apply HT.
}


assert(HABApMNQSpVM : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApMNQSpVm : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V ::  nil) >= 1) by (solve_hyps_min HABApMNQSpVeq HABApMNQSpVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApNSp requis par la preuve de (?)AApNSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApNSp requis par la preuve de (?)AApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm2 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm3 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNSpm2 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: N :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApNSpm3 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Sp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNSpmtmp;try rewrite HT2 in HOoABApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Sp :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApNSpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap :: N ::  de rang :  4 et 4 	 A : A :: B :: Ap :: N :: Q ::   de rang : 4 et 4 *)
assert(HABApNSpm4 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 4).
{
	try assert(HABApNQeq : rk(A :: B :: Ap :: N :: Q :: nil) = 4) by (apply LABApNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNQMtmp : rk(A :: B :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HABApNQeq HABApNQM4).
	try assert(HABApNQSpeq : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LABApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNQSpmtmp : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApNQSpeq HABApNQSpm4).
	try assert(HABApNeq : rk(A :: B :: Ap :: N :: nil) = 4) by (apply LABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNmtmp : rk(A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HABApNeq HABApNm4).
	assert(Hincl : incl (A :: B :: Ap :: N :: nil) (list_inter (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: N :: Q :: Sp :: nil) (A :: B :: Ap :: N :: Q :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: N :: Q :: A :: B :: Ap :: N :: Sp :: nil) ((A :: B :: Ap :: N :: Q :: nil) ++ (A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApNQSpmtmp;try rewrite HT2 in HABApNQSpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: N :: Sp :: nil) (A :: B :: Ap :: N :: nil) 4 4 4 HABApNQSpmtmp HABApNmtmp HABApNQMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BSp requis par la preuve de (?)AApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApNSp requis par la preuve de (?)AApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApNSp requis par la preuve de (?)AApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApNSpm2 : rk(A :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: N :: Sp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: Ap :: N :: Sp ::  de rang :  4 et 4 	 AiB : Sp ::  de rang :  1 et 1 	 A : B :: Sp ::   de rang : 1 et 2 *)
assert(HAApNSpm3 : rk(A :: Ap :: N :: Sp :: nil) >= 3).
{
	assert(HBSpMtmp : rk(B :: Sp :: nil) <= 2) by (solve_hyps_max HBSpeq HBSpM2).
	assert(HABApNSpmtmp : rk(A :: B :: Ap :: N :: Sp :: nil) >= 4) by (solve_hyps_min HABApNSpeq HABApNSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (B :: Sp :: nil) (A :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: N :: Sp :: nil) (B :: Sp :: A :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Sp :: A :: Ap :: N :: Sp :: nil) ((B :: Sp :: nil) ++ (A :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApNSpmtmp;try rewrite HT2 in HABApNSpmtmp.
	assert(HT := rule_4 (B :: Sp :: nil) (A :: Ap :: N :: Sp :: nil) (Sp :: nil) 4 1 2 HABApNSpmtmp HSpmtmp HBSpMtmp Hincl); apply HT.
}
try clear HBSpM1. try clear HBSpM2. try clear HBSpM3. try clear HBSpm4. try clear HBSpm3. try clear HBSpm2. try clear HBSpm1. try clear HABApNSpM1. try clear HABApNSpM2. try clear HABApNSpM3. try clear HABApNSpm4. try clear HABApNSpm3. try clear HABApNSpm2. try clear HABApNSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApNSpm4 : rk(A :: Ap :: N :: Sp :: nil) >= 4).
{
	try assert(HBApMNQSpVeq : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) = 3) by (apply LBApMNQSpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMNQSpVMtmp : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) <= 3) by (solve_hyps_max HBApMNQSpVeq HBApMNQSpVM3).
	try assert(HABApMNQSpVeq : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) = 4) by (apply LABApMNQSpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApMNQSpVmtmp : rk(A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) >= 4) by (solve_hyps_min HABApMNQSpVeq HABApMNQSpVm4).
	try assert(HApNSpeq : rk(Ap :: N :: Sp :: nil) = 3) by (apply LApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApNSpmtmp : rk(Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HApNSpeq HApNSpm3).
	assert(Hincl : incl (Ap :: N :: Sp :: nil) (list_inter (A :: Ap :: N :: Sp :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) (A :: Ap :: N :: Sp :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: N :: Sp :: B :: Ap :: M :: N :: Q :: Sp :: V :: nil) ((A :: Ap :: N :: Sp :: nil) ++ (B :: Ap :: M :: N :: Q :: Sp :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApMNQSpVmtmp;try rewrite HT2 in HABApMNQSpVmtmp.
	assert(HT := rule_2 (A :: Ap :: N :: Sp :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil) (Ap :: N :: Sp :: nil) 4 3 3 HABApMNQSpVmtmp HApNSpmtmp HBApMNQSpVMtmp Hincl);apply HT.
}


assert(HAApNSpM : rk(A :: Ap :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApNSpm : rk(A :: Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HAApNSpeq HAApNSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApNSp *)
(* dans constructLemma(), requis par LOoABApNSp *)
(* dans la couche 0 *)
Lemma LOoABApNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoABApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoABApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNQSp requis par la preuve de (?)OoABApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQSpm2 : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQSpm3 : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: Ap :: M :: N ::   de rang : 4 et 4 *)
assert(HOoABApNQSpm4 : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoBApMNeq : rk(Oo :: B :: Ap :: M :: N :: nil) = 4) by (apply LOoBApMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApMNMtmp : rk(Oo :: B :: Ap :: M :: N :: nil) <= 4) by (solve_hyps_max HOoBApMNeq HOoBApMNM4).
	try assert(HOoABApMNQSpeq : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABApMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMNQSpmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApMNQSpeq HOoABApMNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: Ap :: M :: N :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: M :: N :: Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: M :: N :: Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) ((Oo :: B :: Ap :: M :: N :: nil) ++ (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQSpmtmp;try rewrite HT2 in HOoABApMNQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: M :: N :: nil) (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoABApMNQSpmtmp HOoBApNmtmp HOoBApMNMtmp Hincl); apply HT.
}


assert(HOoABApNQSpM : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApNQSpm : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApNQSpeq HOoABApNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm2 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm3 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: Ap :: N :: Q ::   de rang : 4 et 4 *)
assert(HOoABApNSpm4 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 4).
{
	try assert(HOoBApNQeq : rk(Oo :: B :: Ap :: N :: Q :: nil) = 4) by (apply LOoBApNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNQMtmp : rk(Oo :: B :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HOoBApNQeq HOoBApNQM4).
	try assert(HOoABApNQSpeq : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoABApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNQSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApNQSpeq HOoABApNQSpm4).
	try assert(HOoBApNeq : rk(Oo :: B :: Ap :: N :: nil) = 4) by (apply LOoBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNmtmp : rk(Oo :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoBApNeq HOoBApNm4).
	assert(Hincl : incl (Oo :: B :: Ap :: N :: nil) (list_inter (Oo :: B :: Ap :: N :: Q :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: Q :: Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: N :: Q :: Oo :: A :: B :: Ap :: N :: Sp :: nil) ((Oo :: B :: Ap :: N :: Q :: nil) ++ (Oo :: A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQSpmtmp;try rewrite HT2 in HOoABApNQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: N :: Q :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: B :: Ap :: N :: nil) 4 4 4 HOoABApNQSpmtmp HOoBApNmtmp HOoBApNQMtmp Hincl); apply HT.
}


assert(HOoABApNSpM : rk(Oo :: A :: B :: Ap :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApNSpm : rk(Oo :: A :: B :: Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApNSp requis par la preuve de (?)OoAApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApNSp requis par la preuve de (?)OoAApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApNSp requis par la preuve de (?)OoAApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNSpm2 : rk(Oo :: A :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNSpm3 : rk(Oo :: A :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Sp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Sp ::   de rang : 3 et 3 *)
assert(HOoAApNSpm4 : rk(Oo :: A :: Ap :: N :: Sp :: nil) >= 4).
{
	try assert(HOoABSpeq : rk(Oo :: A :: B :: Sp :: nil) = 3) by (apply LOoABSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABSpMtmp : rk(Oo :: A :: B :: Sp :: nil) <= 3) by (solve_hyps_max HOoABSpeq HOoABSpM3).
	try assert(HOoABApNSpeq : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) = 4) by (apply LOoABApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm4).
	try assert(HOoASpeq : rk(Oo :: A :: Sp :: nil) = 3) by (apply LOoASp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoASpmtmp : rk(Oo :: A :: Sp :: nil) >= 3) by (solve_hyps_min HOoASpeq HOoASpm3).
	assert(Hincl : incl (Oo :: A :: Sp :: nil) (list_inter (Oo :: A :: B :: Sp :: nil) (Oo :: A :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: A :: B :: Sp :: Oo :: A :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Sp :: Oo :: A :: Ap :: N :: Sp :: nil) ((Oo :: A :: B :: Sp :: nil) ++ (Oo :: A :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNSpmtmp;try rewrite HT2 in HOoABApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Sp :: nil) (Oo :: A :: Ap :: N :: Sp :: nil) (Oo :: A :: Sp :: nil) 4 3 3 HOoABApNSpmtmp HOoASpmtmp HOoABSpMtmp Hincl); apply HT.
}


assert(HOoAApNSpM : rk(Oo :: A :: Ap :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApNSpm : rk(Oo :: A :: Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApNSpeq HOoAApNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Ap :: N :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApNSp requis par la preuve de (?)BApNSp pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApNQ requis par la preuve de (?)BApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoBApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoABApNQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNQ requis par la preuve de (?)OoABApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQm2 : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNQm3 : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApNQ requis par la preuve de (?)OoBApNQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApNQ requis par la preuve de (?)OoBApNQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApNQm2 : rk(Oo :: B :: Ap :: N :: Q :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Ap :: N :: Q :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Q ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApNQm3 : rk(Oo :: B :: Ap :: N :: Q :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNQmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: nil) >= 3) by (solve_hyps_min HOoABApNQeq HOoABApNQm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: N :: Q :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: N :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQmtmp;try rewrite HT2 in HOoABApNQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: N :: Q :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApNQmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApNSp requis par la preuve de (?)BApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)BApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm2 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm3 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApNSp requis par la preuve de (?)BApNSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApNSpm2 : rk(B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: N :: Sp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNSpmtmp;try rewrite HT2 in HOoABApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: N :: Sp :: nil) (B :: Ap :: nil) 3 2 3 HOoABApNSpmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : Oo :: B :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : B :: Ap :: N ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: N :: Q ::   de rang : 3 et 4 *)
assert(HBApNSpm3 : rk(B :: Ap :: N :: Sp :: nil) >= 3).
{
	assert(HOoBApNQMtmp : rk(Oo :: B :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HOoBApNQeq HOoBApNQM4).
	try assert(HOoBApNQSpeq : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoBApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApNQSpmtmp : rk(Oo :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApNQSpeq HOoBApNQSpm4).
	try assert(HBApNeq : rk(B :: Ap :: N :: nil) = 3) by (apply LBApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApNmtmp : rk(B :: Ap :: N :: nil) >= 3) by (solve_hyps_min HBApNeq HBApNm3).
	assert(Hincl : incl (B :: Ap :: N :: nil) (list_inter (Oo :: B :: Ap :: N :: Q :: nil) (B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: B :: Ap :: N :: Q :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: N :: Q :: B :: Ap :: N :: Sp :: nil) ((Oo :: B :: Ap :: N :: Q :: nil) ++ (B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApNQSpmtmp;try rewrite HT2 in HOoBApNQSpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: N :: Q :: nil) (B :: Ap :: N :: Sp :: nil) (B :: Ap :: N :: nil) 4 3 4 HOoBApNQSpmtmp HBApNmtmp HOoBApNQMtmp Hincl); apply HT.
}
try clear HOoBApNQM1. try clear HOoBApNQM2. try clear HOoBApNQM3. try clear HOoBApNQm4. try clear HOoBApNQm3. try clear HOoBApNQm2. try clear HOoBApNQm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApNSpM3 : rk(B :: Ap :: N :: Sp :: nil) <= 3).
{
	try assert(HBApMNQSpVeq : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) = 3) by (apply LBApMNQSpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApMNQSpVMtmp : rk(B :: Ap :: M :: N :: Q :: Sp :: V :: nil) <= 3) by (solve_hyps_max HBApMNQSpVeq HBApMNQSpVM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: N :: Sp :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: Ap :: N :: Sp :: nil) (B :: Ap :: M :: N :: Q :: Sp :: V :: nil) 3 3 HBApMNQSpVMtmp Hcomp Hincl);apply HT.
}


assert(HBApNSpM : rk(B :: Ap :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApNSpm : rk(B :: Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HBApNSpeq HBApNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Ap :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApNSp requis par la preuve de (?)OoABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm2 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApNSpm3 : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApNSp requis par la preuve de (?)ABApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApNSpm2 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: N :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApNSpm3 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApNSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApNSpeq HOoABApNSpm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Sp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: N :: Sp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNSpmtmp;try rewrite HT2 in HOoABApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: N :: Sp :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApNSpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap :: N ::  de rang :  4 et 4 	 A : A :: B :: Ap :: N :: Q ::   de rang : 4 et 4 *)
assert(HABApNSpm4 : rk(A :: B :: Ap :: N :: Sp :: nil) >= 4).
{
	try assert(HABApNQeq : rk(A :: B :: Ap :: N :: Q :: nil) = 4) by (apply LABApNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNQMtmp : rk(A :: B :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HABApNQeq HABApNQM4).
	try assert(HABApNQSpeq : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LABApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNQSpmtmp : rk(A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HABApNQSpeq HABApNQSpm4).
	try assert(HABApNeq : rk(A :: B :: Ap :: N :: nil) = 4) by (apply LABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABApNmtmp : rk(A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HABApNeq HABApNm4).
	assert(Hincl : incl (A :: B :: Ap :: N :: nil) (list_inter (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: N :: Q :: Sp :: nil) (A :: B :: Ap :: N :: Q :: A :: B :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: N :: Q :: A :: B :: Ap :: N :: Sp :: nil) ((A :: B :: Ap :: N :: Q :: nil) ++ (A :: B :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApNQSpmtmp;try rewrite HT2 in HABApNQSpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: N :: Q :: nil) (A :: B :: Ap :: N :: Sp :: nil) (A :: B :: Ap :: N :: nil) 4 4 4 HABApNQSpmtmp HABApNmtmp HABApNQMtmp Hincl); apply HT.
}


assert(HABApNSpM : rk(A :: B :: Ap :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApNSpm : rk(A :: B :: Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HABApNSpeq HABApNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApNSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: N :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApNSp requis par la preuve de (?)OoCApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApNSp requis par la preuve de (?)OoCApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApNSp requis par la preuve de (?)OoACApNSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApNSp requis par la preuve de (?)OoACApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNSpm2 : rk(Oo :: A :: C :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApNSpm3 : rk(Oo :: A :: C :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: N :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApNSp requis par la preuve de (?)OoCApNSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApNSp requis par la preuve de (?)OoCApNSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNSpm2 : rk(Oo :: C :: Ap :: N :: Sp :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Sp :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: N :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: C :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApNSpm3 : rk(Oo :: C :: Ap :: N :: Sp :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApNSpmtmp : rk(Oo :: A :: C :: Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HOoACApNSpeq HOoACApNSpm3).
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: N :: Sp :: nil) (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: C :: Ap :: N :: Sp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: C :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApNSpmtmp;try rewrite HT2 in HOoACApNSpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Sp :: nil) (Oo :: C :: Ap :: nil) 3 3 3 HOoACApNSpmtmp HOoCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApNSpM1. try clear HOoACApNSpM2. try clear HOoACApNSpM3. try clear HOoACApNSpm4. try clear HOoACApNSpm3. try clear HOoACApNSpm2. try clear HOoACApNSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: C :: Ap :: N :: Q ::   de rang : 4 et 4 *)
assert(HOoCApNSpm4 : rk(Oo :: C :: Ap :: N :: Sp :: nil) >= 4).
{
	try assert(HOoCApNQeq : rk(Oo :: C :: Ap :: N :: Q :: nil) = 4) by (apply LOoCApNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNQMtmp : rk(Oo :: C :: Ap :: N :: Q :: nil) <= 4) by (solve_hyps_max HOoCApNQeq HOoCApNQM4).
	try assert(HOoCApNQSpeq : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoCApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNQSpmtmp : rk(Oo :: C :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApNQSpeq HOoCApNQSpm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: C :: Ap :: N :: Q :: nil) (Oo :: C :: Ap :: N :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: N :: Q :: Sp :: nil) (Oo :: C :: Ap :: N :: Q :: Oo :: C :: Ap :: N :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: N :: Q :: Oo :: C :: Ap :: N :: Sp :: nil) ((Oo :: C :: Ap :: N :: Q :: nil) ++ (Oo :: C :: Ap :: N :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApNQSpmtmp;try rewrite HT2 in HOoCApNQSpmtmp.
	assert(HT := rule_4 (Oo :: C :: Ap :: N :: Q :: nil) (Oo :: C :: Ap :: N :: Sp :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoCApNQSpmtmp HOoCApNmtmp HOoCApNQMtmp Hincl); apply HT.
}


assert(HOoCApNSpM : rk(Oo :: C :: Ap :: N :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApNSpm : rk(Oo :: C :: Ap :: N :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApNSpeq HOoCApNSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApNQSp requis par la preuve de (?)OoAApNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNQSpm2 : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApNQSpm3 : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Q ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Q ::   de rang : 3 et 3 *)
assert(HOoAApNQSpm4 : rk(Oo :: A :: Ap :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABQeq : rk(Oo :: A :: B :: Q :: nil) = 3) by (apply LOoABQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABQMtmp : rk(Oo :: A :: B :: Q :: nil) <= 3) by (solve_hyps_max HOoABQeq HOoABQM3).
	try assert(HOoABApNQSpeq : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) = 4) by (apply LOoABApNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNQSpmtmp : rk(Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABApNQSpeq HOoABApNQSpm4).
	try assert(HOoAQeq : rk(Oo :: A :: Q :: nil) = 3) by (apply LOoAQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAQmtmp : rk(Oo :: A :: Q :: nil) >= 3) by (solve_hyps_min HOoAQeq HOoAQm3).
	assert(Hincl : incl (Oo :: A :: Q :: nil) (list_inter (Oo :: A :: B :: Q :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: N :: Q :: Sp :: nil) (Oo :: A :: B :: Q :: Oo :: A :: Ap :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Q :: Oo :: A :: Ap :: N :: Q :: Sp :: nil) ((Oo :: A :: B :: Q :: nil) ++ (Oo :: A :: Ap :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApNQSpmtmp;try rewrite HT2 in HOoABApNQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Q :: nil) (Oo :: A :: Ap :: N :: Q :: Sp :: nil) (Oo :: A :: Q :: nil) 4 3 3 HOoABApNQSpmtmp HOoAQmtmp HOoABQMtmp Hincl); apply HT.
}


assert(HOoAApNQSpM : rk(Oo :: A :: Ap :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApNQSpm : rk(Oo :: A :: Ap :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoAApNQSpeq HOoAApNQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpNQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: N :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)OoABpNQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)OoABpNQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNQSp requis par la preuve de (?)OoABpNQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNQSpm2 : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNQSpm3 : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: M :: N :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Bp :: N ::  de rang :  4 et 4 	 A : Oo :: A :: Bp :: M :: N ::   de rang : 4 et 4 *)
assert(HOoABpNQSpm4 : rk(Oo :: A :: Bp :: N :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABpMNeq : rk(Oo :: A :: Bp :: M :: N :: nil) = 4) by (apply LOoABpMN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNMtmp : rk(Oo :: A :: Bp :: M :: N :: nil) <= 4) by (solve_hyps_max HOoABpMNeq HOoABpMNM4).
	try assert(HOoABpMNQSpeq : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) = 4) by (apply LOoABpMNQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMNQSpmtmp : rk(Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABpMNQSpeq HOoABpMNQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: Bp :: M :: N :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: M :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: M :: N :: Oo :: A :: Bp :: N :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: M :: N :: Oo :: A :: Bp :: N :: Q :: Sp :: nil) ((Oo :: A :: Bp :: M :: N :: nil) ++ (Oo :: A :: Bp :: N :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpMNQSpmtmp;try rewrite HT2 in HOoABpMNQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: Bp :: M :: N :: nil) (Oo :: A :: Bp :: N :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABpMNQSpmtmp HOoABpNmtmp HOoABpMNMtmp Hincl); apply HT.
}


assert(HOoABpNQSpM : rk(Oo :: A :: Bp :: N :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNQSpm : rk(Oo :: A :: Bp :: N :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpNQSpeq HOoABpNQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpNPQSp *)
(* dans la couche 0 *)
Lemma LOoABCBpNPQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABCBpNPQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABCBpNPQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpNPQSp requis par la preuve de (?)OoABCBpNPQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNPQSpm2 : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNPQSpm3 : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNPQSpm4 : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNmtmp : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABBpNeq HOoABBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) 4 4 HOoABBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpNPQSpM : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNPQSpm : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABCBpNPQSpeq HOoABCBpNPQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpNPQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Bp :: N :: P :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpNPQSp requis par la preuve de (?)OoABpNPQSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNPQSpm2 : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpNPQSpm3 : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Bp :: N ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: Bp :: N ::   de rang : 4 et 4 *)
assert(HOoABpNPQSpm4 : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) >= 4).
{
	try assert(HOoABCBpNeq : rk(Oo :: A :: B :: C :: Bp :: N :: nil) = 4) by (apply LOoABCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNMtmp : rk(Oo :: A :: B :: C :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABCBpNeq HOoABCBpNM4).
	try assert(HOoABCBpNPQSpeq : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) = 4) by (apply LOoABCBpNPQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNPQSpmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCBpNPQSpeq HOoABCBpNPQSpm4).
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (list_inter (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: P :: Q :: Sp :: nil) (Oo :: A :: B :: C :: Bp :: N :: Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Bp :: N :: Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) ((Oo :: A :: B :: C :: Bp :: N :: nil) ++ (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNPQSpmtmp;try rewrite HT2 in HOoABCBpNPQSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: Bp :: N :: P :: Q :: Sp :: nil) (Oo :: A :: Bp :: N :: nil) 4 4 4 HOoABCBpNPQSpmtmp HOoABpNmtmp HOoABCBpNMtmp Hincl); apply HT.
}


assert(HOoABpNPQSpM : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpNPQSpm : rk(Oo :: A :: Bp :: N :: P :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABpNPQSpeq HOoABpNPQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(T ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HTM : rk(T ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HTeq HTM1).
assert(HTm : rk(T ::  nil) >= 1) by (solve_hyps_min HTeq HTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAT requis par la preuve de (?)OoAT pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAT requis par la preuve de (?)OoAT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoATm2 : rk(Oo :: A :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoATm3 : rk(Oo :: A :: T :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoABpNPTeq : rk(Oo :: A :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNPTmtmp : rk(Oo :: A :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABpNPTeq HOoABpNPTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (Oo :: A :: T :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: N :: P :: T :: nil) (Oo :: A :: T :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: T :: Bp :: N :: P :: T :: nil) ((Oo :: A :: T :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpNPTmtmp;try rewrite HT2 in HOoABpNPTmtmp.
	assert(HT := rule_2 (Oo :: A :: T :: nil) (Bp :: N :: P :: T :: nil) (T :: nil) 4 1 2 HOoABpNPTmtmp HTmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoATM : rk(Oo :: A :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoATeq HOoATM3).
assert(HOoATm : rk(Oo :: A :: T ::  nil) >= 1) by (solve_hyps_min HOoATeq HOoATm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CT requis par la preuve de (?)CT pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCTm2 : rk(C :: T :: nil) >= 2).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HCBpNPTeq : rk(C :: Bp :: N :: P :: T :: nil) = 3) by (apply LCBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNPTmtmp : rk(C :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HCBpNPTeq HCBpNPTm3).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (C :: T :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: P :: T :: nil) (C :: T :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: T :: Bp :: N :: P :: T :: nil) ((C :: T :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpNPTmtmp;try rewrite HT2 in HCBpNPTmtmp.
	assert(HT := rule_2 (C :: T :: nil) (Bp :: N :: P :: T :: nil) (T :: nil) 3 1 2 HCBpNPTmtmp HTmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HCTM : rk(C :: T ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCTeq HCTM2).
assert(HCTm : rk(C :: T ::  nil) >= 1) by (solve_hyps_min HCTeq HCTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACT *)
(* dans la couche 0 *)
Lemma LOoACApMT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: Ap :: M :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm2 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm3 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm4 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApMTM : rk(Oo :: A :: C :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMTm : rk(Oo :: A :: C :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HOoACApMTeq HOoACApMTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACT *)
(* dans la couche 0 *)
Lemma LOoAApMT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMT requis par la preuve de (?)OoAApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMT requis par la preuve de (?)OoAApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMT requis par la preuve de (?)OoAApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMTm2 : rk(Oo :: A :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMTm3 : rk(Oo :: A :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMTm4 : rk(Oo :: A :: Ap :: M :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMTM : rk(Oo :: A :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMTm : rk(Oo :: A :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HOoAApMTeq HOoAApMTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: C :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACT requis par la preuve de (?)OoACT pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACT requis par la preuve de (?)OoACT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACT requis par la preuve de (?)OoACT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACTm2 : rk(Oo :: A :: C :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACTM3 : rk(Oo :: A :: C :: T :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTMtmp : rk(T :: nil) <= 1) by (solve_hyps_max HTeq HTM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: T :: nil) (Oo :: A :: C :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: T :: nil) ((Oo :: A :: C :: nil) ++ (T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (T :: nil) (nil) 2 1 0 HOoACMtmp HTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACTm3 : rk(Oo :: A :: C :: T :: nil) >= 3).
{
	try assert(HOoAApMTeq : rk(Oo :: A :: Ap :: M :: T :: nil) = 4) by (apply LOoAApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMTMtmp : rk(Oo :: A :: Ap :: M :: T :: nil) <= 4) by (solve_hyps_max HOoAApMTeq HOoAApMTM4).
	try assert(HOoACApMTeq : rk(Oo :: A :: C :: Ap :: M :: T :: nil) = 4) by (apply LOoACApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMTmtmp : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 4) by (solve_hyps_min HOoACApMTeq HOoACApMTm4).
	try assert(HOoATeq : rk(Oo :: A :: T :: nil) = 3) by (apply LOoAT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoATmtmp : rk(Oo :: A :: T :: nil) >= 3) by (solve_hyps_min HOoATeq HOoATm3).
	assert(Hincl : incl (Oo :: A :: T :: nil) (list_inter (Oo :: A :: C :: T :: nil) (Oo :: A :: Ap :: M :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: T :: nil) (Oo :: A :: C :: T :: Oo :: A :: Ap :: M :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: T :: Oo :: A :: Ap :: M :: T :: nil) ((Oo :: A :: C :: T :: nil) ++ (Oo :: A :: Ap :: M :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMTmtmp;try rewrite HT2 in HOoACApMTmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: T :: nil) (Oo :: A :: Ap :: M :: T :: nil) (Oo :: A :: T :: nil) 4 3 4 HOoACApMTmtmp HOoATmtmp HOoAApMTMtmp Hincl);apply HT.
}


assert(HOoACTM : rk(Oo :: A :: C :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACTm : rk(Oo :: A :: C :: T ::  nil) >= 1) by (solve_hyps_min HOoACTeq HOoACTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApT *)
(* dans constructLemma(), requis par LCApBpNPT *)
(* dans constructLemma(), requis par LOoCApBpNPT *)
(* dans constructLemma(), requis par LOoBCApBpNPT *)
(* dans la couche 0 *)
Lemma LOoABCApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApBpNPT requis par la preuve de (?)OoABCApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApBpNPT requis par la preuve de (?)OoABCApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpNPT requis par la preuve de (?)OoABCApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPTm2 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPTm3 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPTm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpNPTM : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpNPTm : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApBpNPTeq HOoABCApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpNPT requis par la preuve de (?)OoBCApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpNPT requis par la preuve de (?)OoBCApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpNPT requis par la preuve de (?)OoBCApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNPTm2 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNPTm3 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApBpNPTm4 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApBpNPTeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABCApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApBpNPTmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABCApBpNPTeq HOoABCApBpNPTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpNPTmtmp;try rewrite HT2 in HOoABCApBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApBpNPTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApBpNPTM : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpNPTm : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApBpNPTeq HOoBCApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNPT requis par la preuve de (?)OoCApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNPT requis par la preuve de (?)OoCApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNPT requis par la preuve de (?)OoCApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNPTm2 : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNPTm3 : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoCApBpNPTm4 : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	try assert(HOoBCApBpNPTeq : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBCApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApBpNPTmtmp : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBCApBpNPTeq HOoBCApBpNPTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpNPTmtmp;try rewrite HT2 in HOoBCApBpNPTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoBCApBpNPTmtmp HOoCApNmtmp HOoBCApNMtmp Hincl); apply HT.
}


assert(HOoCApBpNPTM : rk(Oo :: C :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpNPTm : rk(Oo :: C :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoCApBpNPTeq HOoCApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpNPT requis par la preuve de (?)CApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNPT requis par la preuve de (?)CApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNPT requis par la preuve de (?)OoCApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNPT requis par la preuve de (?)OoCApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNPTm2 : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNPTm3 : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpNPT requis par la preuve de (?)CApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpNPT requis par la preuve de (?)CApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpNPT requis par la preuve de (?)OoACApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpNPT requis par la preuve de (?)OoACApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNPTm2 : rk(Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNPTm3 : rk(Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpNPT requis par la preuve de (?)CApBpNPT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: N :: P :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpNPTm2 : rk(C :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpNPTmtmp : rk(Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HOoACApBpNPTeq HOoACApBpNPTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpNPTmtmp;try rewrite HT2 in HOoACApBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: P :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpNPTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpNPTM1. try clear HOoACApBpNPTM2. try clear HOoACApBpNPTM3. try clear HOoACApBpNPTm4. try clear HOoACApBpNPTm3. try clear HOoACApBpNPTm2. try clear HOoACApBpNPTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: P :: T ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpNPTm3 : rk(C :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpNPTmtmp : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HOoCApBpNPTeq HOoCApBpNPTm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNPTmtmp;try rewrite HT2 in HOoCApBpNPTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: P :: T :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpNPTmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HCApBpNPTm4 : rk(C :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	try assert(HOoCApBpNPTeq : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoCApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpNPTmtmp : rk(Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoCApBpNPTeq HOoCApBpNPTm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (C :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNPTmtmp;try rewrite HT2 in HOoCApBpNPTmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: P :: T :: nil) (Ap :: Bp :: N :: nil) 4 3 3 HOoCApBpNPTmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoCApBpNPTM1. try clear HOoCApBpNPTM2. try clear HOoCApBpNPTM3. try clear HOoCApBpNPTm4. try clear HOoCApBpNPTm3. try clear HOoCApBpNPTm2. try clear HOoCApBpNPTm1. 

assert(HCApBpNPTM : rk(C :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpNPTm : rk(C :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HCApBpNPTeq HCApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApT requis par la preuve de (?)CApT pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApT requis par la preuve de (?)CApT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApT requis par la preuve de (?)OoACApT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApT requis par la preuve de (?)OoACApT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTm2 : rk(Oo :: A :: C :: Ap :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTm3 : rk(Oo :: A :: C :: Ap :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApT requis par la preuve de (?)CApT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApTm2 : rk(C :: Ap :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApTmtmp : rk(Oo :: A :: C :: Ap :: T :: nil) >= 3) by (solve_hyps_min HOoACApTeq HOoACApTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApTmtmp;try rewrite HT2 in HOoACApTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApTM1. try clear HOoACApTM2. try clear HOoACApTM3. try clear HOoACApTm4. try clear HOoACApTm3. try clear HOoACApTm2. try clear HOoACApTm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCApTm3 : rk(C :: Ap :: T :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HCApBpNPTeq : rk(C :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LCApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpNPTmtmp : rk(C :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HCApBpNPTeq HCApBpNPTm4).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (C :: Ap :: T :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: N :: P :: T :: nil) (C :: Ap :: T :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: T :: Bp :: N :: P :: T :: nil) ((C :: Ap :: T :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpNPTmtmp;try rewrite HT2 in HCApBpNPTmtmp.
	assert(HT := rule_2 (C :: Ap :: T :: nil) (Bp :: N :: P :: T :: nil) (T :: nil) 4 1 2 HCApBpNPTmtmp HTmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HCApTM : rk(C :: Ap :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApTeq HCApTM3).
assert(HCApTm : rk(C :: Ap :: T ::  nil) >= 1) by (solve_hyps_min HCApTeq HCApTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApMT *)
(* dans la couche 0 *)
Lemma LCApMSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMSpT requis par la preuve de (?)CApMSpT pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMSpT requis par la preuve de (?)CApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMSpT requis par la preuve de (?)CApMSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMSpT requis par la preuve de (?)OoACApMSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMSpT requis par la preuve de (?)OoACApMSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpTm2 : rk(Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpTm3 : rk(Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMSpT requis par la preuve de (?)CApMSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMSpTm2 : rk(C :: Ap :: M :: Sp :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMSpTmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) >= 3) by (solve_hyps_min HOoACApMSpTeq HOoACApMSpTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpTmtmp;try rewrite HT2 in HOoACApMSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMSpTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMSpTM1. try clear HOoACApMSpTM2. try clear HOoACApMSpTM3. try clear HOoACApMSpTm4. try clear HOoACApMSpTm3. try clear HOoACApMSpTm2. try clear HOoACApMSpTm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMSpTm3 : rk(C :: Ap :: M :: Sp :: T :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: T :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCApMSpTM3 : rk(C :: Ap :: M :: Sp :: T :: nil) <= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Ap :: M :: Sp :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: T :: nil) (Ap :: M :: Sp :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: C :: Sp :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Sp :: nil) (C :: Sp :: T :: nil) (Sp :: nil) 2 2 1 HApMSpMtmp HCSpTMtmp HSpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCApMSpTM : rk(C :: Ap :: M :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMSpTm : rk(C :: Ap :: M :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCApMSpTeq HCApMSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMT requis par la preuve de (?)CApMT pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMT requis par la preuve de (?)CApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMT requis par la preuve de (?)CApMT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMT requis par la preuve de (?)OoACApMT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm2 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMTm3 : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMT requis par la preuve de (?)CApMT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: T ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMTm2 : rk(C :: Ap :: M :: T :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMTmtmp : rk(Oo :: A :: C :: Ap :: M :: T :: nil) >= 3) by (solve_hyps_min HOoACApMTeq HOoACApMTm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: T :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: T :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMTmtmp;try rewrite HT2 in HOoACApMTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: T :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMTmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMTM1. try clear HOoACApMTM2. try clear HOoACApMTM3. try clear HOoACApMTm4. try clear HOoACApMTm3. try clear HOoACApMTm2. try clear HOoACApMTm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMTm3 : rk(C :: Ap :: M :: T :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: T :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMTM3 : rk(C :: Ap :: M :: T :: nil) <= 3).
{
	try assert(HCApMSpTeq : rk(C :: Ap :: M :: Sp :: T :: nil) = 3) by (apply LCApMSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpTMtmp : rk(C :: Ap :: M :: Sp :: T :: nil) <= 3) by (solve_hyps_max HCApMSpTeq HCApMSpTM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: T :: nil) (C :: Ap :: M :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: M :: T :: nil) (C :: Ap :: M :: Sp :: T :: nil) 3 3 HCApMSpTMtmp Hcomp Hincl);apply HT.
}


assert(HCApMTM : rk(C :: Ap :: M :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMTm : rk(C :: Ap :: M :: T ::  nil) >= 1) by (solve_hyps_min HCApMTeq HCApMTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LNT *)
(* dans constructLemma(), requis par LCNSpT *)
(* dans constructLemma(), requis par LOoCApNSpT *)
(* dans constructLemma(), requis par LOoBCApNSpT *)
(* dans la couche 0 *)
Lemma LOoABCApNSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApNSpT requis par la preuve de (?)OoABCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm2 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm3 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApNSpTm4 : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApNSpTM : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApNSpTm : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApNSpTeq HOoABCApNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApNSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApNSpT requis par la preuve de (?)OoBCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNSpTm2 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApNSpTm3 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApNSpTm4 : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApNSpTeq : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) = 4) by (apply LOoABCApNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApNSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApNSpTeq HOoABCApNSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApNSpTmtmp;try rewrite HT2 in HOoABCApNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApNSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApNSpTM : rk(Oo :: B :: C :: Ap :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApNSpTm : rk(Oo :: B :: C :: Ap :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApNSpTeq HOoBCApNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApNSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApNSpT requis par la preuve de (?)OoCApNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApNSpT requis par la preuve de (?)OoCApNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApNSpT requis par la preuve de (?)OoCApNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNSpTm2 : rk(Oo :: C :: Ap :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: N :: Sp :: T :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApNSpTm3 : rk(Oo :: C :: Ap :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: N :: Sp :: T :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: B :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoCApNSpTm4 : rk(Oo :: C :: Ap :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoBCApNeq : rk(Oo :: B :: C :: Ap :: N :: nil) = 4) by (apply LOoBCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNMtmp : rk(Oo :: B :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoBCApNeq HOoBCApNM4).
	try assert(HOoBCApNSpTeq : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) = 4) by (apply LOoBCApNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCApNSpTmtmp : rk(Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoBCApNSpTeq HOoBCApNSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: B :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: B :: C :: Ap :: N :: Oo :: C :: Ap :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Ap :: N :: Oo :: C :: Ap :: N :: Sp :: T :: nil) ((Oo :: B :: C :: Ap :: N :: nil) ++ (Oo :: C :: Ap :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApNSpTmtmp;try rewrite HT2 in HOoBCApNSpTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoBCApNSpTmtmp HOoCApNmtmp HOoBCApNMtmp Hincl); apply HT.
}


assert(HOoCApNSpTM : rk(Oo :: C :: Ap :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApNSpTm : rk(Oo :: C :: Ap :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoCApNSpTeq HOoCApNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCNSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: N :: Sp :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CNSpT requis par la preuve de (?)CNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CNSpT requis par la preuve de (?)CNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CNSpT requis par la preuve de (?)CNSpT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCNSpTM3 : rk(C :: N :: Sp :: T :: nil) <= 3).
{
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (N :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: N :: Sp :: T :: nil) (N :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: C :: Sp :: T :: nil) ((N :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (N :: nil) (C :: Sp :: T :: nil) (nil) 1 2 0 HNMtmp HCSpTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCNSpTm2 : rk(C :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HCNeq : rk(C :: N :: nil) = 2) by (apply LCN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCNmtmp : rk(C :: N :: nil) >= 2) by (solve_hyps_min HCNeq HCNm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (C :: N :: nil) (C :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: N :: nil) (C :: N :: Sp :: T :: nil) 2 2 HCNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : C :: N :: Sp ::  de rang :  3 et 3 	 A : Oo :: C :: Ap :: N :: Sp ::   de rang : 4 et 4 *)
assert(HCNSpTm3 : rk(C :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoCApNSpeq : rk(Oo :: C :: Ap :: N :: Sp :: nil) = 4) by (apply LOoCApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNSpMtmp : rk(Oo :: C :: Ap :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoCApNSpeq HOoCApNSpM4).
	try assert(HOoCApNSpTeq : rk(Oo :: C :: Ap :: N :: Sp :: T :: nil) = 4) by (apply LOoCApNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNSpTmtmp : rk(Oo :: C :: Ap :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoCApNSpTeq HOoCApNSpTm4).
	try assert(HCNSpeq : rk(C :: N :: Sp :: nil) = 3) by (apply LCNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCNSpmtmp : rk(C :: N :: Sp :: nil) >= 3) by (solve_hyps_min HCNSpeq HCNSpm3).
	assert(Hincl : incl (C :: N :: Sp :: nil) (list_inter (Oo :: C :: Ap :: N :: Sp :: nil) (C :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: N :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: Sp :: C :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Ap :: N :: Sp :: C :: N :: Sp :: T :: nil) ((Oo :: C :: Ap :: N :: Sp :: nil) ++ (C :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApNSpTmtmp;try rewrite HT2 in HOoCApNSpTmtmp.
	assert(HT := rule_4 (Oo :: C :: Ap :: N :: Sp :: nil) (C :: N :: Sp :: T :: nil) (C :: N :: Sp :: nil) 4 3 4 HOoCApNSpTmtmp HCNSpmtmp HOoCApNSpMtmp Hincl); apply HT.
}


assert(HCNSpTM : rk(C :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCNSpTm : rk(C :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HCNSpTeq HCNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NT requis par la preuve de (?)NT pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HNTm2 : rk(N :: T :: nil) >= 2).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HCNSpTeq : rk(C :: N :: Sp :: T :: nil) = 3) by (apply LCNSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCNSpTmtmp : rk(C :: N :: Sp :: T :: nil) >= 3) by (solve_hyps_min HCNSpTeq HCNSpTm3).
	try assert(HTeq : rk(T :: nil) = 1) by (apply LT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HTmtmp : rk(T :: nil) >= 1) by (solve_hyps_min HTeq HTm1).
	assert(Hincl : incl (T :: nil) (list_inter (N :: T :: nil) (C :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: N :: Sp :: T :: nil) (N :: T :: C :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (N :: T :: C :: Sp :: T :: nil) ((N :: T :: nil) ++ (C :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCNSpTmtmp;try rewrite HT2 in HCNSpTmtmp.
	assert(HT := rule_2 (N :: T :: nil) (C :: Sp :: T :: nil) (T :: nil) 3 1 2 HCNSpTmtmp HTmtmp HCSpTMtmp Hincl);apply HT.
}


assert(HNTM : rk(N :: T ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNTeq HNTM2).
assert(HNTm : rk(N :: T ::  nil) >= 1) by (solve_hyps_min HNTeq HNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpNT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNT requis par la preuve de (?)BpNT pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)BpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoABCBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoABCBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoABCBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNTm2 : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNTm3 : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNTm4 : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNmtmp : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABBpNeq HOoABBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil) 4 4 HOoABBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNTm2 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNTm3 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Bp :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Bp :: N ::   de rang : 4 et 4 *)
assert(HOoBCBpNTm4 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoACBpNeq : rk(Oo :: A :: C :: Bp :: N :: nil) = 4) by (apply LOoACBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNMtmp : rk(Oo :: A :: C :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoACBpNeq HOoACBpNM4).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoCBpNeq : rk(Oo :: C :: Bp :: N :: nil) = 4) by (apply LOoCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCBpNmtmp : rk(Oo :: C :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoCBpNeq HOoCBpNm4).
	assert(Hincl : incl (Oo :: C :: Bp :: N :: nil) (list_inter (Oo :: A :: C :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: Bp :: N :: Oo :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: N :: Oo :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: C :: Bp :: N :: nil) ++ (Oo :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: C :: Bp :: N :: nil) 4 4 4 HOoABCBpNTmtmp HOoCBpNmtmp HOoACBpNMtmp Hincl); apply HT.
}
try clear HOoABCBpNTM1. try clear HOoABCBpNTM2. try clear HOoABCBpNTM3. try clear HOoABCBpNTm4. try clear HOoABCBpNTm3. try clear HOoABCBpNTm2. try clear HOoABCBpNTm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpNT requis par la preuve de (?)BpNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: B :: C :: Bp :: N ::   de rang : 4 et 4 *)
assert(HBpNTm2 : rk(Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBCBpNeq : rk(Oo :: B :: C :: Bp :: N :: nil) = 4) by (apply LOoBCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBCBpNMtmp : rk(Oo :: B :: C :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoBCBpNeq HOoBCBpNM4).
	assert(HOoBCBpNTmtmp : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: B :: C :: Bp :: N :: nil) (Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: B :: C :: Bp :: N :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: N :: Bp :: N :: T :: nil) ((Oo :: B :: C :: Bp :: N :: nil) ++ (Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNTmtmp;try rewrite HT2 in HOoBCBpNTmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: N :: nil) (Bp :: N :: T :: nil) (Bp :: N :: nil) 4 2 4 HOoBCBpNTmtmp HBpNmtmp HOoBCBpNMtmp Hincl); apply HT.
}
try clear HOoBCBpNTM1. try clear HOoBCBpNTM2. try clear HOoBCBpNTM3. try clear HOoBCBpNTm4. try clear HOoBCBpNTm3. try clear HOoBCBpNTm2. try clear HOoBCBpNTm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpNTM2 : rk(Bp :: N :: T :: nil) <= 2).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: N :: T :: nil) (Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Bp :: N :: T :: nil) (Bp :: N :: P :: T :: nil) 2 2 HBpNPTMtmp Hcomp Hincl);apply HT.
}


assert(HBpNTM : rk(Bp :: N :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpNTeq HBpNTM3).
assert(HBpNTm : rk(Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HBpNTeq HBpNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCBpNT *)
(* dans la couche 0 *)
Lemma LOoABCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoABCBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoABCBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpNT requis par la preuve de (?)OoABCBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNTm2 : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNTm3 : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNTm4 : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNmtmp : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABBpNeq HOoABBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: T :: nil) 4 4 HOoABBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpNTM : rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNTm : rk(Oo :: A :: B :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBpNT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Bp :: N :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNT requis par la preuve de (?)OoBCBpNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNTm2 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNTm3 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Bp :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Bp :: N ::   de rang : 4 et 4 *)
assert(HOoBCBpNTm4 : rk(Oo :: B :: C :: Bp :: N :: T :: nil) >= 4).
{
	try assert(HOoACBpNeq : rk(Oo :: A :: C :: Bp :: N :: nil) = 4) by (apply LOoACBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpNMtmp : rk(Oo :: A :: C :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoACBpNeq HOoACBpNM4).
	try assert(HOoABCBpNTeq : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) = 4) by (apply LOoABCBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCBpNTmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: T :: nil) >= 4) by (solve_hyps_min HOoABCBpNTeq HOoABCBpNTm4).
	try assert(HOoCBpNeq : rk(Oo :: C :: Bp :: N :: nil) = 4) by (apply LOoCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCBpNmtmp : rk(Oo :: C :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoCBpNeq HOoCBpNm4).
	assert(Hincl : incl (Oo :: C :: Bp :: N :: nil) (list_inter (Oo :: A :: C :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: T :: nil) (Oo :: A :: C :: Bp :: N :: Oo :: B :: C :: Bp :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: N :: Oo :: B :: C :: Bp :: N :: T :: nil) ((Oo :: A :: C :: Bp :: N :: nil) ++ (Oo :: B :: C :: Bp :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNTmtmp;try rewrite HT2 in HOoABCBpNTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: T :: nil) (Oo :: C :: Bp :: N :: nil) 4 4 4 HOoABCBpNTmtmp HOoCBpNmtmp HOoACBpNMtmp Hincl); apply HT.
}


assert(HOoBCBpNTM : rk(Oo :: B :: C :: Bp :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpNTm : rk(Oo :: B :: C :: Bp :: N :: T ::  nil) >= 1) by (solve_hyps_min HOoBCBpNTeq HOoBCBpNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMNT *)
(* dans la couche 0 *)
Lemma LBpMNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: M :: N :: P :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpMNPT requis par la preuve de (?)BpMNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)BpMNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)OoABBpMNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)OoABBpMNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)OoABBpMNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTm2 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTm3 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTm4 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpMNPT requis par la preuve de (?)BpMNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpMNPT requis par la preuve de (?)BpMNPT pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpMNPTM3 : rk(Bp :: M :: N :: P :: T :: nil) <= 3).
{
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (M :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: M :: N :: P :: T :: nil) (M :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: Bp :: N :: P :: T :: nil) ((M :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (M :: nil) (Bp :: N :: P :: T :: nil) (nil) 1 2 0 HMMtmp HBpNPTMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: M :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Bp :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: M ::   de rang : 4 et 4 *)
assert(HBpMNPTm2 : rk(Bp :: M :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoABBpMeq : rk(Oo :: A :: B :: Bp :: M :: nil) = 4) by (apply LOoABBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMMtmp : rk(Oo :: A :: B :: Bp :: M :: nil) <= 4) by (solve_hyps_max HOoABBpMeq HOoABBpMM4).
	assert(HOoABBpMNPTmtmp : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABBpMNPTeq HOoABBpMNPTm4).
	try assert(HBpMeq : rk(Bp :: M :: nil) = 2) by (apply LBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMmtmp : rk(Bp :: M :: nil) >= 2) by (solve_hyps_min HBpMeq HBpMm2).
	assert(Hincl : incl (Bp :: M :: nil) (list_inter (Oo :: A :: B :: Bp :: M :: nil) (Bp :: M :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) (Oo :: A :: B :: Bp :: M :: Bp :: M :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: M :: Bp :: M :: N :: P :: T :: nil) ((Oo :: A :: B :: Bp :: M :: nil) ++ (Bp :: M :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMNPTmtmp;try rewrite HT2 in HOoABBpMNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: M :: nil) (Bp :: M :: N :: P :: T :: nil) (Bp :: M :: nil) 4 2 4 HOoABBpMNPTmtmp HBpMmtmp HOoABBpMMtmp Hincl); apply HT.
}
try clear HBpMM1. try clear HBpMM2. try clear HBpMM3. try clear HBpMm4. try clear HBpMm3. try clear HBpMm2. try clear HBpMm1. try clear HOoABBpMNPTM1. try clear HOoABBpMNPTM2. try clear HOoABBpMNPTM3. try clear HOoABBpMNPTm4. try clear HOoABBpMNPTm3. try clear HOoABBpMNPTm2. try clear HOoABBpMNPTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HBpMNPTm3 : rk(Bp :: M :: N :: P :: T :: nil) >= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HApBpMNPSpTeq : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) = 4) by (apply LApBpMNPSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNPSpTmtmp : rk(Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNPSpTeq HApBpMNPSpTm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: Sp :: nil) (Bp :: M :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Sp :: T :: nil) (Ap :: M :: Sp :: Bp :: M :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: Bp :: M :: N :: P :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (Bp :: M :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPSpTmtmp;try rewrite HT2 in HApBpMNPSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (Bp :: M :: N :: P :: T :: nil) (M :: nil) 4 1 2 HApBpMNPSpTmtmp HMmtmp HApMSpMtmp Hincl); apply HT.
}


assert(HBpMNPTM : rk(Bp :: M :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpMNPTm : rk(Bp :: M :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HBpMNPTeq HBpMNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LMNT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour MNT requis par la preuve de (?)MNT pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApMNSpT requis par la preuve de (?)MNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApMNQSpT requis par la preuve de (?)ApMNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMNQSpT requis par la preuve de (?)ApMNQSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)ApMNQSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)OoABApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)OoABApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)OoABApMNQSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpTm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpTm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpTm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMNQSpT requis par la preuve de (?)ApMNQSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMNQSpTm2 : rk(Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMNQSpTmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABApMNQSpTeq HOoABApMNQSpTm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Q :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Q :: Sp :: T :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: N :: Q :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNQSpTmtmp;try rewrite HT2 in HOoABApMNQSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Q :: Sp :: T :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMNQSpTmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMNQSpTM1. try clear HOoABApMNQSpTM2. try clear HOoABApMNQSpTM3. try clear HOoABApMNQSpTm4. try clear HOoABApMNQSpTm3. try clear HOoABApMNQSpTm2. try clear HOoABApMNQSpTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  de rang :  4 et 4 	 AiB : N ::  de rang :  1 et 1 	 A : Bp :: N :: P ::   de rang : 2 et 2 *)
assert(HApMNQSpTm3 : rk(Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HApBpMNPQSpTeq : rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T :: nil) = 4) by (apply LApBpMNPQSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpMNPQSpTmtmp : rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T :: nil) >= 4) by (solve_hyps_min HApBpMNPQSpTeq HApBpMNPQSpTm4).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNmtmp : rk(N :: nil) >= 1) by (solve_hyps_min HNeq HNm1).
	assert(Hincl : incl (N :: nil) (list_inter (Bp :: N :: P :: nil) (Ap :: M :: N :: Q :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: N :: P :: Q :: Sp :: T :: nil) (Bp :: N :: P :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: P :: Ap :: M :: N :: Q :: Sp :: T :: nil) ((Bp :: N :: P :: nil) ++ (Ap :: M :: N :: Q :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMNPQSpTmtmp;try rewrite HT2 in HApBpMNPQSpTmtmp.
	assert(HT := rule_4 (Bp :: N :: P :: nil) (Ap :: M :: N :: Q :: Sp :: T :: nil) (N :: nil) 4 1 2 HApBpMNPQSpTmtmp HNmtmp HBpNPMtmp Hincl); apply HT.
}
try clear HApBpMNPQSpTM1. try clear HApBpMNPQSpTM2. try clear HApBpMNPQSpTM3. try clear HApBpMNPQSpTm4. try clear HApBpMNPQSpTm3. try clear HApBpMNPQSpTm2. try clear HApBpMNPQSpTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMNSpT requis par la preuve de (?)ApMNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)ApMNSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)OoABApMNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)OoABApMNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)OoABApMNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpTm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpTm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpTm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMNSpT requis par la preuve de (?)ApMNSpT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: N :: Sp :: T ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMNSpTm2 : rk(Ap :: M :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMNSpTmtmp : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABApMNSpTeq HOoABApMNSpTm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: N :: Sp :: T :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMNSpTmtmp;try rewrite HT2 in HOoABApMNSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: N :: Sp :: T :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMNSpTmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMNSpTM1. try clear HOoABApMNSpTM2. try clear HOoABApMNSpTM3. try clear HOoABApMNSpTm4. try clear HOoABApMNSpTm3. try clear HOoABApMNSpTm2. try clear HOoABApMNSpTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Ap :: M :: N :: Q :: Sp :: T ::  de rang :  3 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Ap :: M :: Q ::   de rang : 2 et 2 *)
assert(HApMNSpTm3 : rk(Ap :: M :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HApMQeq : rk(Ap :: M :: Q :: nil) = 2) by (apply LApMQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQMtmp : rk(Ap :: M :: Q :: nil) <= 2) by (solve_hyps_max HApMQeq HApMQM2).
	assert(HApMNQSpTmtmp : rk(Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3) by (solve_hyps_min HApMNQSpTeq HApMNQSpTm3).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Ap :: M :: Q :: nil) (Ap :: M :: N :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: N :: Q :: Sp :: T :: nil) (Ap :: M :: Q :: Ap :: M :: N :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: Ap :: M :: N :: Sp :: T :: nil) ((Ap :: M :: Q :: nil) ++ (Ap :: M :: N :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApMNQSpTmtmp;try rewrite HT2 in HApMNQSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Q :: nil) (Ap :: M :: N :: Sp :: T :: nil) (Ap :: M :: nil) 3 2 2 HApMNQSpTmtmp HApMmtmp HApMQMtmp Hincl); apply HT.
}
try clear HApMNQSpTM1. try clear HApMNQSpTM2. try clear HApMNQSpTM3. try clear HApMNQSpTm4. try clear HApMNQSpTm3. try clear HApMNQSpTm2. try clear HApMNQSpTm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour MNT requis par la preuve de (?)MNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Ap :: M :: N :: Sp :: T ::  de rang :  3 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : Ap :: M :: Sp ::   de rang : 2 et 2 *)
assert(HMNTm2 : rk(M :: N :: T :: nil) >= 2).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	assert(HApMNSpTmtmp : rk(Ap :: M :: N :: Sp :: T :: nil) >= 3) by (solve_hyps_min HApMNSpTeq HApMNSpTm3).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: Sp :: nil) (M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: N :: Sp :: T :: nil) (Ap :: M :: Sp :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: M :: N :: T :: nil) ((Ap :: M :: Sp :: nil) ++ (M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApMNSpTmtmp;try rewrite HT2 in HApMNSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Sp :: nil) (M :: N :: T :: nil) (M :: nil) 3 1 2 HApMNSpTmtmp HMmtmp HApMSpMtmp Hincl); apply HT.
}
try clear HApMNSpTM1. try clear HApMNSpTM2. try clear HApMNSpTM3. try clear HApMNSpTm4. try clear HApMNSpTm3. try clear HApMNSpTm2. try clear HApMNSpTm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HMNTm3 : rk(M :: N :: T :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HBpMNPTeq : rk(Bp :: M :: N :: P :: T :: nil) = 3) by (apply LBpMNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpMNPTmtmp : rk(Bp :: M :: N :: P :: T :: nil) >= 3) by (solve_hyps_min HBpMNPTeq HBpMNPTm3).
	try assert(HNTeq : rk(N :: T :: nil) = 2) by (apply LNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNTmtmp : rk(N :: T :: nil) >= 2) by (solve_hyps_min HNTeq HNTm2).
	assert(Hincl : incl (N :: T :: nil) (list_inter (M :: N :: T :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: M :: N :: P :: T :: nil) (M :: N :: T :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: N :: T :: Bp :: N :: P :: T :: nil) ((M :: N :: T :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpMNPTmtmp;try rewrite HT2 in HBpMNPTmtmp.
	assert(HT := rule_2 (M :: N :: T :: nil) (Bp :: N :: P :: T :: nil) (N :: T :: nil) 3 2 2 HBpMNPTmtmp HNTmtmp HBpNPTMtmp Hincl);apply HT.
}
try clear HNTM1. try clear HNTM2. try clear HNTM3. try clear HNTm4. try clear HNTm3. try clear HNTm2. try clear HNTm1. 

assert(HMNTM : rk(M :: N :: T ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HMNTeq HMNTM3).
assert(HMNTm : rk(M :: N :: T ::  nil) >= 1) by (solve_hyps_min HMNTeq HMNTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAMNT *)
(* dans constructLemma(), requis par LABpMNPTU *)
(* dans la couche 0 *)
Lemma LABpMNPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp :: M :: N :: P :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpMNPU requis par la preuve de (?)ABpMNPU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpMNPU requis par la preuve de (?)ABpMNPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNPU requis par la preuve de (?)ABpMNPU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNPU requis par la preuve de (?)OoABBpMNPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNPU requis par la preuve de (?)OoABBpMNPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPUm2 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPUm3 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpMNPU requis par la preuve de (?)ABpMNPU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: M :: N :: P :: U ::  de rang :  3 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABpMNPUm2 : rk(A :: Bp :: M :: N :: P :: U :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpMNPUmtmp : rk(Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil) >= 3) by (solve_hyps_min HOoABBpMNPUeq HOoABBpMNPUm3).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: Bp :: M :: N :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: N :: P :: U :: nil) (Oo :: A :: B :: Bp :: A :: Bp :: M :: N :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: Bp :: M :: N :: P :: U :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: Bp :: M :: N :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMNPUmtmp;try rewrite HT2 in HOoABBpMNPUmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: Bp :: M :: N :: P :: U :: nil) (A :: Bp :: nil) 3 2 3 HOoABBpMNPUmtmp HABpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpMNPUM1. try clear HOoABBpMNPUM2. try clear HOoABBpMNPUM3. try clear HOoABBpMNPUm4. try clear HOoABBpMNPUm3. try clear HOoABBpMNPUm2. try clear HOoABBpMNPUm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpMNPUm3 : rk(A :: Bp :: M :: N :: P :: U :: nil) >= 3).
{
	try assert(HABpMeq : rk(A :: Bp :: M :: nil) = 3) by (apply LABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpMmtmp : rk(A :: Bp :: M :: nil) >= 3) by (solve_hyps_min HABpMeq HABpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: M :: nil) (A :: Bp :: M :: N :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: M :: nil) (A :: Bp :: M :: N :: P :: U :: nil) 3 3 HABpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABpMNPUM3 : rk(A :: Bp :: M :: N :: P :: U :: nil) <= 3).
{
	try assert(HBpNPeq : rk(Bp :: N :: P :: nil) = 2) by (apply LBpNP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPMtmp : rk(Bp :: N :: P :: nil) <= 2) by (solve_hyps_max HBpNPeq HBpNPM2).
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (Bp :: N :: P :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: M :: N :: P :: U :: nil) (Bp :: N :: P :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: P :: A :: M :: P :: U :: nil) ((Bp :: N :: P :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: P :: nil) (A :: M :: P :: U :: nil) (P :: nil) 2 2 1 HBpNPMtmp HAMPUMtmp HPmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HPM1. try clear HPM2. try clear HPM3. try clear HPm4. try clear HPm3. try clear HPm2. try clear HPm1. 

assert(HABpMNPUM : rk(A :: Bp :: M :: N :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpMNPUm : rk(A :: Bp :: M :: N :: P :: U ::  nil) >= 1) by (solve_hyps_min HABpMNPUeq HABpMNPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpMNPTU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Bp :: M :: N :: P :: T :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpMNPTU requis par la preuve de (?)ABpMNPTU pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpMNPTU requis par la preuve de (?)ABpMNPTU pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNPTU requis par la preuve de (?)ABpMNPTU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNPTU requis par la preuve de (?)OoABBpMNPTU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNPTU requis par la preuve de (?)OoABBpMNPTU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTUm2 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTUm3 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpMNPTU requis par la preuve de (?)ABpMNPTU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: M :: N :: P :: T :: U ::  de rang :  3 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HABpMNPTUm2 : rk(A :: Bp :: M :: N :: P :: T :: U :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpMNPTUmtmp : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil) >= 3) by (solve_hyps_min HOoABBpMNPTUeq HOoABBpMNPTUm3).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (A :: Bp :: M :: N :: P :: T :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: M :: N :: P :: T :: U :: nil) (Oo :: A :: B :: Bp :: A :: Bp :: M :: N :: P :: T :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: A :: Bp :: M :: N :: P :: T :: U :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (A :: Bp :: M :: N :: P :: T :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpMNPTUmtmp;try rewrite HT2 in HOoABBpMNPTUmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (A :: Bp :: M :: N :: P :: T :: U :: nil) (A :: Bp :: nil) 3 2 3 HOoABBpMNPTUmtmp HABpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpMNPTUM1. try clear HOoABBpMNPTUM2. try clear HOoABBpMNPTUM3. try clear HOoABBpMNPTUm4. try clear HOoABBpMNPTUm3. try clear HOoABBpMNPTUm2. try clear HOoABBpMNPTUm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpMNPTUm3 : rk(A :: Bp :: M :: N :: P :: T :: U :: nil) >= 3).
{
	try assert(HABpMeq : rk(A :: Bp :: M :: nil) = 3) by (apply LABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpMmtmp : rk(A :: Bp :: M :: nil) >= 3) by (solve_hyps_min HABpMeq HABpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: M :: nil) (A :: Bp :: M :: N :: P :: T :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: M :: nil) (A :: Bp :: M :: N :: P :: T :: U :: nil) 3 3 HABpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABpMNPTUM3 : rk(A :: Bp :: M :: N :: P :: T :: U :: nil) <= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HABpMNPUeq : rk(A :: Bp :: M :: N :: P :: U :: nil) = 3) by (apply LABpMNPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpMNPUMtmp : rk(A :: Bp :: M :: N :: P :: U :: nil) <= 3) by (solve_hyps_max HABpMNPUeq HABpMNPUM3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Bp :: N :: T :: nil) (A :: Bp :: M :: N :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: M :: N :: P :: T :: U :: nil) (Bp :: N :: T :: A :: Bp :: M :: N :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: A :: Bp :: M :: N :: P :: U :: nil) ((Bp :: N :: T :: nil) ++ (A :: Bp :: M :: N :: P :: U :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: T :: nil) (A :: Bp :: M :: N :: P :: U :: nil) (Bp :: N :: nil) 2 3 2 HBpNTMtmp HABpMNPUMtmp HBpNmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HABpMNPTUM : rk(A :: Bp :: M :: N :: P :: T :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpMNPTUm : rk(A :: Bp :: M :: N :: P :: T :: U ::  nil) >= 1) by (solve_hyps_min HABpMNPTUeq HABpMNPTUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAMNT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M :: N :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AMNT requis par la preuve de (?)AMNT pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)OoAApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)OoAApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)OoAApMNQSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpTm2 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpTm3 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpTm4 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMNQSpTm2 : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMNQSpTm3 : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HAApMeq : rk(A :: Ap :: M :: nil) = 3) by (apply LAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMmtmp : rk(A :: Ap :: M :: nil) >= 3) by (solve_hyps_min HAApMeq HAApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: M :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: M :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 3 3 HAApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: N :: Q :: Sp :: T ::  de rang :  4 et 4 	 AiB : A :: Ap :: N :: Sp ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: N :: Sp ::   de rang : 4 et 4 *)
assert(HAApMNQSpTm4 : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApNSpeq : rk(Oo :: A :: Ap :: N :: Sp :: nil) = 4) by (apply LOoAApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApNSpMtmp : rk(Oo :: A :: Ap :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApNSpeq HOoAApNSpM4).
	assert(HOoAApMNQSpTmtmp : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoAApMNQSpTeq HOoAApMNQSpTm4).
	try assert(HAApNSpeq : rk(A :: Ap :: N :: Sp :: nil) = 4) by (apply LAApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApNSpmtmp : rk(A :: Ap :: N :: Sp :: nil) >= 4) by (solve_hyps_min HAApNSpeq HAApNSpm4).
	assert(Hincl : incl (A :: Ap :: N :: Sp :: nil) (list_inter (Oo :: A :: Ap :: N :: Sp :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) (Oo :: A :: Ap :: N :: Sp :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: N :: Sp :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) ((Oo :: A :: Ap :: N :: Sp :: nil) ++ (A :: Ap :: M :: N :: Q :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMNQSpTmtmp;try rewrite HT2 in HOoAApMNQSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: N :: Sp :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) (A :: Ap :: N :: Sp :: nil) 4 4 4 HOoAApMNQSpTmtmp HAApNSpmtmp HOoAApNSpMtmp Hincl); apply HT.
}
try clear HOoAApMNQSpTM1. try clear HOoAApMNQSpTM2. try clear HOoAApMNQSpTM3. try clear HOoAApMNQSpTm4. try clear HOoAApMNQSpTm3. try clear HOoAApMNQSpTm2. try clear HOoAApMNQSpTm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AMNT requis par la preuve de (?)AMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABMNT requis par la preuve de (?)AMNT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMNT requis par la preuve de (?)OoABMNT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMNT requis par la preuve de (?)OoABMNT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMNTm2 : rk(Oo :: A :: B :: M :: N :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: N :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMNTm3 : rk(Oo :: A :: B :: M :: N :: T :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: N :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: N :: T :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AMNT requis par la preuve de (?)AMNT pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: M :: N :: T ::  de rang :  3 et 4 	 AiB : A :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HAMNTm2 : rk(A :: M :: N :: T :: nil) >= 2).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	assert(HOoABMNTmtmp : rk(Oo :: A :: B :: M :: N :: T :: nil) >= 3) by (solve_hyps_min HOoABMNTeq HOoABMNTm3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: N :: T :: nil) (Oo :: A :: B :: M :: A :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: M :: N :: T :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABMNTmtmp;try rewrite HT2 in HOoABMNTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: M :: N :: T :: nil) (A :: M :: nil) 3 2 3 HOoABMNTmtmp HAMmtmp HOoABMMtmp Hincl); apply HT.
}
try clear HOoABMNTM1. try clear HOoABMNTM2. try clear HOoABMNTM3. try clear HOoABMNTm4. try clear HOoABMNTm3. try clear HOoABMNTm2. try clear HOoABMNTm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: M :: N :: Q :: Sp :: T ::  de rang :  4 et 4 	 AiB : M ::  de rang :  1 et 1 	 A : Ap :: M :: Q :: Sp ::   de rang : 2 et 2 *)
assert(HAMNTm3 : rk(A :: M :: N :: T :: nil) >= 3).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(HAApMNQSpTmtmp : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4) by (solve_hyps_min HAApMNQSpTeq HAApMNQSpTm4).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMmtmp : rk(M :: nil) >= 1) by (solve_hyps_min HMeq HMm1).
	assert(Hincl : incl (M :: nil) (list_inter (Ap :: M :: Q :: Sp :: nil) (A :: M :: N :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) (Ap :: M :: Q :: Sp :: A :: M :: N :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: Sp :: A :: M :: N :: T :: nil) ((Ap :: M :: Q :: Sp :: nil) ++ (A :: M :: N :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApMNQSpTmtmp;try rewrite HT2 in HAApMNQSpTmtmp.
	assert(HT := rule_4 (Ap :: M :: Q :: Sp :: nil) (A :: M :: N :: T :: nil) (M :: nil) 4 1 2 HAApMNQSpTmtmp HMmtmp HApMQSpMtmp Hincl); apply HT.
}
try clear HAApMNQSpTM1. try clear HAApMNQSpTM2. try clear HAApMNQSpTM3. try clear HAApMNQSpTm4. try clear HAApMNQSpTm3. try clear HAApMNQSpTm2. try clear HAApMNQSpTm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAMNTM3 : rk(A :: M :: N :: T :: nil) <= 3).
{
	try assert(HABpMNPTUeq : rk(A :: Bp :: M :: N :: P :: T :: U :: nil) = 3) by (apply LABpMNPTU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABpMNPTUMtmp : rk(A :: Bp :: M :: N :: P :: T :: U :: nil) <= 3) by (solve_hyps_max HABpMNPTUeq HABpMNPTUM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: M :: N :: T :: nil) (A :: Bp :: M :: N :: P :: T :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: M :: N :: T :: nil) (A :: Bp :: M :: N :: P :: T :: U :: nil) 3 3 HABpMNPTUMtmp Hcomp Hincl);apply HT.
}


assert(HAMNTM : rk(A :: M :: N :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAMNTm : rk(A :: M :: N :: T ::  nil) >= 1) by (solve_hyps_min HAMNTeq HAMNTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpMNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: M :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)OoABBpMNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)OoABBpMNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpMNPT requis par la preuve de (?)OoABBpMNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTm2 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTm3 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpMNPTm4 : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABpMeq : rk(Oo :: A :: Bp :: M :: nil) = 4) by (apply LOoABpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpMmtmp : rk(Oo :: A :: Bp :: M :: nil) >= 4) by (solve_hyps_min HOoABpMeq HOoABpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: M :: nil) (Oo :: A :: B :: Bp :: M :: N :: P :: T :: nil) 4 4 HOoABpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpMNPTM : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpMNPTm : rk(Oo :: A :: B :: Bp :: M :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoABBpMNPTeq HOoABBpMNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMNSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)OoABApMNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)OoABApMNSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNSpT requis par la preuve de (?)OoABApMNSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpTm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpTm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNSpTm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMNSpTM : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMNSpTm : rk(Oo :: A :: B :: Ap :: M :: N :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABApMNSpTeq HOoABApMNSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpNPSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)OoABBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)OoABBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNPSpT requis par la preuve de (?)OoABBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPSpTm2 : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPSpTm3 : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNPSpTm4 : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: P :: Sp :: T :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpNPSpTM : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNPSpTm : rk(Oo :: A :: B :: Bp :: N :: P :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABBpNPSpTeq HOoABBpNPSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpNPSpT *)
(* dans la couche 0 *)
Lemma LOoABCApBpNPSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoABCApBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoABCApBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpNPSpT requis par la preuve de (?)OoABCApBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPSpTm2 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPSpTm3 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpNPSpTm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HOoABApNeq : rk(Oo :: A :: B :: Ap :: N :: nil) = 4) by (apply LOoABApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApNmtmp : rk(Oo :: A :: B :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoABApNeq HOoABApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: N :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 4 4 HOoABApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpNPSpTM : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpNPSpTm : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABCApBpNPSpTeq HOoABCApBpNPSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpNPSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpNPSpT requis par la preuve de (?)OoBCApBpNPSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNPSpTm2 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApBpNPSpTm3 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  de rang :  4 et 4 	 AiB : Oo :: C :: Ap :: N ::  de rang :  4 et 4 	 A : Oo :: A :: C :: Ap :: N ::   de rang : 4 et 4 *)
assert(HOoBCApBpNPSpTm4 : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4).
{
	try assert(HOoACApNeq : rk(Oo :: A :: C :: Ap :: N :: nil) = 4) by (apply LOoACApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApNMtmp : rk(Oo :: A :: C :: Ap :: N :: nil) <= 4) by (solve_hyps_max HOoACApNeq HOoACApNM4).
	try assert(HOoABCApBpNPSpTeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) = 4) by (apply LOoABCApBpNPSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCApBpNPSpTmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoABCApBpNPSpTeq HOoABCApBpNPSpTm4).
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (list_inter (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: N :: Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) ((Oo :: A :: C :: Ap :: N :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpNPSpTmtmp;try rewrite HT2 in HOoABCApBpNPSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: N :: nil) (Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T :: nil) (Oo :: C :: Ap :: N :: nil) 4 4 4 HOoABCApBpNPSpTmtmp HOoCApNmtmp HOoACApNMtmp Hincl); apply HT.
}


assert(HOoBCApBpNPSpTM : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpNPSpTm : rk(Oo :: B :: C :: Ap :: Bp :: N :: P :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoBCApBpNPSpTeq HOoBCApBpNPSpTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApMNQSpT *)
(* dans la couche 0 *)
Lemma LOoAApMNQSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)OoAApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)OoAApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMNQSpT requis par la preuve de (?)OoAApMNQSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpTm2 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpTm3 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMNQSpTm4 : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMNQSpTM : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMNQSpTm : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoAApMNQSpTeq HOoAApMNQSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApMNQSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: M :: N :: Q :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApMNQSpT requis par la preuve de (?)AApMNQSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMNQSpTm2 : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApMNQSpTm3 : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HAApMeq : rk(A :: Ap :: M :: nil) = 3) by (apply LAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApMmtmp : rk(A :: Ap :: M :: nil) >= 3) by (solve_hyps_min HAApMeq HAApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: M :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: M :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) 3 3 HAApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M :: N :: Q :: Sp :: T ::  de rang :  4 et 4 	 AiB : A :: Ap :: N :: Sp ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: N :: Sp ::   de rang : 4 et 4 *)
assert(HAApMNQSpTm4 : rk(A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApNSpeq : rk(Oo :: A :: Ap :: N :: Sp :: nil) = 4) by (apply LOoAApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApNSpMtmp : rk(Oo :: A :: Ap :: N :: Sp :: nil) <= 4) by (solve_hyps_max HOoAApNSpeq HOoAApNSpM4).
	try assert(HOoAApMNQSpTeq : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) = 4) by (apply LOoAApMNQSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMNQSpTmtmp : rk(Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4) by (solve_hyps_min HOoAApMNQSpTeq HOoAApMNQSpTm4).
	try assert(HAApNSpeq : rk(A :: Ap :: N :: Sp :: nil) = 4) by (apply LAApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApNSpmtmp : rk(A :: Ap :: N :: Sp :: nil) >= 4) by (solve_hyps_min HAApNSpeq HAApNSpm4).
	assert(Hincl : incl (A :: Ap :: N :: Sp :: nil) (list_inter (Oo :: A :: Ap :: N :: Sp :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) (Oo :: A :: Ap :: N :: Sp :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: N :: Sp :: A :: Ap :: M :: N :: Q :: Sp :: T :: nil) ((Oo :: A :: Ap :: N :: Sp :: nil) ++ (A :: Ap :: M :: N :: Q :: Sp :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMNQSpTmtmp;try rewrite HT2 in HOoAApMNQSpTmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: N :: Sp :: nil) (A :: Ap :: M :: N :: Q :: Sp :: T :: nil) (A :: Ap :: N :: Sp :: nil) 4 4 4 HOoAApMNQSpTmtmp HAApNSpmtmp HOoAApNSpMtmp Hincl); apply HT.
}


assert(HAApMNQSpTM : rk(A :: Ap :: M :: N :: Q :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApMNQSpTm : rk(A :: Ap :: M :: N :: Q :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HAApMNQSpTeq HAApMNQSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMNQSpT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)OoABApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)OoABApMNQSpT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMNQSpT requis par la preuve de (?)OoABApMNQSpT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpTm2 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpTm3 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMNQSpTm4 : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMNQSpTM : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMNQSpTm : rk(Oo :: A :: B :: Ap :: M :: N :: Q :: Sp :: T ::  nil) >= 1) by (solve_hyps_min HOoABApMNQSpTeq HOoABApMNQSpTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(U ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HUM : rk(U ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HUeq HUM1).
assert(HUm : rk(U ::  nil) >= 1) by (solve_hyps_min HUeq HUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAU *)
(* dans la couche 0 *)
Lemma LACpUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpUV requis par la preuve de (?)ACpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpUV requis par la preuve de (?)ACCpUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm2 : rk(A :: C :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBMtmp : rk(Oo :: B :: nil) <= 2) by (solve_hyps_max HOoBeq HOoBM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (nil) 4 0 2 HOoABCCpUVmtmp Hmtmp HOoBMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACCpUVm3 : rk(A :: C :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCCpUVeq : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoABCCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCCpUVmtmp : rk(Oo :: A :: B :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoABCCpUVeq HOoABCCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: U :: V :: nil) (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Cp :: U :: V :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpUVmtmp;try rewrite HT2 in HOoABCCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoABCCpUVmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpUV requis par la preuve de (?)ACpUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpUV requis par la preuve de (?)ACpUV pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACpUVM3 : rk(A :: Cp :: U :: V :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: U :: V :: nil) (A :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: U :: V :: nil) ((A :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Cp :: U :: V :: nil) (nil) 1 2 0 HAMtmp HCpUVMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Cp :: U :: V ::  de rang :  3 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HACpUVm2 : rk(A :: Cp :: U :: V :: nil) >= 2).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HACCpUVmtmp : rk(A :: C :: Cp :: U :: V :: nil) >= 3) by (solve_hyps_min HACCpUVeq HACCpUVm3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: U :: V :: nil) (C :: A :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: Cp :: U :: V :: nil) ((C :: nil) ++ (A :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpUVmtmp;try rewrite HT2 in HACCpUVmtmp.
	assert(HT := rule_4 (C :: nil) (A :: Cp :: U :: V :: nil) (nil) 3 0 1 HACCpUVmtmp Hmtmp HCMtmp Hincl); apply HT.
}
try clear HACCpUVM1. try clear HACCpUVM2. try clear HACCpUVM3. try clear HACCpUVm4. try clear HACCpUVm3. try clear HACCpUVm2. try clear HACCpUVm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: U :: V ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HACpUVm3 : rk(A :: Cp :: U :: V :: nil) >= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoACCpUVeq : rk(Oo :: A :: C :: Cp :: U :: V :: nil) = 4) by (apply LOoACCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpUVmtmp : rk(Oo :: A :: C :: Cp :: U :: V :: nil) >= 4) by (solve_hyps_min HOoACCpUVeq HOoACCpUVm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: C :: nil) (A :: Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: U :: V :: nil) (Oo :: A :: C :: A :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: A :: Cp :: U :: V :: nil) ((Oo :: A :: C :: nil) ++ (A :: Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpUVmtmp;try rewrite HT2 in HOoACCpUVmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (A :: Cp :: U :: V :: nil) (A :: nil) 4 1 2 HOoACCpUVmtmp HAmtmp HOoACMtmp Hincl); apply HT.
}


assert(HACpUVM : rk(A :: Cp :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpUVm : rk(A :: Cp :: U :: V ::  nil) >= 1) by (solve_hyps_min HACpUVeq HACpUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AU requis par la preuve de (?)AU pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAUm2 : rk(A :: U :: nil) >= 2).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HACpUVeq : rk(A :: Cp :: U :: V :: nil) = 3) by (apply LACpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpUVmtmp : rk(A :: Cp :: U :: V :: nil) >= 3) by (solve_hyps_min HACpUVeq HACpUVm3).
	try assert(HUeq : rk(U :: nil) = 1) by (apply LU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: U :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: U :: V :: nil) (A :: U :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: U :: Cp :: U :: V :: nil) ((A :: U :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpUVmtmp;try rewrite HT2 in HACpUVmtmp.
	assert(HT := rule_2 (A :: U :: nil) (Cp :: U :: V :: nil) (U :: nil) 3 1 2 HACpUVmtmp HUmtmp HCpUVMtmp Hincl);apply HT.
}


assert(HAUM : rk(A :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAUeq HAUM2).
assert(HAUm : rk(A :: U ::  nil) >= 1) by (solve_hyps_min HAUeq HAUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpU requis par la preuve de (?)CpU pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpUm2 : rk(Cp :: U :: nil) >= 2).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HACpMPUeq : rk(A :: Cp :: M :: P :: U :: nil) = 3) by (apply LACpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMPUmtmp : rk(A :: Cp :: M :: P :: U :: nil) >= 3) by (solve_hyps_min HACpMPUeq HACpMPUm3).
	try assert(HUeq : rk(U :: nil) = 1) by (apply LU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (Cp :: U :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: P :: U :: nil) (Cp :: U :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: U :: A :: M :: P :: U :: nil) ((Cp :: U :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMPUmtmp;try rewrite HT2 in HACpMPUmtmp.
	assert(HT := rule_2 (Cp :: U :: nil) (A :: M :: P :: U :: nil) (U :: nil) 3 1 2 HACpMPUmtmp HUmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HCpUM : rk(Cp :: U ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpUeq HCpUM2).
assert(HCpUm : rk(Cp :: U ::  nil) >= 1) by (solve_hyps_min HCpUeq HCpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpU requis par la preuve de (?)ACpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpU requis par la preuve de (?)ACpU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm2 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm3 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpU requis par la preuve de (?)ACpU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: U ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpUm2 : rk(A :: Cp :: U :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpUmtmp : rk(Oo :: A :: B :: Cp :: U :: nil) >= 3) by (solve_hyps_min HOoABCpUeq HOoABCpUm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: U :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpUmtmp;try rewrite HT2 in HOoABCpUmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpUmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpUm3 : rk(A :: Cp :: U :: nil) >= 3).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HACpMPUeq : rk(A :: Cp :: M :: P :: U :: nil) = 3) by (apply LACpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMPUmtmp : rk(A :: Cp :: M :: P :: U :: nil) >= 3) by (solve_hyps_min HACpMPUeq HACpMPUm3).
	try assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (A :: Cp :: U :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: P :: U :: nil) (A :: Cp :: U :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: U :: A :: M :: P :: U :: nil) ((A :: Cp :: U :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpMPUmtmp;try rewrite HT2 in HACpMPUmtmp.
	assert(HT := rule_2 (A :: Cp :: U :: nil) (A :: M :: P :: U :: nil) (A :: U :: nil) 3 2 2 HACpMPUmtmp HAUmtmp HAMPUMtmp Hincl);apply HT.
}


assert(HACpUM : rk(A :: Cp :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpUeq HACpUM3).
assert(HACpUm : rk(A :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HACpUeq HACpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpU requis par la preuve de (?)OoACpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpU requis par la preuve de (?)OoACpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpU requis par la preuve de (?)OoACpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpUm2 : rk(Oo :: A :: Cp :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpUm3 : rk(Oo :: A :: Cp :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpUm4 : rk(Oo :: A :: Cp :: U :: nil) >= 4).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HOoACpMPUeq : rk(Oo :: A :: Cp :: M :: P :: U :: nil) = 4) by (apply LOoACpMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMPUmtmp : rk(Oo :: A :: Cp :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoACpMPUeq HOoACpMPUm4).
	try assert(HAUeq : rk(A :: U :: nil) = 2) by (apply LAU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAUmtmp : rk(A :: U :: nil) >= 2) by (solve_hyps_min HAUeq HAUm2).
	assert(Hincl : incl (A :: U :: nil) (list_inter (Oo :: A :: Cp :: U :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: M :: P :: U :: nil) (Oo :: A :: Cp :: U :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: U :: A :: M :: P :: U :: nil) ((Oo :: A :: Cp :: U :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpMPUmtmp;try rewrite HT2 in HOoACpMPUmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: U :: nil) (A :: M :: P :: U :: nil) (A :: U :: nil) 4 2 2 HOoACpMPUmtmp HAUmtmp HAMPUMtmp Hincl);apply HT.
}
try clear HAUM1. try clear HAUM2. try clear HAUM3. try clear HAUm4. try clear HAUm3. try clear HAUm2. try clear HAUm1. 

assert(HOoACpUM : rk(Oo :: A :: Cp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpUm : rk(Oo :: A :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HOoACpUeq HOoACpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCpU *)
(* dans la couche 0 *)
Lemma LOoABCpMU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMU requis par la preuve de (?)OoABCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMU requis par la preuve de (?)OoABCpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMU requis par la preuve de (?)OoABCpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUm2 : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUm3 : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUm4 : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoACpMeq : rk(Oo :: A :: Cp :: M :: nil) = 4) by (apply LOoACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMmtmp : rk(Oo :: A :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACpMeq HOoACpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: M :: U :: nil) 4 4 HOoACpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCpMUM : rk(Oo :: A :: B :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpMUm : rk(Oo :: A :: B :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoABCpMUeq HOoABCpMUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCpU *)
(* dans la couche 0 *)
Lemma LOoACpMU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Cp :: M :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpMU requis par la preuve de (?)OoACpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpMU requis par la preuve de (?)OoACpMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpMU requis par la preuve de (?)OoACpMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMUm2 : rk(Oo :: A :: Cp :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Cp :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMUm3 : rk(Oo :: A :: Cp :: M :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: Cp :: M :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpMUm4 : rk(Oo :: A :: Cp :: M :: U :: nil) >= 4).
{
	try assert(HOoACpMeq : rk(Oo :: A :: Cp :: M :: nil) = 4) by (apply LOoACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMmtmp : rk(Oo :: A :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACpMeq HOoACpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: M :: nil) (Oo :: A :: Cp :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: M :: nil) (Oo :: A :: Cp :: M :: U :: nil) 4 4 HOoACpMmtmp Hcomp Hincl);apply HT.
}


assert(HOoACpMUM : rk(Oo :: A :: Cp :: M :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpMUm : rk(Oo :: A :: Cp :: M :: U ::  nil) >= 1) by (solve_hyps_min HOoACpMUeq HOoACpMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCpU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpU requis par la preuve de (?)OoABCpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm2 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUm3 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCpUm4 : rk(Oo :: A :: B :: Cp :: U :: nil) >= 4).
{
	try assert(HOoACpMUeq : rk(Oo :: A :: Cp :: M :: U :: nil) = 4) by (apply LOoACpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpMUMtmp : rk(Oo :: A :: Cp :: M :: U :: nil) <= 4) by (solve_hyps_max HOoACpMUeq HOoACpMUM4).
	try assert(HOoABCpMUeq : rk(Oo :: A :: B :: Cp :: M :: U :: nil) = 4) by (apply LOoABCpMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMUmtmp : rk(Oo :: A :: B :: Cp :: M :: U :: nil) >= 4) by (solve_hyps_min HOoABCpMUeq HOoABCpMUm4).
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	assert(Hincl : incl (Oo :: A :: Cp :: U :: nil) (list_inter (Oo :: A :: B :: Cp :: U :: nil) (Oo :: A :: Cp :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: U :: nil) (Oo :: A :: B :: Cp :: U :: Oo :: A :: Cp :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: U :: Oo :: A :: Cp :: M :: U :: nil) ((Oo :: A :: B :: Cp :: U :: nil) ++ (Oo :: A :: Cp :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMUmtmp;try rewrite HT2 in HOoABCpMUmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: U :: nil) (Oo :: A :: Cp :: M :: U :: nil) (Oo :: A :: Cp :: U :: nil) 4 4 4 HOoABCpMUmtmp HOoACpUmtmp HOoACpMUMtmp Hincl);apply HT.
}


assert(HOoABCpUM : rk(Oo :: A :: B :: Cp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpUm : rk(Oo :: A :: B :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HOoABCpUeq HOoABCpUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAMU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: M :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AMU requis par la preuve de (?)AMU pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABMU requis par la preuve de (?)AMU pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABMU requis par la preuve de (?)OoABMU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABMU requis par la preuve de (?)OoABMU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMUm2 : rk(Oo :: A :: B :: M :: U :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: M :: U :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMUm3 : rk(Oo :: A :: B :: M :: U :: nil) >= 3).
{
	try assert(HOoAMeq : rk(Oo :: A :: M :: nil) = 3) by (apply LOoAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAMmtmp : rk(Oo :: A :: M :: nil) >= 3) by (solve_hyps_min HOoAMeq HOoAMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: M :: nil) (Oo :: A :: B :: M :: U :: nil) 3 3 HOoAMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AMU requis par la preuve de (?)AMU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: M :: U ::  de rang :  3 et 4 	 AiB : A :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HAMUm2 : rk(A :: M :: U :: nil) >= 2).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	assert(HOoABMUmtmp : rk(Oo :: A :: B :: M :: U :: nil) >= 3) by (solve_hyps_min HOoABMUeq HOoABMUm3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: M :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: U :: nil) (Oo :: A :: B :: M :: A :: M :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: M :: U :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: M :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABMUmtmp;try rewrite HT2 in HOoABMUmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: M :: U :: nil) (A :: M :: nil) 3 2 3 HOoABMUmtmp HAMmtmp HOoABMMtmp Hincl); apply HT.
}
try clear HOoABMUM1. try clear HOoABMUM2. try clear HOoABMUM3. try clear HOoABMUm4. try clear HOoABMUm3. try clear HOoABMUm2. try clear HOoABMUm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAMUM2 : rk(A :: M :: U :: nil) <= 2).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: M :: U :: nil) (A :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: M :: U :: nil) (A :: M :: P :: U :: nil) 2 2 HAMPUMtmp Hcomp Hincl);apply HT.
}


assert(HAMUM : rk(A :: M :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAMUeq HAMUM3).
assert(HAMUm : rk(A :: M :: U ::  nil) >= 1) by (solve_hyps_min HAMUeq HAMUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(V ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HVM : rk(V ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HVeq HVM1).
assert(HVm : rk(V ::  nil) >= 1) by (solve_hyps_min HVeq HVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpV requis par la preuve de (?)CpV pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpVm2 : rk(Cp :: V :: nil) >= 2).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	try assert(HBCpNQVeq : rk(B :: Cp :: N :: Q :: V :: nil) = 3) by (apply LBCpNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNQVmtmp : rk(B :: Cp :: N :: Q :: V :: nil) >= 3) by (solve_hyps_min HBCpNQVeq HBCpNQVm3).
	try assert(HVeq : rk(V :: nil) = 1) by (apply LV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HVmtmp : rk(V :: nil) >= 1) by (solve_hyps_min HVeq HVm1).
	assert(Hincl : incl (V :: nil) (list_inter (Cp :: V :: nil) (B :: N :: Q :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: N :: Q :: V :: nil) (Cp :: V :: B :: N :: Q :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: V :: B :: N :: Q :: V :: nil) ((Cp :: V :: nil) ++ (B :: N :: Q :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpNQVmtmp;try rewrite HT2 in HBCpNQVmtmp.
	assert(HT := rule_2 (Cp :: V :: nil) (B :: N :: Q :: V :: nil) (V :: nil) 3 1 2 HBCpNQVmtmp HVmtmp HBNQVMtmp Hincl);apply HT.
}
try clear HVM1. try clear HVM2. try clear HVM3. try clear HVm4. try clear HVm3. try clear HVm2. try clear HVm1. 

assert(HCpVM : rk(Cp :: V ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpVeq HCpVM2).
assert(HCpVm : rk(Cp :: V ::  nil) >= 1) by (solve_hyps_min HCpVeq HCpVm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpMV *)
(* dans la couche 0 *)
Lemma LACpMUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMUV requis par la preuve de (?)ACpMUV pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMUV requis par la preuve de (?)ACpMUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMUV requis par la preuve de (?)ACpMUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMUV requis par la preuve de (?)OoABCpMUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMUV requis par la preuve de (?)OoABCpMUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUVm2 : rk(Oo :: A :: B :: Cp :: M :: U :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMUVm3 : rk(Oo :: A :: B :: Cp :: M :: U :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: U :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMUV requis par la preuve de (?)ACpMUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: U :: V ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMUVm2 : rk(A :: Cp :: M :: U :: V :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMUVmtmp : rk(Oo :: A :: B :: Cp :: M :: U :: V :: nil) >= 3) by (solve_hyps_min HOoABCpMUVeq HOoABCpMUVm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: U :: V :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: U :: V :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMUVmtmp;try rewrite HT2 in HOoABCpMUVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: U :: V :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMUVmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMUVM1. try clear HOoABCpMUVM2. try clear HOoABCpMUVM3. try clear HOoABCpMUVm4. try clear HOoABCpMUVm3. try clear HOoABCpMUVm2. try clear HOoABCpMUVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMUVm3 : rk(A :: Cp :: M :: U :: V :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: U :: V :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACpMUVM3 : rk(A :: Cp :: M :: U :: V :: nil) <= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HUeq : rk(U :: nil) = 1) by (apply LU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HUmtmp : rk(U :: nil) >= 1) by (solve_hyps_min HUeq HUm1).
	assert(Hincl : incl (U :: nil) (list_inter (A :: M :: U :: nil) (Cp :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: M :: U :: V :: nil) (A :: M :: U :: Cp :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: U :: Cp :: U :: V :: nil) ((A :: M :: U :: nil) ++ (Cp :: U :: V :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: M :: U :: nil) (Cp :: U :: V :: nil) (U :: nil) 2 2 1 HAMUMtmp HCpUVMtmp HUmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HUM1. try clear HUM2. try clear HUM3. try clear HUm4. try clear HUm3. try clear HUm2. try clear HUm1. 

assert(HACpMUVM : rk(A :: Cp :: M :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMUVm : rk(A :: Cp :: M :: U :: V ::  nil) >= 1) by (solve_hyps_min HACpMUVeq HACpMUVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpMV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: M :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpMV requis par la preuve de (?)ACpMV pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpMV requis par la preuve de (?)ACpMV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpMV requis par la preuve de (?)ACpMV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpMV requis par la preuve de (?)OoABCpMV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpMV requis par la preuve de (?)OoABCpMV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMVm2 : rk(Oo :: A :: B :: Cp :: M :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpMVm3 : rk(Oo :: A :: B :: Cp :: M :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: M :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpMV requis par la preuve de (?)ACpMV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: M :: V ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpMVm2 : rk(A :: Cp :: M :: V :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpMVmtmp : rk(Oo :: A :: B :: Cp :: M :: V :: nil) >= 3) by (solve_hyps_min HOoABCpMVeq HOoABCpMVm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: M :: V :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: M :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: M :: V :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: M :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpMVmtmp;try rewrite HT2 in HOoABCpMVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: M :: V :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpMVmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpMVM1. try clear HOoABCpMVM2. try clear HOoABCpMVM3. try clear HOoABCpMVm4. try clear HOoABCpMVm3. try clear HOoABCpMVm2. try clear HOoABCpMVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMVm3 : rk(A :: Cp :: M :: V :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: M :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: M :: V :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpMVM3 : rk(A :: Cp :: M :: V :: nil) <= 3).
{
	try assert(HACpMUVeq : rk(A :: Cp :: M :: U :: V :: nil) = 3) by (apply LACpMUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMUVMtmp : rk(A :: Cp :: M :: U :: V :: nil) <= 3) by (solve_hyps_max HACpMUVeq HACpMUVM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: V :: nil) (A :: Cp :: M :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Cp :: M :: V :: nil) (A :: Cp :: M :: U :: V :: nil) 3 3 HACpMUVMtmp Hcomp Hincl);apply HT.
}


assert(HACpMVM : rk(A :: Cp :: M :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpMVm : rk(A :: Cp :: M :: V ::  nil) >= 1) by (solve_hyps_min HACpMVeq HACpMVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBNV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: N :: V ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BNV requis par la preuve de (?)BNV pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABNV requis par la preuve de (?)BNV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABNV requis par la preuve de (?)OoABNV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABNV requis par la preuve de (?)OoABNV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNVm2 : rk(Oo :: A :: B :: N :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: N :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABNVm3 : rk(Oo :: A :: B :: N :: V :: nil) >= 3).
{
	try assert(HOoANeq : rk(Oo :: A :: N :: nil) = 3) by (apply LOoAN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoANmtmp : rk(Oo :: A :: N :: nil) >= 3) by (solve_hyps_min HOoANeq HOoANm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: N :: nil) (Oo :: A :: B :: N :: V :: nil) 3 3 HOoANmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BNV requis par la preuve de (?)BNV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: N :: V ::  de rang :  3 et 4 	 AiB : B :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: N ::   de rang : 3 et 3 *)
assert(HBNVm2 : rk(B :: N :: V :: nil) >= 2).
{
	try assert(HOoABNeq : rk(Oo :: A :: B :: N :: nil) = 3) by (apply LOoABN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABNMtmp : rk(Oo :: A :: B :: N :: nil) <= 3) by (solve_hyps_max HOoABNeq HOoABNM3).
	assert(HOoABNVmtmp : rk(Oo :: A :: B :: N :: V :: nil) >= 3) by (solve_hyps_min HOoABNVeq HOoABNVm3).
	try assert(HBNeq : rk(B :: N :: nil) = 2) by (apply LBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNmtmp : rk(B :: N :: nil) >= 2) by (solve_hyps_min HBNeq HBNm2).
	assert(Hincl : incl (B :: N :: nil) (list_inter (Oo :: A :: B :: N :: nil) (B :: N :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: N :: V :: nil) (Oo :: A :: B :: N :: B :: N :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: N :: B :: N :: V :: nil) ((Oo :: A :: B :: N :: nil) ++ (B :: N :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABNVmtmp;try rewrite HT2 in HOoABNVmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: N :: nil) (B :: N :: V :: nil) (B :: N :: nil) 3 2 3 HOoABNVmtmp HBNmtmp HOoABNMtmp Hincl); apply HT.
}
try clear HOoABNVM1. try clear HOoABNVM2. try clear HOoABNVM3. try clear HOoABNVm4. try clear HOoABNVm3. try clear HOoABNVm2. try clear HOoABNVm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBNVM2 : rk(B :: N :: V :: nil) <= 2).
{
	try assert(HBNQVeq : rk(B :: N :: Q :: V :: nil) = 2) by (apply LBNQV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNQVMtmp : rk(B :: N :: Q :: V :: nil) <= 2) by (solve_hyps_max HBNQVeq HBNQVM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: N :: V :: nil) (B :: N :: Q :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: N :: V :: nil) (B :: N :: Q :: V :: nil) 2 2 HBNQVMtmp Hcomp Hincl);apply HT.
}


assert(HBNVM : rk(B :: N :: V ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBNVeq HBNVM3).
assert(HBNVm : rk(B :: N :: V ::  nil) >= 1) by (solve_hyps_min HBNVeq HBNVm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(R ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HRM : rk(R ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HReq HRM1).
assert(HRm : rk(R ::  nil) >= 1) by (solve_hyps_min HReq HRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCR *)
(* dans la couche 0 *)
Lemma LACCpYMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Cp :: Y :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpYMR requis par la preuve de (?)ACCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpYMR requis par la preuve de (?)ACCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpYMR requis par la preuve de (?)ACCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMRm2 : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: Y :: M :: R :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMRm3 : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HACCpeq : rk(A :: C :: Cp :: nil) = 3) by (apply LACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 3) by (solve_hyps_min HACCpeq HACCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: nil) (A :: C :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: nil) (A :: C :: Cp :: Y :: M :: R :: nil) 3 3 HACCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMRm4 : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 4).
{
	try assert(HACCpMeq : rk(A :: C :: Cp :: M :: nil) = 4) by (apply LACCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpMmtmp : rk(A :: C :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACCpMeq HACCpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: R :: nil) 4 4 HACCpMmtmp Hcomp Hincl);apply HT.
}


assert(HACCpYMRM : rk(A :: C :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpYMRm : rk(A :: C :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HACCpYMReq HACCpYMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCR *)
(* dans la couche 0 *)
Lemma LACpYMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpYMR requis par la preuve de (?)ACpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour YMR requis par la preuve de (?)ACpYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYMR requis par la preuve de (?)ACpYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYMR requis par la preuve de (?)ACpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYMR requis par la preuve de (?)OoABCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYMR requis par la preuve de (?)OoABCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMRm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMRm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYMR requis par la preuve de (?)ACpYMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMRm2 : rk(A :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMRmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: R :: nil) >= 3) by (solve_hyps_min HOoABCpYMReq HOoABCpYMRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMRmtmp;try rewrite HT2 in HOoABCpYMRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMRM1. try clear HOoABCpYMRM2. try clear HOoABCpYMRM3. try clear HOoABCpYMRm4. try clear HOoABCpYMRm3. try clear HOoABCpYMRm2. try clear HOoABCpYMRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HACpYMRM3 : rk(A :: Cp :: Y :: M :: R :: nil) <= 3).
{
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	assert(HYMRMtmp : rk(Y :: M :: R :: nil) <= 2) by (solve_hyps_max HYMReq HYMRM2).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (A :: Cp :: Y :: nil) (Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: R :: nil) (A :: Cp :: Y :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Y :: Y :: M :: R :: nil) ((A :: Cp :: Y :: nil) ++ (Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Cp :: Y :: nil) (Y :: M :: R :: nil) (Y :: nil) 2 2 1 HACpYMtmp HYMRMtmp HYmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HACpYM1. try clear HACpYM2. try clear HACpYM3. try clear HACpYm4. try clear HACpYm3. try clear HACpYm2. try clear HACpYm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMRm3 : rk(A :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


assert(HACpYMRM : rk(A :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMRm : rk(A :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HACpYMReq HACpYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CR requis par la preuve de (?)CR pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCRm2 : rk(C :: R :: nil) >= 2).
{
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	try assert(HACCpYMReq : rk(A :: C :: Cp :: Y :: M :: R :: nil) = 4) by (apply LACCpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACCpYMRmtmp : rk(A :: C :: Cp :: Y :: M :: R :: nil) >= 4) by (solve_hyps_min HACCpYMReq HACCpYMRm4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (C :: R :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: Y :: M :: R :: nil) (C :: R :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: R :: A :: Cp :: Y :: M :: R :: nil) ((C :: R :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpYMRmtmp;try rewrite HT2 in HACCpYMRmtmp.
	assert(HT := rule_2 (C :: R :: nil) (A :: Cp :: Y :: M :: R :: nil) (R :: nil) 4 1 3 HACCpYMRmtmp HRmtmp HACpYMRMtmp Hincl);apply HT.
}


assert(HCRM : rk(C :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCReq HCRM2).
assert(HCRm : rk(C :: R ::  nil) >= 1) by (solve_hyps_min HCReq HCRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMR *)
(* dans constructLemma(), requis par LCBpZMNR *)
(* dans constructLemma(), requis par LCBpZMNPTR *)
(* dans la couche 0 *)
Lemma LACBpZMNPTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpZMNPTR requis par la preuve de (?)ACBpZMNPTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpZMNPTR requis par la preuve de (?)ACBpZMNPTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpZMNPTR requis par la preuve de (?)ACBpZMNPTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpZMNPTRm2 : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpZMNPTRm3 : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 3).
{
	try assert(HACBpeq : rk(A :: C :: Bp :: nil) = 3) by (apply LACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 3) by (solve_hyps_min HACBpeq HACBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Bp :: nil) (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Bp :: nil) (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) 3 3 HACBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACBpZMNPTRm4 : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 4).
{
	try assert(HACBpMeq : rk(A :: C :: Bp :: M :: nil) = 4) by (apply LACBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACBpMmtmp : rk(A :: C :: Bp :: M :: nil) >= 4) by (solve_hyps_min HACBpMeq HACBpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Bp :: M :: nil) (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) 4 4 HACBpMmtmp Hcomp Hincl);apply HT.
}


assert(HACBpZMNPTRM : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpZMNPTRm : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R ::  nil) >= 1) by (solve_hyps_min HACBpZMNPTReq HACBpZMNPTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZMNPTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: M :: N :: P :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZMNPTR requis par la preuve de (?)CBpZMNPTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZMNPTR requis par la preuve de (?)CBpZMNPTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZMNPTR requis par la preuve de (?)CBpZMNPTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZMNPTR requis par la preuve de (?)OoACBpZMNPTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZMNPTR requis par la preuve de (?)OoACBpZMNPTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNPTRm2 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNPTRm3 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZMNPTR requis par la preuve de (?)CBpZMNPTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZMNPTRm2 : rk(C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZMNPTRmtmp : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZMNPTReq HOoACBpZMNPTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZMNPTRmtmp;try rewrite HT2 in HOoACBpZMNPTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZMNPTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZMNPTRM1. try clear HOoACBpZMNPTRM2. try clear HOoACBpZMNPTRM3. try clear HOoACBpZMNPTRm4. try clear HOoACBpZMNPTRm3. try clear HOoACBpZMNPTRm2. try clear HOoACBpZMNPTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZMNPTRm3 : rk(C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 3).
{
	try assert(HCBpMeq : rk(C :: Bp :: M :: nil) = 3) by (apply LCBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpMmtmp : rk(C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HCBpMeq HCBpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) 3 3 HCBpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Bp :: Z :: M :: N :: P :: T :: R ::  de rang :  4 et 4 	 AiB : M :: N :: T ::  de rang :  3 et 3 	 A : A :: M :: N :: T ::   de rang : 3 et 3 *)
assert(HCBpZMNPTRm4 : rk(C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 4).
{
	try assert(HAMNTeq : rk(A :: M :: N :: T :: nil) = 3) by (apply LAMNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMNTMtmp : rk(A :: M :: N :: T :: nil) <= 3) by (solve_hyps_max HAMNTeq HAMNTM3).
	try assert(HACBpZMNPTReq : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) = 4) by (apply LACBpZMNPTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACBpZMNPTRmtmp : rk(A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 4) by (solve_hyps_min HACBpZMNPTReq HACBpZMNPTRm4).
	try assert(HMNTeq : rk(M :: N :: T :: nil) = 3) by (apply LMNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMNTmtmp : rk(M :: N :: T :: nil) >= 3) by (solve_hyps_min HMNTeq HMNTm3).
	assert(Hincl : incl (M :: N :: T :: nil) (list_inter (A :: M :: N :: T :: nil) (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) (A :: M :: N :: T :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: N :: T :: C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) ((A :: M :: N :: T :: nil) ++ (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpZMNPTRmtmp;try rewrite HT2 in HACBpZMNPTRmtmp.
	assert(HT := rule_4 (A :: M :: N :: T :: nil) (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) (M :: N :: T :: nil) 4 3 3 HACBpZMNPTRmtmp HMNTmtmp HAMNTMtmp Hincl); apply HT.
}


assert(HCBpZMNPTRM : rk(C :: Bp :: Z :: M :: N :: P :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZMNPTRm : rk(C :: Bp :: Z :: M :: N :: P :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpZMNPTReq HCBpZMNPTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZMNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: M :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZMNR requis par la preuve de (?)OoACBpZMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZMNR requis par la preuve de (?)OoACBpZMNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNRm2 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZMNRm3 : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZMNR requis par la preuve de (?)CBpZMNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: M :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZMNRm2 : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZMNRmtmp : rk(Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZMNReq HOoACBpZMNRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: M :: N :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: M :: N :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZMNRmtmp;try rewrite HT2 in HOoACBpZMNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: M :: N :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZMNRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZMNRM1. try clear HOoACBpZMNRM2. try clear HOoACBpZMNRM3. try clear HOoACBpZMNRm4. try clear HOoACBpZMNRm3. try clear HOoACBpZMNRm2. try clear HOoACBpZMNRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZMNRm3 : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 3).
{
	try assert(HCBpMeq : rk(C :: Bp :: M :: nil) = 3) by (apply LCBpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpMmtmp : rk(C :: Bp :: M :: nil) >= 3) by (solve_hyps_min HCBpMeq HCBpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: M :: nil) (C :: Bp :: Z :: M :: N :: R :: nil) 3 3 HCBpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: Z :: M :: N :: P :: T :: R ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Bp :: N :: P :: T ::   de rang : 2 et 2 *)
assert(HCBpZMNRm4 : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 4).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HCBpZMNPTReq : rk(C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) = 4) by (apply LCBpZMNPTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZMNPTRmtmp : rk(C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) >= 4) by (solve_hyps_min HCBpZMNPTReq HCBpZMNPTRm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Bp :: N :: P :: T :: nil) (C :: Bp :: Z :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: M :: N :: P :: T :: R :: nil) (Bp :: N :: P :: T :: C :: Bp :: Z :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: P :: T :: C :: Bp :: Z :: M :: N :: R :: nil) ((Bp :: N :: P :: T :: nil) ++ (C :: Bp :: Z :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpZMNPTRmtmp;try rewrite HT2 in HCBpZMNPTRmtmp.
	assert(HT := rule_4 (Bp :: N :: P :: T :: nil) (C :: Bp :: Z :: M :: N :: R :: nil) (Bp :: N :: nil) 4 2 2 HCBpZMNPTRmtmp HBpNmtmp HBpNPTMtmp Hincl); apply HT.
}


assert(HCBpZMNRM : rk(C :: Bp :: Z :: M :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZMNRm : rk(C :: Bp :: Z :: M :: N :: R ::  nil) >= 1) by (solve_hyps_min HCBpZMNReq HCBpZMNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LMR *)
(* dans la couche 0 *)
Lemma LCBpZNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpZNR requis par la preuve de (?)CBpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ZNR requis par la preuve de (?)CBpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZNR requis par la preuve de (?)CBpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZNR requis par la preuve de (?)CBpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZNR requis par la preuve de (?)OoACBpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZNR requis par la preuve de (?)OoACBpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNRm2 : rk(Oo :: A :: C :: Bp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNRm3 : rk(Oo :: A :: C :: Bp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZNR requis par la preuve de (?)CBpZNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZNRm2 : rk(C :: Bp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZNRmtmp : rk(Oo :: A :: C :: Bp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZNReq HOoACBpZNRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: N :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZNRmtmp;try rewrite HT2 in HOoACBpZNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZNRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZNRM1. try clear HOoACBpZNRM2. try clear HOoACBpZNRM3. try clear HOoACBpZNRm4. try clear HOoACBpZNRm3. try clear HOoACBpZNRm2. try clear HOoACBpZNRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HCBpZNRM3 : rk(C :: Bp :: Z :: N :: R :: nil) <= 3).
{
	try assert(HCBpZeq : rk(C :: Bp :: Z :: nil) = 2) by (apply LCBpZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZMtmp : rk(C :: Bp :: Z :: nil) <= 2) by (solve_hyps_max HCBpZeq HCBpZM2).
	assert(HZNRMtmp : rk(Z :: N :: R :: nil) <= 2) by (solve_hyps_max HZNReq HZNRM2).
	try assert(HZeq : rk(Z :: nil) = 1) by (apply LZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HZmtmp : rk(Z :: nil) >= 1) by (solve_hyps_min HZeq HZm1).
	assert(Hincl : incl (Z :: nil) (list_inter (C :: Bp :: Z :: nil) (Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: N :: R :: nil) (C :: Bp :: Z :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Z :: Z :: N :: R :: nil) ((C :: Bp :: Z :: nil) ++ (Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Bp :: Z :: nil) (Z :: N :: R :: nil) (Z :: nil) 2 2 1 HCBpZMtmp HZNRMtmp HZmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCBpZM1. try clear HCBpZM2. try clear HCBpZM3. try clear HCBpZm4. try clear HCBpZm3. try clear HCBpZm2. try clear HCBpZm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZNRm3 : rk(C :: Bp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


assert(HCBpZNRM : rk(C :: Bp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZNRm : rk(C :: Bp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HCBpZNReq HCBpZNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(M :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour MR requis par la preuve de (?)MR pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HMRm2 : rk(M :: R :: nil) >= 2).
{
	try assert(HCBpZNReq : rk(C :: Bp :: Z :: N :: R :: nil) = 3) by (apply LCBpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNRMtmp : rk(C :: Bp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpZNReq HCBpZNRM3).
	try assert(HCBpZMNReq : rk(C :: Bp :: Z :: M :: N :: R :: nil) = 4) by (apply LCBpZMNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZMNRmtmp : rk(C :: Bp :: Z :: M :: N :: R :: nil) >= 4) by (solve_hyps_min HCBpZMNReq HCBpZMNRm4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (M :: R :: nil) (C :: Bp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: M :: N :: R :: nil) (M :: R :: C :: Bp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (M :: R :: C :: Bp :: Z :: N :: R :: nil) ((M :: R :: nil) ++ (C :: Bp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpZMNRmtmp;try rewrite HT2 in HCBpZMNRmtmp.
	assert(HT := rule_2 (M :: R :: nil) (C :: Bp :: Z :: N :: R :: nil) (R :: nil) 4 1 3 HCBpZMNRmtmp HRmtmp HCBpZNRMtmp Hincl);apply HT.
}


assert(HMRM : rk(M :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HMReq HMRM2).
assert(HMRm : rk(M :: R ::  nil) >= 1) by (solve_hyps_min HMReq HMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApMR *)
(* dans constructLemma(), requis par LAApCpYMR *)
(* dans la couche 0 *)
Lemma LOoAApCpYMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Cp :: Y :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm2 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm3 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm4 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApCpYMRM : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpYMRm : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HOoAApCpYMReq HOoAApCpYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpYMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Ap :: Cp :: Y :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpYMR requis par la preuve de (?)OoAApCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm2 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYMRm3 : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpYMR requis par la preuve de (?)AApCpYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApCpYMRm2 : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 2).
{
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: Y :: M :: R ::  de rang :  3 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApCpYMRm3 : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	assert(HOoAApCpYMRmtmp : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 3) by (solve_hyps_min HOoAApCpYMReq HOoAApCpYMRm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) (Oo :: Ap :: Cp :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: Cp :: Y :: M :: R :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpYMRmtmp;try rewrite HT2 in HOoAApCpYMRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil) (Ap :: Cp :: nil) 3 2 2 HOoAApCpYMRmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: Y :: M :: R ::  de rang :  4 et 4 	 AiB : Ap :: Cp :: M ::  de rang :  3 et 3 	 A : Oo :: Ap :: Cp :: M ::   de rang : 3 et 3 *)
assert(HAApCpYMRm4 : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4).
{
	try assert(HOoApCpMeq : rk(Oo :: Ap :: Cp :: M :: nil) = 3) by (apply LOoApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApCpMMtmp : rk(Oo :: Ap :: Cp :: M :: nil) <= 3) by (solve_hyps_max HOoApCpMeq HOoApCpMM3).
	try assert(HOoAApCpYMReq : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) = 4) by (apply LOoAApCpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApCpYMRmtmp : rk(Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4) by (solve_hyps_min HOoAApCpYMReq HOoAApCpYMRm4).
	try assert(HApCpMeq : rk(Ap :: Cp :: M :: nil) = 3) by (apply LApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApCpMmtmp : rk(Ap :: Cp :: M :: nil) >= 3) by (solve_hyps_min HApCpMeq HApCpMm3).
	assert(Hincl : incl (Ap :: Cp :: M :: nil) (list_inter (Oo :: Ap :: Cp :: M :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Y :: M :: R :: nil) (Oo :: Ap :: Cp :: M :: A :: Ap :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: A :: Ap :: Cp :: Y :: M :: R :: nil) ((Oo :: Ap :: Cp :: M :: nil) ++ (A :: Ap :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpYMRmtmp;try rewrite HT2 in HOoAApCpYMRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: M :: nil) (A :: Ap :: Cp :: Y :: M :: R :: nil) (Ap :: Cp :: M :: nil) 4 3 3 HOoAApCpYMRmtmp HApCpMmtmp HOoApCpMMtmp Hincl); apply HT.
}
try clear HOoAApCpYMRM1. try clear HOoAApCpYMRM2. try clear HOoAApCpYMRM3. try clear HOoAApCpYMRm4. try clear HOoAApCpYMRm3. try clear HOoAApCpYMRm2. try clear HOoAApCpYMRm1. 

assert(HAApCpYMRM : rk(A :: Ap :: Cp :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpYMRm : rk(A :: Ap :: Cp :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HAApCpYMReq HAApCpYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMR requis par la preuve de (?)ApMR pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMR requis par la preuve de (?)ApMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm2 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm3 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm4 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApMR requis par la preuve de (?)ApMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: R ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMRm2 : rk(Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMRmtmp : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 4) by (solve_hyps_min HOoABApMReq HOoABApMRm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: R :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: R :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMRmtmp;try rewrite HT2 in HOoABApMRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: R :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMRmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMRM1. try clear HOoABApMRM2. try clear HOoABApMRM3. try clear HOoABApMRm4. try clear HOoABApMRm3. try clear HOoABApMRm2. try clear HOoABApMRm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApMRm3 : rk(Ap :: M :: R :: nil) >= 3).
{
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	try assert(HAApCpYMReq : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) = 4) by (apply LAApCpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAApCpYMRmtmp : rk(A :: Ap :: Cp :: Y :: M :: R :: nil) >= 4) by (solve_hyps_min HAApCpYMReq HAApCpYMRm4).
	try assert(HMReq : rk(M :: R :: nil) = 2) by (apply LMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HMRmtmp : rk(M :: R :: nil) >= 2) by (solve_hyps_min HMReq HMRm2).
	assert(Hincl : incl (M :: R :: nil) (list_inter (Ap :: M :: R :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: Y :: M :: R :: nil) (Ap :: M :: R :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: R :: A :: Cp :: Y :: M :: R :: nil) ((Ap :: M :: R :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpYMRmtmp;try rewrite HT2 in HAApCpYMRmtmp.
	assert(HT := rule_2 (Ap :: M :: R :: nil) (A :: Cp :: Y :: M :: R :: nil) (M :: R :: nil) 4 2 3 HAApCpYMRmtmp HMRmtmp HACpYMRMtmp Hincl);apply HT.
}
try clear HMRM1. try clear HMRM2. try clear HMRM3. try clear HMRm4. try clear HMRm3. try clear HMRm2. try clear HMRm1. 

assert(HApMRM : rk(Ap :: M :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMReq HApMRM3).
assert(HApMRm : rk(Ap :: M :: R ::  nil) >= 1) by (solve_hyps_min HApMReq HApMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMR requis par la preuve de (?)OoABApMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm2 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm3 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMRm4 : rk(Oo :: A :: B :: Ap :: M :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMRM : rk(Oo :: A :: B :: Ap :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMRm : rk(Oo :: A :: B :: Ap :: M :: R ::  nil) >= 1) by (solve_hyps_min HOoABApMReq HOoABApMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApMR *)
(* dans la couche 0 *)
Lemma LCApYMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Y :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApYMR requis par la preuve de (?)CApYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour YMR requis par la preuve de (?)CApYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApYMR requis par la preuve de (?)CApYMR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApYMR requis par la preuve de (?)CApYMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApYMR requis par la preuve de (?)OoACApYMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApYMR requis par la preuve de (?)OoACApYMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMRm2 : rk(Oo :: A :: C :: Ap :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMRm3 : rk(Oo :: A :: C :: Ap :: Y :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApYMR requis par la preuve de (?)CApYMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Y :: M :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApYMRm2 : rk(C :: Ap :: Y :: M :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApYMRmtmp : rk(Oo :: A :: C :: Ap :: Y :: M :: R :: nil) >= 3) by (solve_hyps_min HOoACApYMReq HOoACApYMRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: M :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApYMRmtmp;try rewrite HT2 in HOoACApYMRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApYMRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApYMRM1. try clear HOoACApYMRM2. try clear HOoACApYMRM3. try clear HOoACApYMRm4. try clear HOoACApYMRm3. try clear HOoACApYMRm2. try clear HOoACApYMRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HCApYMRM3 : rk(C :: Ap :: Y :: M :: R :: nil) <= 3).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	assert(HYMRMtmp : rk(Y :: M :: R :: nil) <= 2) by (solve_hyps_max HYMReq HYMRM2).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (C :: Ap :: Y :: nil) (Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Y :: M :: R :: nil) (C :: Ap :: Y :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: Y :: M :: R :: nil) ((C :: Ap :: Y :: nil) ++ (Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: Y :: nil) (Y :: M :: R :: nil) (Y :: nil) 2 2 1 HCApYMtmp HYMRMtmp HYmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCApYM1. try clear HCApYM2. try clear HCApYM3. try clear HCApYm4. try clear HCApYm3. try clear HCApYm2. try clear HCApYm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApYMRm3 : rk(C :: Ap :: Y :: M :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


assert(HCApYMRM : rk(C :: Ap :: Y :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApYMRm : rk(C :: Ap :: Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HCApYMReq HCApYMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMR requis par la preuve de (?)CApMR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMR requis par la preuve de (?)CApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMR requis par la preuve de (?)CApMR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMR requis par la preuve de (?)OoACApMR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMR requis par la preuve de (?)OoACApMR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMRm2 : rk(Oo :: A :: C :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMRm3 : rk(Oo :: A :: C :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMR requis par la preuve de (?)CApMR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMRm2 : rk(C :: Ap :: M :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMRmtmp : rk(Oo :: A :: C :: Ap :: M :: R :: nil) >= 3) by (solve_hyps_min HOoACApMReq HOoACApMRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMRmtmp;try rewrite HT2 in HOoACApMRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMRM1. try clear HOoACApMRM2. try clear HOoACApMRM3. try clear HOoACApMRm4. try clear HOoACApMRm3. try clear HOoACApMRm2. try clear HOoACApMRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMRm3 : rk(C :: Ap :: M :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMRM3 : rk(C :: Ap :: M :: R :: nil) <= 3).
{
	try assert(HCApYMReq : rk(C :: Ap :: Y :: M :: R :: nil) = 3) by (apply LCApYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMRMtmp : rk(C :: Ap :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HCApYMReq HCApYMRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: R :: nil) (C :: Ap :: Y :: M :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: M :: R :: nil) (C :: Ap :: Y :: M :: R :: nil) 3 3 HCApYMRMtmp Hcomp Hincl);apply HT.
}


assert(HCApMRM : rk(C :: Ap :: M :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMRm : rk(C :: Ap :: M :: R ::  nil) >= 1) by (solve_hyps_min HCApMReq HCApMRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LYMR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Y :: M :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HYMRM : rk(Y :: M :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HYMReq HYMRM3).
assert(HYMRm : rk(Y :: M :: R ::  nil) >= 1) by (solve_hyps_min HYMReq HYMRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LNR *)
(* dans constructLemma(), requis par LCApMNR *)
(* dans constructLemma(), requis par LCApMNQSpR *)
(* dans la couche 0 *)
Lemma LBCApMNQSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApMNQSpR requis par la preuve de (?)BCApMNQSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApMNQSpR requis par la preuve de (?)BCApMNQSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApMNQSpR requis par la preuve de (?)BCApMNQSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMNQSpRm2 : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMNQSpRm3 : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 3).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) 3 3 HBCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMNQSpRm4 : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


assert(HBCApMNQSpRM : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApMNQSpRm : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HBCApMNQSpReq HBCApMNQSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMNQSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: N :: Q :: Sp :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMNQSpR requis par la preuve de (?)CApMNQSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMNQSpR requis par la preuve de (?)CApMNQSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMNQSpR requis par la preuve de (?)CApMNQSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMNQSpR requis par la preuve de (?)OoACApMNQSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMNQSpR requis par la preuve de (?)OoACApMNQSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNQSpRm2 : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNQSpRm3 : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMNQSpR requis par la preuve de (?)CApMNQSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMNQSpRm2 : rk(C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMNQSpRmtmp : rk(Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACApMNQSpReq HOoACApMNQSpRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: N :: Q :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: N :: Q :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMNQSpRmtmp;try rewrite HT2 in HOoACApMNQSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: N :: Q :: Sp :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMNQSpRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMNQSpRM1. try clear HOoACApMNQSpRM2. try clear HOoACApMNQSpRM3. try clear HOoACApMNQSpRm4. try clear HOoACApMNQSpRm3. try clear HOoACApMNQSpRm2. try clear HOoACApMNQSpRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMNQSpRm3 : rk(C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: N :: Q :: Sp :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: M :: N :: Q :: Sp :: R ::  de rang :  4 et 4 	 AiB : Ap :: N :: Sp ::  de rang :  3 et 3 	 A : B :: Ap :: N :: Sp ::   de rang : 3 et 3 *)
assert(HCApMNQSpRm4 : rk(C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 4).
{
	try assert(HBApNSpeq : rk(B :: Ap :: N :: Sp :: nil) = 3) by (apply LBApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBApNSpMtmp : rk(B :: Ap :: N :: Sp :: nil) <= 3) by (solve_hyps_max HBApNSpeq HBApNSpM3).
	try assert(HBCApMNQSpReq : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) = 4) by (apply LBCApMNQSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCApMNQSpRmtmp : rk(B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 4) by (solve_hyps_min HBCApMNQSpReq HBCApMNQSpRm4).
	try assert(HApNSpeq : rk(Ap :: N :: Sp :: nil) = 3) by (apply LApNSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApNSpmtmp : rk(Ap :: N :: Sp :: nil) >= 3) by (solve_hyps_min HApNSpeq HApNSpm3).
	assert(Hincl : incl (Ap :: N :: Sp :: nil) (list_inter (B :: Ap :: N :: Sp :: nil) (C :: Ap :: M :: N :: Q :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) (B :: Ap :: N :: Sp :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: N :: Sp :: C :: Ap :: M :: N :: Q :: Sp :: R :: nil) ((B :: Ap :: N :: Sp :: nil) ++ (C :: Ap :: M :: N :: Q :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApMNQSpRmtmp;try rewrite HT2 in HBCApMNQSpRmtmp.
	assert(HT := rule_4 (B :: Ap :: N :: Sp :: nil) (C :: Ap :: M :: N :: Q :: Sp :: R :: nil) (Ap :: N :: Sp :: nil) 4 3 3 HBCApMNQSpRmtmp HApNSpmtmp HBApNSpMtmp Hincl); apply HT.
}


assert(HCApMNQSpRM : rk(C :: Ap :: M :: N :: Q :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMNQSpRm : rk(C :: Ap :: M :: N :: Q :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCApMNQSpReq HCApMNQSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMNR requis par la preuve de (?)CApMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMNR requis par la preuve de (?)CApMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMNR requis par la preuve de (?)CApMNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMNR requis par la preuve de (?)OoACApMNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMNR requis par la preuve de (?)OoACApMNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNRm2 : rk(Oo :: A :: C :: Ap :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMNRm3 : rk(Oo :: A :: C :: Ap :: M :: N :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: N :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMNR requis par la preuve de (?)CApMNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMNRm2 : rk(C :: Ap :: M :: N :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMNRmtmp : rk(Oo :: A :: C :: Ap :: M :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACApMNReq HOoACApMNRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: N :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: N :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMNRmtmp;try rewrite HT2 in HOoACApMNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: N :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMNRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMNRM1. try clear HOoACApMNRM2. try clear HOoACApMNRM3. try clear HOoACApMNRm4. try clear HOoACApMNRm3. try clear HOoACApMNRm2. try clear HOoACApMNRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMNRm3 : rk(C :: Ap :: M :: N :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: N :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: M :: N :: Q :: Sp :: R ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Ap :: M :: Q :: Sp ::   de rang : 2 et 2 *)
assert(HCApMNRm4 : rk(C :: Ap :: M :: N :: R :: nil) >= 4).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HCApMNQSpReq : rk(C :: Ap :: M :: N :: Q :: Sp :: R :: nil) = 4) by (apply LCApMNQSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMNQSpRmtmp : rk(C :: Ap :: M :: N :: Q :: Sp :: R :: nil) >= 4) by (solve_hyps_min HCApMNQSpReq HCApMNQSpRm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Ap :: M :: Q :: Sp :: nil) (C :: Ap :: M :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: N :: Q :: Sp :: R :: nil) (Ap :: M :: Q :: Sp :: C :: Ap :: M :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Q :: Sp :: C :: Ap :: M :: N :: R :: nil) ((Ap :: M :: Q :: Sp :: nil) ++ (C :: Ap :: M :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMNQSpRmtmp;try rewrite HT2 in HCApMNQSpRmtmp.
	assert(HT := rule_4 (Ap :: M :: Q :: Sp :: nil) (C :: Ap :: M :: N :: R :: nil) (Ap :: M :: nil) 4 2 2 HCApMNQSpRmtmp HApMmtmp HApMQSpMtmp Hincl); apply HT.
}


assert(HCApMNRM : rk(C :: Ap :: M :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMNRm : rk(C :: Ap :: M :: N :: R ::  nil) >= 1) by (solve_hyps_min HCApMNReq HCApMNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(N :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour NR requis par la preuve de (?)NR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: M :: N :: R ::  de rang :  4 et 4 	 AiB : R ::  de rang :  1 et 1 	 A : C :: Ap :: M :: R ::   de rang : 3 et 3 *)
assert(HNRm2 : rk(N :: R :: nil) >= 2).
{
	try assert(HCApMReq : rk(C :: Ap :: M :: R :: nil) = 3) by (apply LCApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMRMtmp : rk(C :: Ap :: M :: R :: nil) <= 3) by (solve_hyps_max HCApMReq HCApMRM3).
	try assert(HCApMNReq : rk(C :: Ap :: M :: N :: R :: nil) = 4) by (apply LCApMNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMNRmtmp : rk(C :: Ap :: M :: N :: R :: nil) >= 4) by (solve_hyps_min HCApMNReq HCApMNRm4).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (C :: Ap :: M :: R :: nil) (N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: N :: R :: nil) (C :: Ap :: M :: R :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: R :: N :: R :: nil) ((C :: Ap :: M :: R :: nil) ++ (N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApMNRmtmp;try rewrite HT2 in HCApMNRmtmp.
	assert(HT := rule_4 (C :: Ap :: M :: R :: nil) (N :: R :: nil) (R :: nil) 4 1 3 HCApMNRmtmp HRmtmp HCApMRMtmp Hincl); apply HT.
}


assert(HNRM : rk(N :: R ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HNReq HNRM2).
assert(HNRm : rk(N :: R ::  nil) >= 1) by (solve_hyps_min HNReq HNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpNR *)
(* dans constructLemma(), requis par LBBpCpZNR *)
(* dans la couche 0 *)
Lemma LOoBBpCpZNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: B :: Bp :: Cp :: Z :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm2 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm3 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm4 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBBpCpZNRM : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpZNRm : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HOoBBpCpZNReq HOoBBpCpZNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpCpZNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Bp :: Cp :: Z :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpZNR requis par la preuve de (?)OoBBpCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm2 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoBeq : rk(Oo :: B :: nil) = 2) by (apply LOoB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBmtmp : rk(Oo :: B :: nil) >= 2) by (solve_hyps_min HOoBeq HOoBm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 2 2 HOoBmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpZNRm3 : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 3) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpmtmp : rk(Oo :: B :: Bp :: nil) >= 3) by (solve_hyps_min HOoBBpeq HOoBBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: nil) (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) 3 3 HOoBBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpCpZNR requis par la preuve de (?)OoABBpCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpCpZNR requis par la preuve de (?)OoABBpCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpZNRm2 : rk(Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpZNRm3 : rk(Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpZNR requis par la preuve de (?)BBpCpZNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: Cp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp ::   de rang : 3 et 3 *)
assert(HBBpCpZNRm2 : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoABBpeq : rk(Oo :: A :: B :: Bp :: nil) = 3) by (apply LOoABBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABBpCpZNRmtmp : rk(Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoABBpCpZNReq HOoABBpCpZNRm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Cp :: Z :: N :: R :: nil) (Oo :: A :: B :: Bp :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: B :: Bp :: Cp :: Z :: N :: R :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpCpZNRmtmp;try rewrite HT2 in HOoABBpCpZNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil) (B :: Bp :: nil) 3 2 3 HOoABBpCpZNRmtmp HBBpmtmp HOoABBpMtmp Hincl); apply HT.
}
try clear HOoABBpCpZNRM1. try clear HOoABBpCpZNRM2. try clear HOoABBpCpZNRM3. try clear HOoABBpCpZNRm4. try clear HOoABBpCpZNRm3. try clear HOoABBpCpZNRm2. try clear HOoABBpCpZNRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : Bp :: Cp ::  de rang :  2 et 2 	 A : Oo :: Bp :: Cp ::   de rang : 2 et 2 *)
assert(HBBpCpZNRm3 : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoBpCpeq : rk(Oo :: Bp :: Cp :: nil) = 2) by (apply LOoBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpMtmp : rk(Oo :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoBpCpeq HOoBpCpM2).
	assert(HOoBBpCpZNRmtmp : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoBBpCpZNReq HOoBBpCpZNRm3).
	try assert(HBpCpeq : rk(Bp :: Cp :: nil) = 2) by (apply LBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpmtmp : rk(Bp :: Cp :: nil) >= 2) by (solve_hyps_min HBpCpeq HBpCpm2).
	assert(Hincl : incl (Bp :: Cp :: nil) (list_inter (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) (Oo :: Bp :: Cp :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: B :: Bp :: Cp :: Z :: N :: R :: nil) ((Oo :: Bp :: Cp :: nil) ++ (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpZNRmtmp;try rewrite HT2 in HOoBBpCpZNRmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil) (Bp :: Cp :: nil) 3 2 2 HOoBBpCpZNRmtmp HBpCpmtmp HOoBpCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp :: Z :: N :: R ::  de rang :  4 et 4 	 AiB : Bp :: Cp :: N ::  de rang :  3 et 3 	 A : Oo :: Bp :: Cp :: N ::   de rang : 3 et 3 *)
assert(HBBpCpZNRm4 : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4).
{
	try assert(HOoBpCpNeq : rk(Oo :: Bp :: Cp :: N :: nil) = 3) by (apply LOoBpCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBpCpNMtmp : rk(Oo :: Bp :: Cp :: N :: nil) <= 3) by (solve_hyps_max HOoBpCpNeq HOoBpCpNM3).
	try assert(HOoBBpCpZNReq : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) = 4) by (apply LOoBBpCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoBBpCpZNRmtmp : rk(Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4) by (solve_hyps_min HOoBBpCpZNReq HOoBBpCpZNRm4).
	try assert(HBpCpNeq : rk(Bp :: Cp :: N :: nil) = 3) by (apply LBpCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpCpNmtmp : rk(Bp :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBpCpNeq HBpCpNm3).
	assert(Hincl : incl (Bp :: Cp :: N :: nil) (list_inter (Oo :: Bp :: Cp :: N :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: Z :: N :: R :: nil) (Oo :: Bp :: Cp :: N :: B :: Bp :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: N :: B :: Bp :: Cp :: Z :: N :: R :: nil) ((Oo :: Bp :: Cp :: N :: nil) ++ (B :: Bp :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpZNRmtmp;try rewrite HT2 in HOoBBpCpZNRmtmp.
	assert(HT := rule_4 (Oo :: Bp :: Cp :: N :: nil) (B :: Bp :: Cp :: Z :: N :: R :: nil) (Bp :: Cp :: N :: nil) 4 3 3 HOoBBpCpZNRmtmp HBpCpNmtmp HOoBpCpNMtmp Hincl); apply HT.
}
try clear HOoBBpCpZNRM1. try clear HOoBBpCpZNRM2. try clear HOoBBpCpZNRM3. try clear HOoBBpCpZNRm4. try clear HOoBBpCpZNRm3. try clear HOoBBpCpZNRm2. try clear HOoBBpCpZNRm1. 

assert(HBBpCpZNRM : rk(B :: Bp :: Cp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpZNRm : rk(B :: Bp :: Cp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HBBpCpZNReq HBBpCpZNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpNR *)
(* dans la couche 0 *)
Lemma LBCpZNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpZNR requis par la preuve de (?)BCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ZNR requis par la preuve de (?)BCpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpZNR requis par la preuve de (?)BCpZNR pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpZNR requis par la preuve de (?)BCpZNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpZNR requis par la preuve de (?)OoABCpZNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpZNR requis par la preuve de (?)OoABCpZNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNRm2 : rk(Oo :: A :: B :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNRm3 : rk(Oo :: A :: B :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpZNR requis par la preuve de (?)BCpZNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Z :: N :: R ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpZNRm2 : rk(B :: Cp :: Z :: N :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpZNRmtmp : rk(Oo :: A :: B :: Cp :: Z :: N :: R :: nil) >= 3) by (solve_hyps_min HOoABCpZNReq HOoABCpZNRm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Z :: N :: R :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpZNRmtmp;try rewrite HT2 in HOoABCpZNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: R :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpZNRmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpZNRM1. try clear HOoABCpZNRM2. try clear HOoABCpZNRM3. try clear HOoABCpZNRm4. try clear HOoABCpZNRm3. try clear HOoABCpZNRm2. try clear HOoABCpZNRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HBCpZNRM3 : rk(B :: Cp :: Z :: N :: R :: nil) <= 3).
{
	try assert(HBCpZeq : rk(B :: Cp :: Z :: nil) = 2) by (apply LBCpZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZMtmp : rk(B :: Cp :: Z :: nil) <= 2) by (solve_hyps_max HBCpZeq HBCpZM2).
	assert(HZNRMtmp : rk(Z :: N :: R :: nil) <= 2) by (solve_hyps_max HZNReq HZNRM2).
	try assert(HZeq : rk(Z :: nil) = 1) by (apply LZ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HZmtmp : rk(Z :: nil) >= 1) by (solve_hyps_min HZeq HZm1).
	assert(Hincl : incl (Z :: nil) (list_inter (B :: Cp :: Z :: nil) (Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: Z :: N :: R :: nil) (B :: Cp :: Z :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: Z :: Z :: N :: R :: nil) ((B :: Cp :: Z :: nil) ++ (Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Cp :: Z :: nil) (Z :: N :: R :: nil) (Z :: nil) 2 2 1 HBCpZMtmp HZNRMtmp HZmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HBCpZM1. try clear HBCpZM2. try clear HBCpZM3. try clear HBCpZm4. try clear HBCpZm3. try clear HBCpZm2. try clear HBCpZm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpZNRm3 : rk(B :: Cp :: Z :: N :: R :: nil) >= 3).
{
	try assert(HBCpNeq : rk(B :: Cp :: N :: nil) = 3) by (apply LBCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNmtmp : rk(B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBCpNeq HBCpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: R :: nil) 3 3 HBCpNmtmp Hcomp Hincl);apply HT.
}


assert(HBCpZNRM : rk(B :: Cp :: Z :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpZNRm : rk(B :: Cp :: Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HBCpZNReq HBCpZNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNR requis par la preuve de (?)BpNR pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)BpNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm2 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm3 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm4 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpNR requis par la preuve de (?)BpNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: N :: R ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: N ::   de rang : 4 et 4 *)
assert(HBpNRm2 : rk(Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNMtmp : rk(Oo :: A :: B :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABBpNeq HOoABBpNM4).
	assert(HOoABBpNRmtmp : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 4) by (solve_hyps_min HOoABBpNReq HOoABBpNRm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: R :: nil) (Oo :: A :: B :: Bp :: N :: Bp :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Bp :: N :: R :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Bp :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNRmtmp;try rewrite HT2 in HOoABBpNRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: R :: nil) (Bp :: N :: nil) 4 2 4 HOoABBpNRmtmp HBpNmtmp HOoABBpNMtmp Hincl); apply HT.
}
try clear HOoABBpNRM1. try clear HOoABBpNRM2. try clear HOoABBpNRM3. try clear HOoABBpNRm4. try clear HOoABBpNRm3. try clear HOoABBpNRm2. try clear HOoABBpNRm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpNRm3 : rk(Bp :: N :: R :: nil) >= 3).
{
	try assert(HBCpZNReq : rk(B :: Cp :: Z :: N :: R :: nil) = 3) by (apply LBCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNRMtmp : rk(B :: Cp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HBCpZNReq HBCpZNRM3).
	try assert(HBBpCpZNReq : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) = 4) by (apply LBBpCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBBpCpZNRmtmp : rk(B :: Bp :: Cp :: Z :: N :: R :: nil) >= 4) by (solve_hyps_min HBBpCpZNReq HBBpCpZNRm4).
	try assert(HNReq : rk(N :: R :: nil) = 2) by (apply LNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HNRmtmp : rk(N :: R :: nil) >= 2) by (solve_hyps_min HNReq HNRm2).
	assert(Hincl : incl (N :: R :: nil) (list_inter (Bp :: N :: R :: nil) (B :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: Z :: N :: R :: nil) (Bp :: N :: R :: B :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: R :: B :: Cp :: Z :: N :: R :: nil) ((Bp :: N :: R :: nil) ++ (B :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpZNRmtmp;try rewrite HT2 in HBBpCpZNRmtmp.
	assert(HT := rule_2 (Bp :: N :: R :: nil) (B :: Cp :: Z :: N :: R :: nil) (N :: R :: nil) 4 2 3 HBBpCpZNRmtmp HNRmtmp HBCpZNRMtmp Hincl);apply HT.
}
try clear HNRM1. try clear HNRM2. try clear HNRM3. try clear HNRm4. try clear HNRm3. try clear HNRm2. try clear HNRm1. 

assert(HBpNRM : rk(Bp :: N :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpNReq HBpNRM3).
assert(HBpNRm : rk(Bp :: N :: R ::  nil) >= 1) by (solve_hyps_min HBpNReq HBpNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNR requis par la preuve de (?)OoABBpNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm2 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm3 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNRm4 : rk(Oo :: A :: B :: Bp :: N :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpNRM : rk(Oo :: A :: B :: Bp :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNRm : rk(Oo :: A :: B :: Bp :: N :: R ::  nil) >= 1) by (solve_hyps_min HOoABBpNReq HOoABBpNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpNR requis par la preuve de (?)CBpNR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNR requis par la preuve de (?)CBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNR requis par la preuve de (?)CBpNR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNR requis par la preuve de (?)OoACBpNR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNR requis par la preuve de (?)OoACBpNR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNRm2 : rk(Oo :: A :: C :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNRm3 : rk(Oo :: A :: C :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNR requis par la preuve de (?)CBpNR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNRm2 : rk(C :: Bp :: N :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNRmtmp : rk(Oo :: A :: C :: Bp :: N :: R :: nil) >= 3) by (solve_hyps_min HOoACBpNReq HOoACBpNRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNRmtmp;try rewrite HT2 in HOoACBpNRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpNRM1. try clear HOoACBpNRM2. try clear HOoACBpNRM3. try clear HOoACBpNRm4. try clear HOoACBpNRm3. try clear HOoACBpNRm2. try clear HOoACBpNRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNRm3 : rk(C :: Bp :: N :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: N :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNRM3 : rk(C :: Bp :: N :: R :: nil) <= 3).
{
	try assert(HCBpZNReq : rk(C :: Bp :: Z :: N :: R :: nil) = 3) by (apply LCBpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNRMtmp : rk(C :: Bp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpZNReq HCBpZNRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: R :: nil) (C :: Bp :: Z :: N :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Bp :: N :: R :: nil) (C :: Bp :: Z :: N :: R :: nil) 3 3 HCBpZNRMtmp Hcomp Hincl);apply HT.
}


assert(HCBpNRM : rk(C :: Bp :: N :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNRm : rk(C :: Bp :: N :: R ::  nil) >= 1) by (solve_hyps_min HCBpNReq HCBpNRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LZNR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Z :: N :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

assert(HZNRM : rk(Z :: N :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HZNReq HZNRM3).
assert(HZNRm : rk(Z :: N :: R ::  nil) >= 1) by (solve_hyps_min HZNReq HZNRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSpR *)
(* dans constructLemma(), requis par LCApSpR *)
(* dans constructLemma(), requis par LCApMSpR *)
(* dans la couche 0 *)
Lemma LApMSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Ap :: M :: Sp :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApMSpR requis par la preuve de (?)ApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApMSpR requis par la preuve de (?)ApMSpR pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)ApMSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApMSpR requis par la preuve de (?)ApMSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M :: Sp :: R ::  de rang :  4 et 4 	 AiB : Ap :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap :: M ::   de rang : 4 et 4 *)
assert(HApMSpRm2 : rk(Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABApMMtmp : rk(Oo :: A :: B :: Ap :: M :: nil) <= 4) by (solve_hyps_max HOoABApMeq HOoABApMM4).
	assert(HOoABApMSpRmtmp : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 4) by (solve_hyps_min HOoABApMSpReq HOoABApMSpRm4).
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMmtmp : rk(Ap :: M :: nil) >= 2) by (solve_hyps_min HApMeq HApMm2).
	assert(Hincl : incl (Ap :: M :: nil) (list_inter (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: M :: Ap :: M :: Sp :: R :: nil) ((Oo :: A :: B :: Ap :: M :: nil) ++ (Ap :: M :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMSpRmtmp;try rewrite HT2 in HOoABApMSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: M :: nil) (Ap :: M :: Sp :: R :: nil) (Ap :: M :: nil) 4 2 4 HOoABApMSpRmtmp HApMmtmp HOoABApMMtmp Hincl); apply HT.
}
try clear HOoABApMSpRM1. try clear HOoABApMSpRM2. try clear HOoABApMSpRM3. try clear HOoABApMSpRm4. try clear HOoABApMSpRm3. try clear HOoABApMSpRm2. try clear HOoABApMSpRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApMSpRM3 : rk(Ap :: M :: Sp :: R :: nil) <= 3).
{
	try assert(HApMSpeq : rk(Ap :: M :: Sp :: nil) = 2) by (apply LApMSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpMtmp : rk(Ap :: M :: Sp :: nil) <= 2) by (solve_hyps_max HApMSpeq HApMSpM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: M :: Sp :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: Sp :: R :: nil) (Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Sp :: R :: nil) ((Ap :: M :: Sp :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: M :: Sp :: nil) (R :: nil) (nil) 2 1 0 HApMSpMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApMSpRm3 : rk(Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HApMReq : rk(Ap :: M :: R :: nil) = 3) by (apply LApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMRmtmp : rk(Ap :: M :: R :: nil) >= 3) by (solve_hyps_min HApMReq HApMRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil) 3 3 HApMRmtmp Hcomp Hincl);apply HT.
}


assert(HApMSpRM : rk(Ap :: M :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApMSpRm : rk(Ap :: M :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HApMSpReq HApMSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApMSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: M :: Sp :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApMSpR requis par la preuve de (?)CApMSpR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApMSpR requis par la preuve de (?)CApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApMSpR requis par la preuve de (?)CApMSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApMSpR requis par la preuve de (?)OoACApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApMSpR requis par la preuve de (?)OoACApMSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpRm2 : rk(Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMSpRm3 : rk(Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApMSpR requis par la preuve de (?)CApMSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApMSpRm2 : rk(C :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApMSpRmtmp : rk(Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACApMSpReq HOoACApMSpRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: Sp :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: M :: Sp :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: M :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMSpRmtmp;try rewrite HT2 in HOoACApMSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: M :: Sp :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApMSpRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApMSpRM1. try clear HOoACApMSpRM2. try clear HOoACApMSpRM3. try clear HOoACApMSpRm4. try clear HOoACApMSpRm3. try clear HOoACApMSpRm2. try clear HOoACApMSpRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApMSpRm3 : rk(C :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: M :: Sp :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCApMSpRM3 : rk(C :: Ap :: M :: Sp :: R :: nil) <= 3).
{
	try assert(HCApMReq : rk(C :: Ap :: M :: R :: nil) = 3) by (apply LCApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMRMtmp : rk(C :: Ap :: M :: R :: nil) <= 3) by (solve_hyps_max HCApMReq HCApMRM3).
	try assert(HApMSpReq : rk(Ap :: M :: Sp :: R :: nil) = 3) by (apply LApMSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMSpRMtmp : rk(Ap :: M :: Sp :: R :: nil) <= 3) by (solve_hyps_max HApMSpReq HApMSpRM3).
	try assert(HApMReq : rk(Ap :: M :: R :: nil) = 3) by (apply LApMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApMRmtmp : rk(Ap :: M :: R :: nil) >= 3) by (solve_hyps_min HApMReq HApMRm3).
	assert(Hincl : incl (Ap :: M :: R :: nil) (list_inter (C :: Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: M :: Sp :: R :: nil) (C :: Ap :: M :: R :: Ap :: M :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: R :: Ap :: M :: Sp :: R :: nil) ((C :: Ap :: M :: R :: nil) ++ (Ap :: M :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: M :: R :: nil) (Ap :: M :: Sp :: R :: nil) (Ap :: M :: R :: nil) 3 3 3 HCApMRMtmp HApMSpRMtmp HApMRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCApMSpRM : rk(C :: Ap :: M :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApMSpRm : rk(C :: Ap :: M :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCApMSpReq HCApMSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Sp :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApSpR requis par la preuve de (?)CApSpR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApSpR requis par la preuve de (?)CApSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApSpR requis par la preuve de (?)CApSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApSpR requis par la preuve de (?)OoACApSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApSpR requis par la preuve de (?)OoACApSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpRm2 : rk(Oo :: A :: C :: Ap :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApSpRm3 : rk(Oo :: A :: C :: Ap :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApSpR requis par la preuve de (?)CApSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApSpRm2 : rk(C :: Ap :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApSpRmtmp : rk(Oo :: A :: C :: Ap :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACApSpReq HOoACApSpRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Sp :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Sp :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApSpRmtmp;try rewrite HT2 in HOoACApSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Sp :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApSpRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApSpRM1. try clear HOoACApSpRM2. try clear HOoACApSpRM3. try clear HOoACApSpRm4. try clear HOoACApSpRm3. try clear HOoACApSpRm2. try clear HOoACApSpRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApSpRm3 : rk(C :: Ap :: Sp :: R :: nil) >= 3).
{
	try assert(HCApSpeq : rk(C :: Ap :: Sp :: nil) = 3) by (apply LCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApSpmtmp : rk(C :: Ap :: Sp :: nil) >= 3) by (solve_hyps_min HCApSpeq HCApSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Sp :: nil) (C :: Ap :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: Sp :: nil) (C :: Ap :: Sp :: R :: nil) 3 3 HCApSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApSpRM3 : rk(C :: Ap :: Sp :: R :: nil) <= 3).
{
	try assert(HCApMSpReq : rk(C :: Ap :: M :: Sp :: R :: nil) = 3) by (apply LCApMSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMSpRMtmp : rk(C :: Ap :: M :: Sp :: R :: nil) <= 3) by (solve_hyps_max HCApMSpReq HCApMSpRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Sp :: R :: nil) (C :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: Sp :: R :: nil) (C :: Ap :: M :: Sp :: R :: nil) 3 3 HCApMSpRMtmp Hcomp Hincl);apply HT.
}


assert(HCApSpRM : rk(C :: Ap :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApSpRm : rk(C :: Ap :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCApSpReq HCApSpRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSpR *)
(* dans constructLemma(), requis par LCBpZNSpTR *)
(* dans la couche 0 *)
Lemma LCBpZNTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: N :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZNTR requis par la preuve de (?)OoACBpZNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZNTR requis par la preuve de (?)OoACBpZNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNTRm2 : rk(Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNTRm3 : rk(Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZNTR requis par la preuve de (?)CBpZNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: N :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZNTRm2 : rk(C :: Bp :: Z :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZNTRmtmp : rk(Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZNTReq HOoACBpZNTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: N :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZNTRmtmp;try rewrite HT2 in HOoACBpZNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZNTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZNTRM1. try clear HOoACBpZNTRM2. try clear HOoACBpZNTRM3. try clear HOoACBpZNTRm4. try clear HOoACBpZNTRm3. try clear HOoACBpZNTRm2. try clear HOoACBpZNTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZNTRm3 : rk(C :: Bp :: Z :: N :: T :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: T :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpZNTRM3 : rk(C :: Bp :: Z :: N :: T :: R :: nil) <= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HCBpZNReq : rk(C :: Bp :: Z :: N :: R :: nil) = 3) by (apply LCBpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNRMtmp : rk(C :: Bp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpZNReq HCBpZNRM3).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Bp :: N :: T :: nil) (C :: Bp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: N :: T :: R :: nil) (Bp :: N :: T :: C :: Bp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: C :: Bp :: Z :: N :: R :: nil) ((Bp :: N :: T :: nil) ++ (C :: Bp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: T :: nil) (C :: Bp :: Z :: N :: R :: nil) (Bp :: N :: nil) 2 3 2 HBpNTMtmp HCBpZNRMtmp HBpNmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpZNTRM : rk(C :: Bp :: Z :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZNTRm : rk(C :: Bp :: Z :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpZNTReq HCBpZNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpZNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: Z :: N :: Sp :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpZNSpTR requis par la preuve de (?)OoACBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpZNSpTR requis par la preuve de (?)OoACBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNSpTRm2 : rk(Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpZNSpTRm3 : rk(Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpZNSpTR requis par la preuve de (?)CBpZNSpTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpZNSpTRm2 : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpZNSpTRmtmp : rk(Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpZNSpTReq HOoACBpZNSpTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpZNSpTRmtmp;try rewrite HT2 in HOoACBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpZNSpTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpZNSpTRM1. try clear HOoACBpZNSpTRM2. try clear HOoACBpZNSpTRM3. try clear HOoACBpZNSpTRm4. try clear HOoACBpZNSpTRm3. try clear HOoACBpZNSpTRm2. try clear HOoACBpZNSpTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpZNSpTRm3 : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpZNSpTRM3 : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) <= 3).
{
	try assert(HCSpTeq : rk(C :: Sp :: T :: nil) = 2) by (apply LCSpT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpTMtmp : rk(C :: Sp :: T :: nil) <= 2) by (solve_hyps_max HCSpTeq HCSpTM2).
	try assert(HCBpZNTReq : rk(C :: Bp :: Z :: N :: T :: R :: nil) = 3) by (apply LCBpZNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNTRMtmp : rk(C :: Bp :: Z :: N :: T :: R :: nil) <= 3) by (solve_hyps_max HCBpZNTReq HCBpZNTRM3).
	try assert(HCTeq : rk(C :: T :: nil) = 2) by (apply LCT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCTmtmp : rk(C :: T :: nil) >= 2) by (solve_hyps_min HCTeq HCTm2).
	assert(Hincl : incl (C :: T :: nil) (list_inter (C :: Sp :: T :: nil) (C :: Bp :: Z :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Sp :: T :: C :: Bp :: Z :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: T :: C :: Bp :: Z :: N :: T :: R :: nil) ((C :: Sp :: T :: nil) ++ (C :: Bp :: Z :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Sp :: T :: nil) (C :: Bp :: Z :: N :: T :: R :: nil) (C :: T :: nil) 2 3 2 HCSpTMtmp HCBpZNTRMtmp HCTmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpZNSpTRM : rk(C :: Bp :: Z :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpZNSpTRm : rk(C :: Bp :: Z :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpZNSpTReq HCBpZNSpTRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSpR *)
(* dans constructLemma(), requis par LCApBpZNSpTR *)
(* dans la couche 0 *)
Lemma LOoCApBpZNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm2 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm3 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm4 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 4 4 HOoCApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpZNSpTRM : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpZNSpTRm : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoCApBpZNSpTReq HOoCApBpZNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpZNSpTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpZNSpTR requis par la preuve de (?)OoCApBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm2 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpZNSpTRm3 : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpZNSpTR requis par la preuve de (?)OoACApBpZNSpTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpZNSpTR requis par la preuve de (?)OoACApBpZNSpTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpZNSpTRm2 : rk(Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpZNSpTRm3 : rk(Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpZNSpTR requis par la preuve de (?)CApBpZNSpTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpZNSpTRm2 : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpZNSpTRmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApBpZNSpTReq HOoACApBpZNSpTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpZNSpTRmtmp;try rewrite HT2 in HOoACApBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpZNSpTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpZNSpTRM1. try clear HOoACApBpZNSpTRM2. try clear HOoACApBpZNSpTRM3. try clear HOoACApBpZNSpTRm4. try clear HOoACApBpZNSpTRm3. try clear HOoACApBpZNSpTRm2. try clear HOoACApBpZNSpTRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpZNSpTRm3 : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpZNSpTRmtmp : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 3) by (solve_hyps_min HOoCApBpZNSpTReq HOoCApBpZNSpTRm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpZNSpTRmtmp;try rewrite HT2 in HOoCApBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpZNSpTRmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HCApBpZNSpTRm4 : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	try assert(HOoCApBpZNSpTReq : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) = 4) by (apply LOoCApBpZNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpZNSpTRmtmp : rk(Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HOoCApBpZNSpTReq HOoCApBpZNSpTRm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpZNSpTRmtmp;try rewrite HT2 in HOoCApBpZNSpTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (Ap :: Bp :: N :: nil) 4 3 3 HOoCApBpZNSpTRmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoCApBpZNSpTRM1. try clear HOoCApBpZNSpTRM2. try clear HOoCApBpZNSpTRM3. try clear HOoCApBpZNSpTRm4. try clear HOoCApBpZNSpTRm3. try clear HOoCApBpZNSpTRm2. try clear HOoCApBpZNSpTRm1. 

assert(HCApBpZNSpTRM : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpZNSpTRm : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApBpZNSpTReq HCApBpZNSpTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Sp :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CSpR requis par la preuve de (?)CSpR pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACSpR requis par la preuve de (?)CSpR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACSpR requis par la preuve de (?)OoACSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACSpR requis par la preuve de (?)OoACSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACSpRm2 : rk(Oo :: A :: C :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACSpRm3 : rk(Oo :: A :: C :: Sp :: R :: nil) >= 3).
{
	try assert(HOoASpeq : rk(Oo :: A :: Sp :: nil) = 3) by (apply LOoASp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoASpmtmp : rk(Oo :: A :: Sp :: nil) >= 3) by (solve_hyps_min HOoASpeq HOoASpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Sp :: nil) (Oo :: A :: C :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Sp :: nil) (Oo :: A :: C :: Sp :: R :: nil) 3 3 HOoASpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CSpR requis par la preuve de (?)CSpR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Sp :: R ::  de rang :  3 et 4 	 AiB : C :: Sp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Sp ::   de rang : 3 et 3 *)
assert(HCSpRm2 : rk(C :: Sp :: R :: nil) >= 2).
{
	try assert(HOoACSpeq : rk(Oo :: A :: C :: Sp :: nil) = 3) by (apply LOoACSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACSpMtmp : rk(Oo :: A :: C :: Sp :: nil) <= 3) by (solve_hyps_max HOoACSpeq HOoACSpM3).
	assert(HOoACSpRmtmp : rk(Oo :: A :: C :: Sp :: R :: nil) >= 3) by (solve_hyps_min HOoACSpReq HOoACSpRm3).
	try assert(HCSpeq : rk(C :: Sp :: nil) = 2) by (apply LCSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpmtmp : rk(C :: Sp :: nil) >= 2) by (solve_hyps_min HCSpeq HCSpm2).
	assert(Hincl : incl (C :: Sp :: nil) (list_inter (Oo :: A :: C :: Sp :: nil) (C :: Sp :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Sp :: R :: nil) (Oo :: A :: C :: Sp :: C :: Sp :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Sp :: C :: Sp :: R :: nil) ((Oo :: A :: C :: Sp :: nil) ++ (C :: Sp :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACSpRmtmp;try rewrite HT2 in HOoACSpRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Sp :: nil) (C :: Sp :: R :: nil) (C :: Sp :: nil) 3 2 3 HOoACSpRmtmp HCSpmtmp HOoACSpMtmp Hincl); apply HT.
}
try clear HCSpM1. try clear HCSpM2. try clear HCSpM3. try clear HCSpm4. try clear HCSpm3. try clear HCSpm2. try clear HCSpm1. try clear HOoACSpRM1. try clear HOoACSpRM2. try clear HOoACSpRM3. try clear HOoACSpRm4. try clear HOoACSpRm3. try clear HOoACSpRm2. try clear HOoACSpRm1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HCSpRM2 : rk(C :: Sp :: R :: nil) <= 2).
{
	try assert(HCApSpReq : rk(C :: Ap :: Sp :: R :: nil) = 3) by (apply LCApSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApSpRMtmp : rk(C :: Ap :: Sp :: R :: nil) <= 3) by (solve_hyps_max HCApSpReq HCApSpRM3).
	try assert(HCBpZNSpTReq : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) = 3) by (apply LCBpZNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpZNSpTRMtmp : rk(C :: Bp :: Z :: N :: Sp :: T :: R :: nil) <= 3) by (solve_hyps_max HCBpZNSpTReq HCBpZNSpTRM3).
	try assert(HCApBpZNSpTReq : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) = 4) by (apply LCApBpZNSpTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpZNSpTRmtmp : rk(C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) >= 4) by (solve_hyps_min HCApBpZNSpTReq HCApBpZNSpTRm4).
	assert(Hincl : incl (C :: Sp :: R :: nil) (list_inter (C :: Ap :: Sp :: R :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Ap :: Sp :: R :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Sp :: R :: C :: Bp :: Z :: N :: Sp :: T :: R :: nil) ((C :: Ap :: Sp :: R :: nil) ++ (C :: Bp :: Z :: N :: Sp :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpZNSpTRmtmp;try rewrite HT2 in HCApBpZNSpTRmtmp.
	assert(HT := rule_3 (C :: Ap :: Sp :: R :: nil) (C :: Bp :: Z :: N :: Sp :: T :: R :: nil) (C :: Sp :: R :: nil) 3 3 4 HCApSpRMtmp HCBpZNSpTRMtmp HCApBpZNSpTRmtmp Hincl);apply HT.
}


assert(HCSpRM : rk(C :: Sp :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCSpReq HCSpRM3).
assert(HCSpRm : rk(C :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HCSpReq HCSpRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApMSpR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Ap :: M :: Sp :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMSpR requis par la preuve de (?)OoABApMSpR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm2 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm3 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMSpRm4 : rk(Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: Sp :: R :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMSpRM : rk(Oo :: A :: B :: Ap :: M :: Sp :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMSpRm : rk(Oo :: A :: B :: Ap :: M :: Sp :: R ::  nil) >= 1) by (solve_hyps_min HOoABApMSpReq HOoABApMSpRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCTR *)
(* dans constructLemma(), requis par LCApTR *)
(* dans la couche 0 *)
Lemma LCApYMTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Y :: M :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApYMTR requis par la preuve de (?)CApYMTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApYMTR requis par la preuve de (?)CApYMTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApYMTR requis par la preuve de (?)CApYMTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApYMTR requis par la preuve de (?)OoACApYMTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApYMTR requis par la preuve de (?)OoACApYMTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMTRm2 : rk(Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMTRm3 : rk(Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApYMTR requis par la preuve de (?)CApYMTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Y :: M :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApYMTRm2 : rk(C :: Ap :: Y :: M :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApYMTRmtmp : rk(Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApYMTReq HOoACApYMTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: M :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Y :: M :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Y :: M :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApYMTRmtmp;try rewrite HT2 in HOoACApYMTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Y :: M :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApYMTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApYMTRM1. try clear HOoACApYMTRM2. try clear HOoACApYMTRM3. try clear HOoACApYMTRm4. try clear HOoACApYMTRm3. try clear HOoACApYMTRm2. try clear HOoACApYMTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApYMTRm3 : rk(C :: Ap :: Y :: M :: T :: R :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: T :: R :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCApYMTRM3 : rk(C :: Ap :: Y :: M :: T :: R :: nil) <= 3).
{
	try assert(HCApMTeq : rk(C :: Ap :: M :: T :: nil) = 3) by (apply LCApMT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMTMtmp : rk(C :: Ap :: M :: T :: nil) <= 3) by (solve_hyps_max HCApMTeq HCApMTM3).
	try assert(HCApYMReq : rk(C :: Ap :: Y :: M :: R :: nil) = 3) by (apply LCApYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMRMtmp : rk(C :: Ap :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HCApYMReq HCApYMRM3).
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hincl : incl (C :: Ap :: M :: nil) (list_inter (C :: Ap :: M :: T :: nil) (C :: Ap :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Y :: M :: T :: R :: nil) (C :: Ap :: M :: T :: C :: Ap :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: M :: T :: C :: Ap :: Y :: M :: R :: nil) ((C :: Ap :: M :: T :: nil) ++ (C :: Ap :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: M :: T :: nil) (C :: Ap :: Y :: M :: R :: nil) (C :: Ap :: M :: nil) 3 3 3 HCApMTMtmp HCApYMRMtmp HCApMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCApYMTRM : rk(C :: Ap :: Y :: M :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApYMTRm : rk(C :: Ap :: Y :: M :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApYMTReq HCApYMTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApTR requis par la preuve de (?)CApTR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApTR requis par la preuve de (?)CApTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApTR requis par la preuve de (?)CApTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApTR requis par la preuve de (?)OoACApTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApTR requis par la preuve de (?)OoACApTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTRm2 : rk(Oo :: A :: C :: Ap :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApTRm3 : rk(Oo :: A :: C :: Ap :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApTR requis par la preuve de (?)CApTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApTRm2 : rk(C :: Ap :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApTRmtmp : rk(Oo :: A :: C :: Ap :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApTReq HOoACApTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApTRmtmp;try rewrite HT2 in HOoACApTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApTRM1. try clear HOoACApTRM2. try clear HOoACApTRM3. try clear HOoACApTRm4. try clear HOoACApTRm3. try clear HOoACApTRm2. try clear HOoACApTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApTRm3 : rk(C :: Ap :: T :: R :: nil) >= 3).
{
	try assert(HCApTeq : rk(C :: Ap :: T :: nil) = 3) by (apply LCApT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApTmtmp : rk(C :: Ap :: T :: nil) >= 3) by (solve_hyps_min HCApTeq HCApTm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: T :: nil) (C :: Ap :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: T :: nil) (C :: Ap :: T :: R :: nil) 3 3 HCApTmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApTRM3 : rk(C :: Ap :: T :: R :: nil) <= 3).
{
	try assert(HCApYMTReq : rk(C :: Ap :: Y :: M :: T :: R :: nil) = 3) by (apply LCApYMTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApYMTRMtmp : rk(C :: Ap :: Y :: M :: T :: R :: nil) <= 3) by (solve_hyps_max HCApYMTReq HCApYMTRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: T :: R :: nil) (C :: Ap :: Y :: M :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Ap :: T :: R :: nil) (C :: Ap :: Y :: M :: T :: R :: nil) 3 3 HCApYMTRMtmp Hcomp Hincl);apply HT.
}


assert(HCApTRM : rk(C :: Ap :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApTRm : rk(C :: Ap :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApTReq HCApTRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCTR *)
(* dans constructLemma(), requis par LCBpNTR *)
(* dans la couche 0 *)
Lemma LBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Bp :: N :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpNTR requis par la preuve de (?)BpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpNTR requis par la preuve de (?)BpNTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)BpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm2 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm3 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm4 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpNTR requis par la preuve de (?)BpNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: N :: T :: R ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: N ::   de rang : 4 et 4 *)
assert(HBpNTRm2 : rk(Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABBpNMtmp : rk(Oo :: A :: B :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABBpNeq HOoABBpNM4).
	assert(HOoABBpNTRmtmp : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 4) by (solve_hyps_min HOoABBpNTReq HOoABBpNTRm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: N :: T :: R :: nil) (Oo :: A :: B :: Bp :: N :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: Bp :: N :: T :: R :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpNTRmtmp;try rewrite HT2 in HOoABBpNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: N :: nil) (Bp :: N :: T :: R :: nil) (Bp :: N :: nil) 4 2 4 HOoABBpNTRmtmp HBpNmtmp HOoABBpNMtmp Hincl); apply HT.
}
try clear HOoABBpNTRM1. try clear HOoABBpNTRM2. try clear HOoABBpNTRM3. try clear HOoABBpNTRm4. try clear HOoABBpNTRm3. try clear HOoABBpNTRm2. try clear HOoABBpNTRm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpNTRM3 : rk(Bp :: N :: T :: R :: nil) <= 3).
{
	try assert(HBpNTeq : rk(Bp :: N :: T :: nil) = 2) by (apply LBpNT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTMtmp : rk(Bp :: N :: T :: nil) <= 2) by (solve_hyps_max HBpNTeq HBpNTM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: N :: T :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: N :: T :: R :: nil) (Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: T :: R :: nil) ((Bp :: N :: T :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: N :: T :: nil) (R :: nil) (nil) 2 1 0 HBpNTMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpNTRm3 : rk(Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HBpNReq : rk(Bp :: N :: R :: nil) = 3) by (apply LBpNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNRmtmp : rk(Bp :: N :: R :: nil) >= 3) by (solve_hyps_min HBpNReq HBpNRm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil) 3 3 HBpNRmtmp Hcomp Hincl);apply HT.
}


assert(HBpNTRM : rk(Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpNTRm : rk(Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HBpNTReq HBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Bp :: N :: T :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpNTR requis par la preuve de (?)CBpNTR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpNTR requis par la preuve de (?)CBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACBpNTR requis par la preuve de (?)CBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACBpNTR requis par la preuve de (?)OoACBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACBpNTR requis par la preuve de (?)OoACBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNTRm2 : rk(Oo :: A :: C :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACBpNTRm3 : rk(Oo :: A :: C :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: C :: Bp :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpNTR requis par la preuve de (?)CBpNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Bp :: N :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Bp ::   de rang : 3 et 3 *)
assert(HCBpNTRm2 : rk(C :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoACBpeq : rk(Oo :: A :: C :: Bp :: nil) = 3) by (apply LOoACBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACBpMtmp : rk(Oo :: A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoACBpeq HOoACBpM3).
	assert(HOoACBpNTRmtmp : rk(Oo :: A :: C :: Bp :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACBpNTReq HOoACBpNTRm3).
	try assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Bp :: N :: T :: R :: nil) (Oo :: A :: C :: Bp :: C :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Bp :: C :: Bp :: N :: T :: R :: nil) ((Oo :: A :: C :: Bp :: nil) ++ (C :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACBpNTRmtmp;try rewrite HT2 in HOoACBpNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Bp :: nil) (C :: Bp :: N :: T :: R :: nil) (C :: Bp :: nil) 3 2 3 HOoACBpNTRmtmp HCBpmtmp HOoACBpMtmp Hincl); apply HT.
}
try clear HOoACBpNTRM1. try clear HOoACBpNTRM2. try clear HOoACBpNTRM3. try clear HOoACBpNTRm4. try clear HOoACBpNTRm3. try clear HOoACBpNTRm2. try clear HOoACBpNTRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCBpNTRm3 : rk(C :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HCBpNeq : rk(C :: Bp :: N :: nil) = 3) by (apply LCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNmtmp : rk(C :: Bp :: N :: nil) >= 3) by (solve_hyps_min HCBpNeq HCBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Bp :: N :: nil) (C :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Bp :: N :: nil) (C :: Bp :: N :: T :: R :: nil) 3 3 HCBpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCBpNTRM3 : rk(C :: Bp :: N :: T :: R :: nil) <= 3).
{
	try assert(HCBpNReq : rk(C :: Bp :: N :: R :: nil) = 3) by (apply LCBpNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNRMtmp : rk(C :: Bp :: N :: R :: nil) <= 3) by (solve_hyps_max HCBpNReq HCBpNRM3).
	try assert(HBpNTReq : rk(Bp :: N :: T :: R :: nil) = 3) by (apply LBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNTRMtmp : rk(Bp :: N :: T :: R :: nil) <= 3) by (solve_hyps_max HBpNTReq HBpNTRM3).
	try assert(HBpNReq : rk(Bp :: N :: R :: nil) = 3) by (apply LBpNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBpNRmtmp : rk(Bp :: N :: R :: nil) >= 3) by (solve_hyps_min HBpNReq HBpNRm3).
	assert(Hincl : incl (Bp :: N :: R :: nil) (list_inter (C :: Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: N :: T :: R :: nil) (C :: Bp :: N :: R :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: R :: Bp :: N :: T :: R :: nil) ((C :: Bp :: N :: R :: nil) ++ (Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Bp :: N :: R :: nil) (Bp :: N :: T :: R :: nil) (Bp :: N :: R :: nil) 3 3 3 HCBpNRMtmp HBpNTRMtmp HBpNRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCBpNTRM : rk(C :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpNTRm : rk(C :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HCBpNTReq HCBpNTRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCTR *)
(* dans constructLemma(), requis par LCApBpNTR *)
(* dans la couche 0 *)
Lemma LOoCApBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: N :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm2 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm3 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm4 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoCApNeq : rk(Oo :: C :: Ap :: N :: nil) = 4) by (apply LOoCApN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApNmtmp : rk(Oo :: C :: Ap :: N :: nil) >= 4) by (solve_hyps_min HOoCApNeq HOoCApNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: N :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 4 4 HOoCApNmtmp Hcomp Hincl);apply HT.
}


assert(HOoCApBpNTRM : rk(Oo :: C :: Ap :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpNTRm : rk(Oo :: C :: Ap :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoCApBpNTReq HOoCApBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Ap :: Bp :: N :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpNTR requis par la preuve de (?)OoCApBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm2 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoCeq : rk(Oo :: C :: nil) = 2) by (apply LOoC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCmtmp : rk(Oo :: C :: nil) >= 2) by (solve_hyps_min HOoCeq HOoCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 2 2 HOoCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApBpNTRm3 : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoCApeq : rk(Oo :: C :: Ap :: nil) = 3) by (apply LOoCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApmtmp : rk(Oo :: C :: Ap :: nil) >= 3) by (solve_hyps_min HOoCApeq HOoCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: nil) (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) 3 3 HOoCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpNTR requis par la preuve de (?)OoACApBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpNTR requis par la preuve de (?)OoACApBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNTRm2 : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpNTRm3 : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpNTR requis par la preuve de (?)CApBpNTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: N :: T :: R ::  de rang :  3 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HCApBpNTRm2 : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoACApBpNTRmtmp : rk(Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACApBpNTReq HOoACApBpNTRm3).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: N :: T :: R :: nil) (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: C :: Ap :: Bp :: N :: T :: R :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (C :: Ap :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpNTRmtmp;try rewrite HT2 in HOoACApBpNTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil) (C :: Ap :: nil) 3 2 3 HOoACApBpNTRmtmp HCApmtmp HOoACApMtmp Hincl); apply HT.
}
try clear HOoACApBpNTRM1. try clear HOoACApBpNTRM2. try clear HOoACApBpNTRM3. try clear HOoACApBpNTRm4. try clear HOoACApBpNTRm3. try clear HOoACApBpNTRm2. try clear HOoACApBpNTRm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: T :: R ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpNTRm3 : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoCApBpNTRmtmp : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 3) by (solve_hyps_min HOoCApBpNTReq HOoCApBpNTRm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: C :: Ap :: Bp :: N :: T :: R :: nil) ((Oo :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNTRmtmp;try rewrite HT2 in HOoCApBpNTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil) (Ap :: Bp :: nil) 3 2 2 HOoCApBpNTRmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: N :: T :: R ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: N ::  de rang :  3 et 3 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HCApBpNTRm4 : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	try assert(HOoCApBpNTReq : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) = 4) by (apply LOoCApBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoCApBpNTRmtmp : rk(Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) >= 4) by (solve_hyps_min HOoCApBpNTReq HOoCApBpNTRm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: N :: T :: R :: nil) (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: C :: Ap :: Bp :: N :: T :: R :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (C :: Ap :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpNTRmtmp;try rewrite HT2 in HOoCApBpNTRmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (C :: Ap :: Bp :: N :: T :: R :: nil) (Ap :: Bp :: N :: nil) 4 3 3 HOoCApBpNTRmtmp HApBpNmtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoCApBpNTRM1. try clear HOoCApBpNTRM2. try clear HOoCApBpNTRM3. try clear HOoCApBpNTRm4. try clear HOoCApBpNTRm3. try clear HOoCApBpNTRm2. try clear HOoCApBpNTRm1. 

assert(HCApBpNTRM : rk(C :: Ap :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpNTRm : rk(C :: Ap :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HCApBpNTReq HCApBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: T :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CTR requis par la preuve de (?)CTR pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACTR requis par la preuve de (?)CTR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACTR requis par la preuve de (?)OoACTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACTR requis par la preuve de (?)OoACTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACTRm2 : rk(Oo :: A :: C :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACTRm3 : rk(Oo :: A :: C :: T :: R :: nil) >= 3).
{
	try assert(HOoATeq : rk(Oo :: A :: T :: nil) = 3) by (apply LOoAT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoATmtmp : rk(Oo :: A :: T :: nil) >= 3) by (solve_hyps_min HOoATeq HOoATm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: T :: nil) (Oo :: A :: C :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: T :: nil) (Oo :: A :: C :: T :: R :: nil) 3 3 HOoATmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CTR requis par la preuve de (?)CTR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: T :: R ::  de rang :  3 et 4 	 AiB : C :: T ::  de rang :  2 et 2 	 A : Oo :: A :: C :: T ::   de rang : 3 et 3 *)
assert(HCTRm2 : rk(C :: T :: R :: nil) >= 2).
{
	try assert(HOoACTeq : rk(Oo :: A :: C :: T :: nil) = 3) by (apply LOoACT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACTMtmp : rk(Oo :: A :: C :: T :: nil) <= 3) by (solve_hyps_max HOoACTeq HOoACTM3).
	assert(HOoACTRmtmp : rk(Oo :: A :: C :: T :: R :: nil) >= 3) by (solve_hyps_min HOoACTReq HOoACTRm3).
	try assert(HCTeq : rk(C :: T :: nil) = 2) by (apply LCT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCTmtmp : rk(C :: T :: nil) >= 2) by (solve_hyps_min HCTeq HCTm2).
	assert(Hincl : incl (C :: T :: nil) (list_inter (Oo :: A :: C :: T :: nil) (C :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: T :: R :: nil) (Oo :: A :: C :: T :: C :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: T :: C :: T :: R :: nil) ((Oo :: A :: C :: T :: nil) ++ (C :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACTRmtmp;try rewrite HT2 in HOoACTRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: T :: nil) (C :: T :: R :: nil) (C :: T :: nil) 3 2 3 HOoACTRmtmp HCTmtmp HOoACTMtmp Hincl); apply HT.
}
try clear HCTM1. try clear HCTM2. try clear HCTM3. try clear HCTm4. try clear HCTm3. try clear HCTm2. try clear HCTm1. try clear HOoACTRM1. try clear HOoACTRM2. try clear HOoACTRM3. try clear HOoACTRm4. try clear HOoACTRm3. try clear HOoACTRm2. try clear HOoACTRm1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HCTRM2 : rk(C :: T :: R :: nil) <= 2).
{
	try assert(HCApTReq : rk(C :: Ap :: T :: R :: nil) = 3) by (apply LCApTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApTRMtmp : rk(C :: Ap :: T :: R :: nil) <= 3) by (solve_hyps_max HCApTReq HCApTRM3).
	try assert(HCBpNTReq : rk(C :: Bp :: N :: T :: R :: nil) = 3) by (apply LCBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCBpNTRMtmp : rk(C :: Bp :: N :: T :: R :: nil) <= 3) by (solve_hyps_max HCBpNTReq HCBpNTRM3).
	try assert(HCApBpNTReq : rk(C :: Ap :: Bp :: N :: T :: R :: nil) = 4) by (apply LCApBpNTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCApBpNTRmtmp : rk(C :: Ap :: Bp :: N :: T :: R :: nil) >= 4) by (solve_hyps_min HCApBpNTReq HCApBpNTRm4).
	assert(Hincl : incl (C :: T :: R :: nil) (list_inter (C :: Ap :: T :: R :: nil) (C :: Bp :: N :: T :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: N :: T :: R :: nil) (C :: Ap :: T :: R :: C :: Bp :: N :: T :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: T :: R :: C :: Bp :: N :: T :: R :: nil) ((C :: Ap :: T :: R :: nil) ++ (C :: Bp :: N :: T :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpNTRmtmp;try rewrite HT2 in HCApBpNTRmtmp.
	assert(HT := rule_3 (C :: Ap :: T :: R :: nil) (C :: Bp :: N :: T :: R :: nil) (C :: T :: R :: nil) 3 3 4 HCApTRMtmp HCBpNTRMtmp HCApBpNTRmtmp Hincl);apply HT.
}


assert(HCTRM : rk(C :: T :: R ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCTReq HCTRM3).
assert(HCTRm : rk(C :: T :: R ::  nil) >= 1) by (solve_hyps_min HCTReq HCTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpNTR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Bp :: N :: T :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpNTR requis par la preuve de (?)OoABBpNTR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm2 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm3 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNTRm4 : rk(Oo :: A :: B :: Bp :: N :: T :: R :: nil) >= 4).
{
	try assert(HOoABpNeq : rk(Oo :: A :: Bp :: N :: nil) = 4) by (apply LOoABpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABpNmtmp : rk(Oo :: A :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABpNeq HOoABpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: T :: R :: nil) 4 4 HOoABpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpNTRM : rk(Oo :: A :: B :: Bp :: N :: T :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNTRm : rk(Oo :: A :: B :: Bp :: N :: T :: R ::  nil) >= 1) by (solve_hyps_min HOoABBpNTReq HOoABBpNTRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpYMUR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y :: M :: U :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpYMUR requis par la preuve de (?)ACpYMUR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYMUR requis par la preuve de (?)ACpYMUR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYMUR requis par la preuve de (?)ACpYMUR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYMUR requis par la preuve de (?)OoABCpYMUR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYMUR requis par la preuve de (?)OoABCpYMUR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMURm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMURm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYMUR requis par la preuve de (?)ACpYMUR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M :: U :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMURm2 : rk(A :: Cp :: Y :: M :: U :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMURmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) >= 3) by (solve_hyps_min HOoABCpYMUReq HOoABCpYMURm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: U :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: U :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMURmtmp;try rewrite HT2 in HOoABCpYMURmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMURmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMURM1. try clear HOoABCpYMURM2. try clear HOoABCpYMURM3. try clear HOoABCpYMURm4. try clear HOoABCpYMURm3. try clear HOoABCpYMURm2. try clear HOoABCpYMURm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMURm3 : rk(A :: Cp :: Y :: M :: U :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACpYMURM3 : rk(A :: Cp :: Y :: M :: U :: R :: nil) <= 3).
{
	try assert(HAMUeq : rk(A :: M :: U :: nil) = 2) by (apply LAMU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMUMtmp : rk(A :: M :: U :: nil) <= 2) by (solve_hyps_max HAMUeq HAMUM2).
	try assert(HACpYMReq : rk(A :: Cp :: Y :: M :: R :: nil) = 3) by (apply LACpYMR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMRMtmp : rk(A :: Cp :: Y :: M :: R :: nil) <= 3) by (solve_hyps_max HACpYMReq HACpYMRM3).
	try assert(HAMeq : rk(A :: M :: nil) = 2) by (apply LAM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HAMmtmp : rk(A :: M :: nil) >= 2) by (solve_hyps_min HAMeq HAMm2).
	assert(Hincl : incl (A :: M :: nil) (list_inter (A :: M :: U :: nil) (A :: Cp :: Y :: M :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: U :: R :: nil) (A :: M :: U :: A :: Cp :: Y :: M :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: M :: U :: A :: Cp :: Y :: M :: R :: nil) ((A :: M :: U :: nil) ++ (A :: Cp :: Y :: M :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: M :: U :: nil) (A :: Cp :: Y :: M :: R :: nil) (A :: M :: nil) 2 3 2 HAMUMtmp HACpYMRMtmp HAMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HACpYMURM : rk(A :: Cp :: Y :: M :: U :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMURm : rk(A :: Cp :: Y :: M :: U :: R ::  nil) >= 1) by (solve_hyps_min HACpYMUReq HACpYMURm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpZNVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z :: N :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpZNVR requis par la preuve de (?)OoABCpZNVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpZNVR requis par la preuve de (?)OoABCpZNVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNVRm2 : rk(Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNVRm3 : rk(Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpZNVR requis par la preuve de (?)BCpZNVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Z :: N :: V :: R ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpZNVRm2 : rk(B :: Cp :: Z :: N :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpZNVRmtmp : rk(Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpZNVReq HOoABCpZNVRm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Z :: N :: V :: R :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: Z :: N :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpZNVRmtmp;try rewrite HT2 in HOoABCpZNVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: V :: R :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpZNVRmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpZNVRM1. try clear HOoABCpZNVRM2. try clear HOoABCpZNVRM3. try clear HOoABCpZNVRm4. try clear HOoABCpZNVRm3. try clear HOoABCpZNVRm2. try clear HOoABCpZNVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpZNVRm3 : rk(B :: Cp :: Z :: N :: V :: R :: nil) >= 3).
{
	try assert(HBCpNeq : rk(B :: Cp :: N :: nil) = 3) by (apply LBCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNmtmp : rk(B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBCpNeq HBCpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: V :: R :: nil) 3 3 HBCpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCpZNVRM3 : rk(B :: Cp :: Z :: N :: V :: R :: nil) <= 3).
{
	try assert(HBNVeq : rk(B :: N :: V :: nil) = 2) by (apply LBNV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNVMtmp : rk(B :: N :: V :: nil) <= 2) by (solve_hyps_max HBNVeq HBNVM2).
	try assert(HBCpZNReq : rk(B :: Cp :: Z :: N :: R :: nil) = 3) by (apply LBCpZNR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNRMtmp : rk(B :: Cp :: Z :: N :: R :: nil) <= 3) by (solve_hyps_max HBCpZNReq HBCpZNRM3).
	try assert(HBNeq : rk(B :: N :: nil) = 2) by (apply LBN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBNmtmp : rk(B :: N :: nil) >= 2) by (solve_hyps_min HBNeq HBNm2).
	assert(Hincl : incl (B :: N :: nil) (list_inter (B :: N :: V :: nil) (B :: Cp :: Z :: N :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: Z :: N :: V :: R :: nil) (B :: N :: V :: B :: Cp :: Z :: N :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: N :: V :: B :: Cp :: Z :: N :: R :: nil) ((B :: N :: V :: nil) ++ (B :: Cp :: Z :: N :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: N :: V :: nil) (B :: Cp :: Z :: N :: R :: nil) (B :: N :: nil) 2 3 2 HBNVMtmp HBCpZNRMtmp HBNmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBCpZNVRM : rk(B :: Cp :: Z :: N :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpZNVRm : rk(B :: Cp :: Z :: N :: V :: R ::  nil) >= 1) by (solve_hyps_min HBCpZNVReq HBCpZNVRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpUVR *)
(* dans constructLemma(), requis par LACpUVR *)
(* dans la couche 0 *)
Lemma LACpYMUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: Y :: M :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYMUVR requis par la preuve de (?)OoABCpYMUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYMUVR requis par la preuve de (?)OoABCpYMUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMUVRm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMUVRm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYMUVR requis par la preuve de (?)ACpYMUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMUVRm2 : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMUVRmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpYMUVReq HOoABCpYMUVRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMUVRmtmp;try rewrite HT2 in HOoABCpYMUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMUVRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMUVRM1. try clear HOoABCpYMUVRM2. try clear HOoABCpYMUVRM3. try clear HOoABCpYMUVRm4. try clear HOoABCpYMUVRm3. try clear HOoABCpYMUVRm2. try clear HOoABCpYMUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMUVRm3 : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACpYMUVRM3 : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) <= 3).
{
	try assert(HACpMVeq : rk(A :: Cp :: M :: V :: nil) = 3) by (apply LACpMV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMVMtmp : rk(A :: Cp :: M :: V :: nil) <= 3) by (solve_hyps_max HACpMVeq HACpMVM3).
	try assert(HACpYMUReq : rk(A :: Cp :: Y :: M :: U :: R :: nil) = 3) by (apply LACpYMUR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMURMtmp : rk(A :: Cp :: Y :: M :: U :: R :: nil) <= 3) by (solve_hyps_max HACpYMUReq HACpYMURM3).
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hincl : incl (A :: Cp :: M :: nil) (list_inter (A :: Cp :: M :: V :: nil) (A :: Cp :: Y :: M :: U :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: U :: V :: R :: nil) (A :: Cp :: M :: V :: A :: Cp :: Y :: M :: U :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: M :: V :: A :: Cp :: Y :: M :: U :: R :: nil) ((A :: Cp :: M :: V :: nil) ++ (A :: Cp :: Y :: M :: U :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Cp :: M :: V :: nil) (A :: Cp :: Y :: M :: U :: R :: nil) (A :: Cp :: M :: nil) 3 3 3 HACpMVMtmp HACpYMURMtmp HACpMmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HACpYMUVRM : rk(A :: Cp :: Y :: M :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMUVRm : rk(A :: Cp :: Y :: M :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HACpYMUVReq HACpYMUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: Cp :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpUVR requis par la preuve de (?)ACpUVR pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpUVR requis par la preuve de (?)ACpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)ACpUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm2 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm3 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpUVR requis par la preuve de (?)ACpUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: U :: V :: R ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpUVRm2 : rk(A :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpUVRmtmp : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpUVReq HOoABCpUVRm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpUVRmtmp;try rewrite HT2 in HOoABCpUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: U :: V :: R :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpUVRmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpUVRm3 : rk(A :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HACpUeq : rk(A :: Cp :: U :: nil) = 3) by (apply LACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpUmtmp : rk(A :: Cp :: U :: nil) >= 3) by (solve_hyps_min HACpUeq HACpUm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: U :: nil) (A :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: U :: nil) (A :: Cp :: U :: V :: R :: nil) 3 3 HACpUmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpUVRM3 : rk(A :: Cp :: U :: V :: R :: nil) <= 3).
{
	try assert(HACpYMUVReq : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) = 3) by (apply LACpYMUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpYMUVRMtmp : rk(A :: Cp :: Y :: M :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HACpYMUVReq HACpYMUVRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: U :: V :: R :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Cp :: U :: V :: R :: nil) (A :: Cp :: Y :: M :: U :: V :: R :: nil) 3 3 HACpYMUVRMtmp Hcomp Hincl);apply HT.
}


assert(HACpUVRM : rk(A :: Cp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpUVRm : rk(A :: Cp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HACpUVReq HACpUVRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpUVR *)
(* dans la couche 0 *)
Lemma LBCpZNUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(B :: Cp :: Z :: N :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpZNUVR requis par la preuve de (?)OoABCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpZNUVR requis par la preuve de (?)OoABCpZNUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNUVRm2 : rk(Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpZNUVRm3 : rk(Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpZNUVR requis par la preuve de (?)BCpZNUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R ::  de rang :  3 et 4 	 AiB : B :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBCpZNUVRm2 : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpZNUVRmtmp : rk(Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoABCpZNUVReq HOoABCpZNUVRm3).
	try assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hincl : incl (B :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Cp :: Z :: N :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpZNUVRmtmp;try rewrite HT2 in HOoABCpZNUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil) (B :: Cp :: nil) 3 2 3 HOoABCpZNUVRmtmp HBCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpZNUVRM1. try clear HOoABCpZNUVRM2. try clear HOoABCpZNUVRM3. try clear HOoABCpZNUVRm4. try clear HOoABCpZNUVRm3. try clear HOoABCpZNUVRm2. try clear HOoABCpZNUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpZNUVRm3 : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HBCpNeq : rk(B :: Cp :: N :: nil) = 3) by (apply LBCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpNmtmp : rk(B :: Cp :: N :: nil) >= 3) by (solve_hyps_min HBCpNeq HBCpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: N :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil) 3 3 HBCpNmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCpZNUVRM3 : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) <= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HBCpZNVReq : rk(B :: Cp :: Z :: N :: V :: R :: nil) = 3) by (apply LBCpZNVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNVRMtmp : rk(B :: Cp :: Z :: N :: V :: R :: nil) <= 3) by (solve_hyps_max HBCpZNVReq HBCpZNVRM3).
	try assert(HCpVeq : rk(Cp :: V :: nil) = 2) by (apply LCpV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpVmtmp : rk(Cp :: V :: nil) >= 2) by (solve_hyps_min HCpVeq HCpVm2).
	assert(Hincl : incl (Cp :: V :: nil) (list_inter (Cp :: U :: V :: nil) (B :: Cp :: Z :: N :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: Z :: N :: U :: V :: R :: nil) (Cp :: U :: V :: B :: Cp :: Z :: N :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: U :: V :: B :: Cp :: Z :: N :: V :: R :: nil) ((Cp :: U :: V :: nil) ++ (B :: Cp :: Z :: N :: V :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: U :: V :: nil) (B :: Cp :: Z :: N :: V :: R :: nil) (Cp :: V :: nil) 2 3 2 HCpUVMtmp HBCpZNVRMtmp HCpVmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCpVM1. try clear HCpVM2. try clear HCpVM3. try clear HCpVm4. try clear HCpVm3. try clear HCpVm2. try clear HCpVm1. 

assert(HBCpZNUVRM : rk(B :: Cp :: Z :: N :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpZNUVRm : rk(B :: Cp :: Z :: N :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HBCpZNUVReq HBCpZNUVRm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpUVR *)
(* dans la couche 0 *)
Lemma LABCpZNUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(A :: B :: Cp :: Z :: N :: U :: V :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCpZNUVR requis par la preuve de (?)ABCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpZNUVR requis par la preuve de (?)ABCpZNUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpZNUVR requis par la preuve de (?)ABCpZNUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpZNUVRm2 : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpZNUVRm3 : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 3).
{
	try assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpZNUVRm4 : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 4).
{
	try assert(HABCpNeq : rk(A :: B :: Cp :: N :: nil) = 4) by (apply LABCpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpNmtmp : rk(A :: B :: Cp :: N :: nil) >= 4) by (solve_hyps_min HABCpNeq HABCpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: N :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: N :: nil) (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) 4 4 HABCpNmtmp Hcomp Hincl);apply HT.
}


assert(HABCpZNUVRM : rk(A :: B :: Cp :: Z :: N :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpZNUVRm : rk(A :: B :: Cp :: Z :: N :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HABCpZNUVReq HABCpZNUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Cp :: U :: V :: R ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpUVR requis par la preuve de (?)CpUVR pour la règle 3  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CpUVR requis par la preuve de (?)CpUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)CpUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm2 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm3 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm4 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 4).
{
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 4 4 HOoACpUmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpUVR requis par la preuve de (?)CpUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: U :: V :: R ::  de rang :  4 et 4 	 AiB : Cp :: U ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp :: U ::   de rang : 4 et 4 *)
assert(HCpUVRm2 : rk(Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoABCpUeq : rk(Oo :: A :: B :: Cp :: U :: nil) = 4) by (apply LOoABCpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoABCpUMtmp : rk(Oo :: A :: B :: Cp :: U :: nil) <= 4) by (solve_hyps_max HOoABCpUeq HOoABCpUM4).
	assert(HOoABCpUVRmtmp : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 4) by (solve_hyps_min HOoABCpUVReq HOoABCpUVRm4).
	try assert(HCpUeq : rk(Cp :: U :: nil) = 2) by (apply LCpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUmtmp : rk(Cp :: U :: nil) >= 2) by (solve_hyps_min HCpUeq HCpUm2).
	assert(Hincl : incl (Cp :: U :: nil) (list_inter (Oo :: A :: B :: Cp :: U :: nil) (Cp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: U :: V :: R :: nil) (Oo :: A :: B :: Cp :: U :: Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: U :: Cp :: U :: V :: R :: nil) ((Oo :: A :: B :: Cp :: U :: nil) ++ (Cp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpUVRmtmp;try rewrite HT2 in HOoABCpUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: U :: nil) (Cp :: U :: V :: R :: nil) (Cp :: U :: nil) 4 2 4 HOoABCpUVRmtmp HCpUmtmp HOoABCpUMtmp Hincl); apply HT.
}
try clear HCpUM1. try clear HCpUM2. try clear HCpUM3. try clear HCpUm4. try clear HCpUm3. try clear HCpUm2. try clear HCpUm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCpUVRM3 : rk(Cp :: U :: V :: R :: nil) <= 3).
{
	try assert(HCpUVeq : rk(Cp :: U :: V :: nil) = 2) by (apply LCpUV with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVMtmp : rk(Cp :: U :: V :: nil) <= 2) by (solve_hyps_max HCpUVeq HCpUVM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRMtmp : rk(R :: nil) <= 1) by (solve_hyps_max HReq HRM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: U :: V :: nil) (R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: U :: V :: R :: nil) (Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: U :: V :: R :: nil) ((Cp :: U :: V :: nil) ++ (R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: U :: V :: nil) (R :: nil) (nil) 2 1 0 HCpUVMtmp HRMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HCpUVRM2 : rk(Cp :: U :: V :: R :: nil) <= 2).
{
	try assert(HACpUVReq : rk(A :: Cp :: U :: V :: R :: nil) = 3) by (apply LACpUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HACpUVRMtmp : rk(A :: Cp :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HACpUVReq HACpUVRM3).
	try assert(HBCpZNUVReq : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) = 3) by (apply LBCpZNUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HBCpZNUVRMtmp : rk(B :: Cp :: Z :: N :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HBCpZNUVReq HBCpZNUVRM3).
	try assert(HABCpZNUVReq : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) = 4) by (apply LABCpZNUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HABCpZNUVRmtmp : rk(A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) >= 4) by (solve_hyps_min HABCpZNUVReq HABCpZNUVRm4).
	assert(Hincl : incl (Cp :: U :: V :: R :: nil) (list_inter (A :: Cp :: U :: V :: R :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: Z :: N :: U :: V :: R :: nil) (A :: Cp :: U :: V :: R :: B :: Cp :: Z :: N :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: U :: V :: R :: B :: Cp :: Z :: N :: U :: V :: R :: nil) ((A :: Cp :: U :: V :: R :: nil) ++ (B :: Cp :: Z :: N :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCpZNUVRmtmp;try rewrite HT2 in HABCpZNUVRmtmp.
	assert(HT := rule_3 (A :: Cp :: U :: V :: R :: nil) (B :: Cp :: Z :: N :: U :: V :: R :: nil) (Cp :: U :: V :: R :: nil) 3 3 4 HACpUVRMtmp HBCpZNUVRMtmp HABCpZNUVRmtmp Hincl);apply HT.
}


assert(HCpUVRM : rk(Cp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpUVRm : rk(Cp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HCpUVReq HCpUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCpUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(Oo :: A :: B :: Cp :: U :: V :: R ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpUVR requis par la preuve de (?)OoABCpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm2 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm3 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpUVRm4 : rk(Oo :: A :: B :: Cp :: U :: V :: R :: nil) >= 4).
{
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: U :: nil) (Oo :: A :: B :: Cp :: U :: V :: R :: nil) 4 4 HOoACpUmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCpUVRM : rk(Oo :: A :: B :: Cp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpUVRm : rk(Oo :: A :: B :: Cp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HOoABCpUVReq HOoABCpUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSpUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSpUVR requis par la preuve de (?)OoACCpSpUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSpUVR requis par la preuve de (?)OoACCpSpUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpUVRm2 : rk(Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpUVRm3 : rk(Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CCpSpUVR requis par la preuve de (?)CCpSpUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp :: U :: V :: R ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpUVRm2 : rk(C :: Cp :: Sp :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpUVRmtmp : rk(Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoACCpSpUVReq HOoACCpSpUVRm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: U :: V :: R :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: U :: V :: R :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpUVRmtmp;try rewrite HT2 in HOoACCpSpUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpUVRmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpUVRM1. try clear HOoACCpSpUVRM2. try clear HOoACCpSpUVRM3. try clear HOoACCpSpUVRm4. try clear HOoACCpSpUVRm3. try clear HOoACCpSpUVRm2. try clear HOoACCpSpUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpUVRm3 : rk(C :: Cp :: Sp :: U :: V :: R :: nil) >= 3).
{
	try assert(HCCpSpeq : rk(C :: Cp :: Sp :: nil) = 3) by (apply LCCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpmtmp : rk(C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HCCpSpeq HCCpSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil) 3 3 HCCpSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCCpSpUVRM3 : rk(C :: Cp :: Sp :: U :: V :: R :: nil) <= 3).
{
	try assert(HCSpReq : rk(C :: Sp :: R :: nil) = 2) by (apply LCSpR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCSpRMtmp : rk(C :: Sp :: R :: nil) <= 2) by (solve_hyps_max HCSpReq HCSpRM2).
	try assert(HCpUVReq : rk(Cp :: U :: V :: R :: nil) = 2) by (apply LCpUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCpUVRMtmp : rk(Cp :: U :: V :: R :: nil) <= 2) by (solve_hyps_max HCpUVReq HCpUVRM2).
	try assert(HReq : rk(R :: nil) = 1) by (apply LR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HRmtmp : rk(R :: nil) >= 1) by (solve_hyps_min HReq HRm1).
	assert(Hincl : incl (R :: nil) (list_inter (C :: Sp :: R :: nil) (Cp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: Sp :: U :: V :: R :: nil) (C :: Sp :: R :: Cp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: R :: Cp :: U :: V :: R :: nil) ((C :: Sp :: R :: nil) ++ (Cp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Sp :: R :: nil) (Cp :: U :: V :: R :: nil) (R :: nil) 2 2 1 HCSpRMtmp HCpUVRMtmp HRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCCpSpUVRM : rk(C :: Cp :: Sp :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCCpSpUVRm : rk(C :: Cp :: Sp :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HCCpSpUVReq HCCpSpUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSpTUVR : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp :: T :: U :: V :: R ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSpTUVR requis par la preuve de (?)OoACCpSpTUVR pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSpTUVR requis par la preuve de (?)OoACCpSpTUVR pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVRm2 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVRm3 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CCpSpTUVR requis par la preuve de (?)CCpSpTUVR pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpTUVRm2 : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpTUVRmtmp : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 3) by (solve_hyps_min HOoACCpSpTUVReq HOoACCpSpTUVRm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: R :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: T :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpTUVRmtmp;try rewrite HT2 in HOoACCpSpTUVRmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpTUVRmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpTUVRM1. try clear HOoACCpSpTUVRM2. try clear HOoACCpSpTUVRM3. try clear HOoACCpSpTUVRm4. try clear HOoACCpSpTUVRm3. try clear HOoACCpSpTUVRm2. try clear HOoACCpSpTUVRm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpTUVRm3 : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) >= 3).
{
	try assert(HCCpSpeq : rk(C :: Cp :: Sp :: nil) = 3) by (apply LCCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpmtmp : rk(C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HCCpSpeq HCCpSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil) 3 3 HCCpSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCCpSpTUVRM3 : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) <= 3).
{
	try assert(HCTReq : rk(C :: T :: R :: nil) = 2) by (apply LCTR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCTRMtmp : rk(C :: T :: R :: nil) <= 2) by (solve_hyps_max HCTReq HCTRM2).
	try assert(HCCpSpUVReq : rk(C :: Cp :: Sp :: U :: V :: R :: nil) = 3) by (apply LCCpSpUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpUVRMtmp : rk(C :: Cp :: Sp :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HCCpSpUVReq HCCpSpUVRM3).
	try assert(HCReq : rk(C :: R :: nil) = 2) by (apply LCR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCRmtmp : rk(C :: R :: nil) >= 2) by (solve_hyps_min HCReq HCRm2).
	assert(Hincl : incl (C :: R :: nil) (list_inter (C :: T :: R :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: Sp :: T :: U :: V :: R :: nil) (C :: T :: R :: C :: Cp :: Sp :: U :: V :: R :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: T :: R :: C :: Cp :: Sp :: U :: V :: R :: nil) ((C :: T :: R :: nil) ++ (C :: Cp :: Sp :: U :: V :: R :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: T :: R :: nil) (C :: Cp :: Sp :: U :: V :: R :: nil) (C :: R :: nil) 2 3 2 HCTRMtmp HCCpSpUVRMtmp HCRmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCRM1. try clear HCRM2. try clear HCRM3. try clear HCRm4. try clear HCRm3. try clear HCRm2. try clear HCRm1. 

assert(HCCpSpTUVRM : rk(C :: Cp :: Sp :: T :: U :: V :: R ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCCpSpTUVRm : rk(C :: Cp :: Sp :: T :: U :: V :: R ::  nil) >= 1) by (solve_hyps_min HCCpSpTUVReq HCCpSpTUVRm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSpTUV : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R ,
rk(Oo :: A ::  nil) = 2 -> rk(Oo :: B ::  nil) = 2 -> rk(A :: B ::  nil) = 2 ->
rk(Oo :: C ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 ->
rk(Oo :: Bp ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2 ->
rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 -> rk(B :: Cp :: Z ::  nil) = 2 ->
rk(X :: Y :: Z ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: Q :: Sp ::  nil) = 4 ->
rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N :: P :: T ::  nil) = 4 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: C :: Ap :: Bp :: Cp :: Sp :: T ::  nil) = 4 -> rk(Ap :: Bp :: M :: N :: P :: Q :: Sp :: T ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 ->
rk(Oo :: A :: Ap :: Bp :: Cp :: M :: P :: U ::  nil) = 4 -> rk(A :: C :: M :: P :: Sp :: T :: U ::  nil) = 4 -> rk(B :: N :: Q :: V ::  nil) = 2 ->
rk(Oo :: B :: Ap :: Bp :: Cp :: N :: Q :: V ::  nil) = 4 -> rk(B :: C :: N :: Q :: Sp :: T :: V ::  nil) = 4 -> rk(Cp :: U :: V ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Cp :: U :: V ::  nil) = 4 -> rk(A :: B :: M :: N :: P :: Q :: U :: V ::  nil) = 4 -> rk(Ap :: Cp :: M :: Q :: Sp :: U :: V ::  nil) = 4 ->
rk(Bp :: Cp :: N :: P :: T :: U :: V ::  nil) = 4 -> rk(Y :: M :: R ::  nil) = 2 -> rk(Z :: N :: R ::  nil) = 2 ->
rk(C :: Cp :: Sp :: T :: U :: V ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V R 
HOoAeq HOoBeq HABeq HOoCeq HACeq HBCeq HOoABCeq HOoApeq HOoAApeq HOoBpeq
HApBpeq HOoCpeq HApCpeq HBpCpeq HOoApBpCpeq HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq
HBCpZeq HXYZeq HApMQSpeq HOoABCApMQSpeq HBpNPTeq HOoABCBpNPTeq HCSpTeq HOoCApBpCpSpTeq HApBpMNPQSpTeq HAMPUeq
HOoAApBpCpMPUeq HACMPSpTUeq HBNQVeq HOoBApBpCpNQVeq HBCNQSpTVeq HCpUVeq HOoABCCpUVeq HABMNPQUVeq HApCpMQSpUVeq HBpCpNPTUVeq
HYMReq HZNReq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpSpTUV requis par la preuve de (?)OoACCpSpTUV pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpSpTUV requis par la preuve de (?)OoACCpSpTUV pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVm2 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) >= 2).
{
	try assert(HOoAeq : rk(Oo :: A :: nil) = 2) by (apply LOoA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 2) by (solve_hyps_min HOoAeq HOoAm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) 2 2 HOoAmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpSpTUVm3 : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CCpSpTUV requis par la preuve de (?)CCpSpTUV pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: Sp :: T :: U :: V ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCCpSpTUVm2 : rk(C :: Cp :: Sp :: T :: U :: V :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	assert(HOoACCpSpTUVmtmp : rk(Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) >= 3) by (solve_hyps_min HOoACCpSpTUVeq HOoACCpSpTUVm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: Sp :: T :: U :: V :: nil) (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Cp :: Sp :: T :: U :: V :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Cp :: Sp :: T :: U :: V :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpSpTUVmtmp;try rewrite HT2 in HOoACCpSpTUVmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil) (C :: Cp :: nil) 3 2 3 HOoACCpSpTUVmtmp HCCpmtmp HOoACCpMtmp Hincl); apply HT.
}
try clear HOoACCpSpTUVM1. try clear HOoACCpSpTUVM2. try clear HOoACCpSpTUVM3. try clear HOoACCpSpTUVm4. try clear HOoACCpSpTUVm3. try clear HOoACCpSpTUVm2. try clear HOoACCpSpTUVm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpTUVm3 : rk(C :: Cp :: Sp :: T :: U :: V :: nil) >= 3).
{
	try assert(HCCpSpeq : rk(C :: Cp :: Sp :: nil) = 3) by (apply LCCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpmtmp : rk(C :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HCCpSpeq HCCpSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Cp :: Sp :: nil) (C :: Cp :: Sp :: T :: U :: V :: nil) 3 3 HCCpSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCCpSpTUVM3 : rk(C :: Cp :: Sp :: T :: U :: V :: nil) <= 3).
{
	try assert(HCCpSpTUVReq : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) = 3) by (apply LCCpSpTUVR with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) (R := R) ;try assumption).
	assert(HCCpSpTUVRMtmp : rk(C :: Cp :: Sp :: T :: U :: V :: R :: nil) <= 3) by (solve_hyps_max HCCpSpTUVReq HCCpSpTUVRM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Cp :: Sp :: T :: U :: V :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: Cp :: Sp :: T :: U :: V :: nil) (C :: Cp :: Sp :: T :: U :: V :: R :: nil) 3 3 HCCpSpTUVRMtmp Hcomp Hincl);apply HT.
}


assert(HCCpSpTUVM : rk(C :: Cp :: Sp :: T :: U :: V ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCCpSpTUVm : rk(C :: Cp :: Sp :: T :: U :: V ::  nil) >= 1) by (solve_hyps_min HCCpSpTUVeq HCCpSpTUVm1).
intuition.
Qed.

