Require Import lemmas_automation_g.


(* dans la couche 0 *)
Lemma LOo : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LA : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HAM : rk(A ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAeq HAM1).
assert(HAm : rk(A ::  nil) >= 1) by (solve_hyps_min HAeq HAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HBM : rk(B ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBeq HBM1).
assert(HBm : rk(B ::  nil) >= 1) by (solve_hyps_min HBeq HBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HABM : rk(A :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABeq HABM2).
assert(HABm : rk(A :: B ::  nil) >= 1) by (solve_hyps_min HABeq HABm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAB *)
(* dans la couche 0 *)
Lemma LOoABC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoABCM : rk(Oo :: A :: B :: C ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCm : rk(Oo :: A :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoABCeq HOoABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAB : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABM2 : rk(Oo :: A :: B :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: B :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoABM : rk(Oo :: A :: B ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABeq HOoABM3).
assert(HOoABm : rk(Oo :: A :: B ::  nil) >= 1) by (solve_hyps_min HOoABeq HOoABm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HCM : rk(C ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCeq HCM1).
assert(HCm : rk(C ::  nil) >= 1) by (solve_hyps_min HCeq HCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAC requis par la preuve de (?)OoAC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACm2 : rk(Oo :: A :: C :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACM2 : rk(Oo :: A :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoACM : rk(Oo :: A :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACeq HOoACM3).
assert(HOoACm : rk(Oo :: A :: C ::  nil) >= 1) by (solve_hyps_min HOoACeq HOoACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HBCM : rk(B :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCeq HBCM2).
assert(HBCm : rk(B :: C ::  nil) >= 1) by (solve_hyps_min HBCeq HBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBC requis par la preuve de (?)OoBC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCm2 : rk(Oo :: B :: C :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCM2 : rk(Oo :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HOoBCM : rk(Oo :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBCeq HOoBCM3).
assert(HOoBCm : rk(Oo :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoBCeq HOoBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABC : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCM2 : rk(A :: B :: C :: nil) <= 2).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: C :: nil) (Oo :: A :: B :: C :: nil) 2 2 HOoABCMtmp Hcomp Hincl);apply HT.
}


assert(HABCM : rk(A :: B :: C ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCeq HABCM3).
assert(HABCm : rk(A :: B :: C ::  nil) >= 1) by (solve_hyps_min HABCeq HABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HApM : rk(Ap ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HApeq HApM1).
assert(HApm : rk(Ap ::  nil) >= 1) by (solve_hyps_min HApeq HApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoAApM : rk(Oo :: A :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAApeq HOoAApM3).
assert(HOoAApm : rk(Oo :: A :: Ap ::  nil) >= 1) by (solve_hyps_min HOoAApeq HOoAApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: nil) ((Oo :: A :: B :: nil) ++ (Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Ap :: nil) (nil) 2 1 0 HOoABMtmp HApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Bp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HBpM : rk(Bp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBpeq HBpM1).
assert(HBpm : rk(Bp ::  nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoAApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoABCApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCp requis par la preuve de (?)OoAApBpCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoAApBpCpM3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (nil) 1 2 0 HAMtmp HOoApBpCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 3 1 2 HOoABCApBpCpmtmp HOomtmp HOoBCMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpCpM : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpm : rk(Oo :: A :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LOoApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoApBpCpM : rk(Oo :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpCpm : rk(Oo :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: nil) 3 1 2 HOoAApBpCpmtmp HBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpm2 : rk(Oo :: Ap :: Bp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpM2 : rk(Oo :: Ap :: Bp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpM : rk(Oo :: Ap :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApBpeq HOoApBpM3).
assert(HOoApBpm : rk(Oo :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoApBpeq HOoApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBp requis par la preuve de (?)OoAApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBp requis par la preuve de (?)OoAApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpm3 : rk(Oo :: A :: Ap :: Bp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpM3 : rk(Oo :: A :: Ap :: Bp :: nil) <= 3).
{
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpMtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoAApBpCpeq HOoAApBpCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpM : rk(Oo :: A :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpm : rk(Oo :: A :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoAApBpeq HOoAApBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBp *)
(* dans constructLemma(), requis par LOoACApBpCp *)
(* dans la couche 0 *)
Lemma LOoABCApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoABCApBpCpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((A :: B :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: nil) 3 1 2 HOoABCApBpCpmtmp HAmtmp HABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoACApBpCpM3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoACMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: C :: nil) 3 2 2 HOoABCApBpCpmtmp HACmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpm2 : rk(A :: C :: Ap :: Bp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Ap :: Bp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApBpm3 : rk(A :: C :: Ap :: Bp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: C :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: C :: Ap :: Bp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Bp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: C :: Ap :: Bp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: Bp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Ap :: Bp :: nil) 3 2 2 HOoACApBpCpmtmp HApBpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpM3 : rk(A :: C :: Ap :: Bp :: nil) <= 3).
{
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpMtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApBpCpeq HOoACApBpCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 3 3 HOoACApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HACApBpM : rk(A :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpm : rk(A :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HACApBpeq HACApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Cp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HCpM : rk(Cp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCpeq HCpM1).
assert(HCpm : rk(Cp ::  nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCp *)
(* dans la couche 0 *)
Lemma LOoACpU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Cp :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoACpUM : rk(Oo :: A :: Cp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpUm : rk(Oo :: A :: Cp :: U ::  nil) >= 1) by (solve_hyps_min HOoACpUeq HOoACpUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCp *)
(* dans la couche 0 *)
Lemma LOoAU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: U ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAU requis par la preuve de (?)OoAU pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpU requis par la preuve de (?)OoAU pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpU requis par la preuve de (?)OoAApBpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpUm3 : rk(Oo :: A :: Ap :: Bp :: U :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: U :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAU requis par la preuve de (?)OoAU pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: U ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoAUm2 : rk(Oo :: A :: U :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpUmtmp : rk(Oo :: A :: Ap :: Bp :: U :: nil) >= 3) by (solve_hyps_min HOoAApBpUeq HOoAApBpUm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: U :: nil) (Oo :: Ap :: Bp :: Oo :: A :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: U :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpUmtmp;try rewrite HT2 in HOoAApBpUmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: U :: nil) (Oo :: nil) 3 1 2 HOoAApBpUmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpUM1. try clear HOoAApBpUM2. try clear HOoAApBpUM3. try clear HOoAApBpUm4. try clear HOoAApBpUm3. try clear HOoAApBpUm2. try clear HOoAApBpUm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Cp :: U ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Cp ::   de rang : 1 et 1 *)
assert(HOoAUm3 : rk(Oo :: A :: U :: nil) >= 3).
{
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (Oo :: A :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: U :: nil) (Cp :: Oo :: A :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Oo :: A :: U :: nil) ((Cp :: nil) ++ (Oo :: A :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpUmtmp;try rewrite HT2 in HOoACpUmtmp.
	assert(HT := rule_4 (Cp :: nil) (Oo :: A :: U :: nil) (nil) 4 0 1 HOoACpUmtmp Hmtmp HCpMtmp Hincl); apply HT.
}


assert(HOoAUM : rk(Oo :: A :: U ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAUeq HOoAUM3).
assert(HOoAUm : rk(Oo :: A :: U ::  nil) >= 1) by (solve_hyps_min HOoAUeq HOoAUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoCp requis par la preuve de (?)OoCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpm2 : rk(Oo :: Cp :: nil) >= 2).
{
	try assert(HOoAUeq : rk(Oo :: A :: U :: nil) = 3) by (apply LOoAU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAUMtmp : rk(Oo :: A :: U :: nil) <= 3) by (solve_hyps_max HOoAUeq HOoAUM3).
	try assert(HOoACpUeq : rk(Oo :: A :: Cp :: U :: nil) = 4) by (apply LOoACpU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACpUmtmp : rk(Oo :: A :: Cp :: U :: nil) >= 4) by (solve_hyps_min HOoACpUeq HOoACpUm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Cp :: nil) (Oo :: A :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: U :: nil) (Oo :: Cp :: Oo :: A :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: Oo :: A :: U :: nil) ((Oo :: Cp :: nil) ++ (Oo :: A :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpUmtmp;try rewrite HT2 in HOoACpUmtmp.
	assert(HT := rule_2 (Oo :: Cp :: nil) (Oo :: A :: U :: nil) (Oo :: nil) 4 1 3 HOoACpUmtmp HOomtmp HOoAUMtmp Hincl);apply HT.
}
try clear HOoACpUM1. try clear HOoACpUM2. try clear HOoACpUM3. try clear HOoACpUm4. try clear HOoACpUm3. try clear HOoACpUm2. try clear HOoACpUm1. 

assert(HOoCpM : rk(Oo :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCpeq HOoCpM2).
assert(HOoCpm : rk(Oo :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCpeq HOoCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ACp requis par la preuve de (?)ACp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpm2 : rk(A :: Cp :: nil) >= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Cp :: nil) 3 1 2 HOoAApBpCpmtmp HCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HACpM : rk(A :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACpeq HACpM2).
assert(HACpm : rk(A :: Cp ::  nil) >= 1) by (solve_hyps_min HACpeq HACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCp requis par la preuve de (?)OoACp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCp requis par la preuve de (?)OoAApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpm3 : rk(Oo :: A :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApCp requis par la preuve de (?)OoACp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACp requis par la preuve de (?)OoACp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HOoACpm2 : rk(Oo :: A :: Cp :: nil) >= 2).
{
	assert(HApCpMtmp : rk(Ap :: Cp :: nil) <= 2) by (solve_hyps_max HApCpeq HApCpM2).
	assert(HOoAApCpmtmp : rk(Oo :: A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApCpeq HOoAApCpm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: A :: Cp :: nil) (Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: Cp :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: Ap :: Cp :: nil) ((Oo :: A :: Cp :: nil) ++ (Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpmtmp;try rewrite HT2 in HOoAApCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: nil) (Ap :: Cp :: nil) (Cp :: nil) 3 1 2 HOoAApCpmtmp HCpmtmp HApCpMtmp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpm3 : rk(Oo :: A :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoAApBpCpeq HOoAApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpmtmp;try rewrite HT2 in HOoAApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoAApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACpM : rk(Oo :: A :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoACpeq HOoACpM3).
assert(HOoACpm : rk(Oo :: A :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACpeq HOoACpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCp *)
(* dans la couche 0 *)
Lemma LOoABApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCp requis par la preuve de (?)OoABApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABApBpCpM3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoABMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoABApBpCpm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (A :: B :: nil) 3 2 2 HOoABCApBpCpmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoABApBpCpM : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpCpm : rk(Oo :: A :: B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABCpM3 : rk(Oo :: A :: B :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Cp :: nil) (nil) 2 1 0 HOoABMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCpm3 : rk(Oo :: A :: B :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoABApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABCpM : rk(Oo :: A :: B :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpm : rk(Oo :: A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCpeq HOoABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCp requis par la preuve de (?)OoACCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpm2 : rk(Oo :: A :: C :: Cp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Cp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACCpM3 : rk(Oo :: A :: C :: Cp :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: nil) (Oo :: A :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: nil) ((Oo :: A :: C :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (Cp :: nil) (nil) 2 1 0 HOoACMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACCpm3 : rk(Oo :: A :: C :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoACApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoACCpM : rk(Oo :: A :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpm : rk(Oo :: A :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACCpeq HOoACCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCCp *)
(* dans la couche 0 *)
Lemma LOoBCApBpCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpm2 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (A :: B :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil) ((A :: B :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (B :: nil) 3 1 2 HOoABCApBpCpmtmp HBmtmp HABMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBCApBpCpM3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: B :: C :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: nil) 2 2 1 HOoBCMtmp HOoApBpCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : B :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (A :: B :: C :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil) ((A :: B :: C :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (B :: C :: nil) 3 2 2 HOoABCApBpCpmtmp HBCmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoBCApBpCpM : rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpCpm : rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCCp requis par la preuve de (?)OoBCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCp requis par la preuve de (?)OoBCCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCp requis par la preuve de (?)OoBCCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCCpm2 : rk(Oo :: B :: C :: Cp :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Cp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBCCpM3 : rk(Oo :: B :: C :: Cp :: nil) <= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: C :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: nil) (Oo :: B :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Cp :: nil) ((Oo :: B :: C :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: nil) (Cp :: nil) (nil) 2 1 0 HOoBCMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBCCpm3 : rk(Oo :: B :: C :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBCApBpCpeq : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCApBpCpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: B :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: B :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpmtmp;try rewrite HT2 in HOoBCApBpCpmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoBCApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoBCCpM : rk(Oo :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCCpm : rk(Oo :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBCCpeq HOoBCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCp requis par la preuve de (?)OoABCCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABCpM3 : rk(Oo :: A :: B :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Cp :: nil) (nil) 2 1 0 HOoABMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpm2 : rk(Oo :: A :: B :: C :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABCCpM3 : rk(Oo :: A :: B :: C :: Cp :: nil) <= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (A :: B :: C :: Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: B :: Cp :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (Oo :: A :: B :: Cp :: nil) (A :: B :: nil) 2 3 2 HABCMtmp HOoABCpMtmp HABmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCCpm3 : rk(Oo :: A :: B :: C :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: B :: C :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: C :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Cp :: nil) 3 2 2 HOoABCApBpCpmtmp HOoCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


assert(HOoABCCpM : rk(Oo :: A :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpm : rk(Oo :: A :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCCpeq HOoABCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABCpM3 : rk(Oo :: A :: B :: Cp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: nil) ((Oo :: A :: B :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Cp :: nil) (nil) 2 1 0 HOoABMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 2 et 3 *)
assert(HOoApCpm2 : rk(Oo :: Ap :: Cp :: nil) >= 2).
{
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Cp :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: Ap :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Cp :: nil) (Oo :: Cp :: nil) 3 2 3 HOoABApCpmtmp HOoCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABApCpM1. try clear HOoABApCpM2. try clear HOoABApCpM3. try clear HOoABApCpm4. try clear HOoABApCpm3. try clear HOoABApCpm2. try clear HOoABApCpm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpM2 : rk(Oo :: Ap :: Cp :: nil) <= 2).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) 2 2 HOoApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpM : rk(Oo :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApCpeq HOoApCpM3).
assert(HOoApCpm : rk(Oo :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApCpeq HOoApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCp requis par la preuve de (?)OoAApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCp requis par la preuve de (?)OoAApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpm3 : rk(Oo :: A :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpM3 : rk(Oo :: A :: Ap :: Cp :: nil) <= 3).
{
	try assert(HOoAApBpCpeq : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoAApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpMtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoAApBpCpeq HOoAApBpCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Bp :: Cp :: nil) 3 3 HOoAApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HOoAApCpM : rk(Oo :: A :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpm : rk(Oo :: A :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoAApCpeq HOoAApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpm2 : rk(A :: B :: Ap :: Cp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Cp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApCpm3 : rk(A :: B :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApBpCpeq HOoABApBpCpm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) (A :: B :: Ap :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpmtmp;try rewrite HT2 in HOoABApBpCpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Ap :: Cp :: nil) 3 2 2 HOoABApBpCpmtmp HApCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpM3 : rk(A :: B :: Ap :: Cp :: nil) <= 3).
{
	try assert(HOoABApBpCpeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoABApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpMtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoABApBpCpeq HOoABApBpCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: nil) 3 3 HOoABApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HABApCpM : rk(A :: B :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpm : rk(A :: B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABApCpeq HABApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApCpm2 : rk(A :: C :: Ap :: Cp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Ap :: Cp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApCpm3 : rk(A :: C :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: C :: Ap :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Ap :: Cp :: nil) 3 2 2 HOoACApBpCpmtmp HApCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApCpM3 : rk(A :: C :: Ap :: Cp :: nil) <= 3).
{
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpMtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApBpCpeq HOoACApBpCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 3 3 HOoACApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HACApCpM : rk(A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApCpm : rk(A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HACApCpeq HACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCp requis par la preuve de (?)BCApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApCp requis par la preuve de (?)BCApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCp requis par la preuve de (?)BCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApCpm2 : rk(B :: C :: Ap :: Cp :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: Cp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCApCpm3 : rk(B :: C :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 2) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpCpMtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) <= 2) by (solve_hyps_max HOoApBpCpeq HOoApBpCpM2).
	try assert(HOoBCApBpCpeq : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCApBpCpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (B :: C :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (B :: C :: Ap :: Cp :: Oo :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: Cp :: Oo :: Ap :: Bp :: Cp :: nil) ((B :: C :: Ap :: Cp :: nil) ++ (Oo :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpmtmp;try rewrite HT2 in HOoBCApBpCpmtmp.
	assert(HT := rule_2 (B :: C :: Ap :: Cp :: nil) (Oo :: Ap :: Bp :: Cp :: nil) (Ap :: Cp :: nil) 3 2 2 HOoBCApBpCpmtmp HApCpmtmp HOoApBpCpMtmp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApCpM3 : rk(B :: C :: Ap :: Cp :: nil) <= 3).
{
	try assert(HOoBCApBpCpeq : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) = 3) by (apply LOoBCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCApBpCpMtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoBCApBpCpeq HOoBCApBpCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: Cp :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: C :: Ap :: Cp :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) 3 3 HOoBCApBpCpMtmp Hcomp Hincl);apply HT.
}


assert(HBCApCpM : rk(B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpm : rk(B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HBCApCpeq HBCApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(X ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HXM : rk(X ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HXeq HXM1).
assert(HXm : rk(X ::  nil) >= 1) by (solve_hyps_min HXeq HXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApX *)
(* dans constructLemma(), requis par LAApBpX *)
(* dans constructLemma(), requis par LOoAApBpX *)
(* dans la couche 0 *)
Lemma LABpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HABpXM : rk(A :: Bp :: X ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABpXeq HABpXM3).
assert(HABpXm : rk(A :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HABpXeq HABpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXm3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoAApBpXM3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Ap :: Bp :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Bp :: X :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: nil) (Bp :: nil) 2 2 1 HOoApBpMtmp HABpXMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoAApBpXM : rk(Oo :: A :: Ap :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpXm : rk(Oo :: A :: Ap :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Ap :: Bp :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBpX requis par la preuve de (?)AApBpX pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)AApBpX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXm3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoBp requis par la preuve de (?)AApBpX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBpX requis par la preuve de (?)AApBpX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpX requis par la preuve de (?)AApBpX pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApBpXM3 : rk(A :: Ap :: Bp :: X :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: X :: nil) (Ap :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: Bp :: X :: nil) ((Ap :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: Bp :: X :: nil) (nil) 1 2 0 HApMtmp HABpXMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Bp ::   de rang : 1 et 2 *)
assert(HAApBpXm2 : rk(A :: Ap :: Bp :: X :: nil) >= 2).
{
	assert(HOoBpMtmp : rk(Oo :: Bp :: nil) <= 2) by (solve_hyps_max HOoBpeq HOoBpM2).
	assert(HOoAApBpXmtmp : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Bp :: nil) (A :: Ap :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Bp :: A :: Ap :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: A :: Ap :: Bp :: X :: nil) ((Oo :: Bp :: nil) ++ (A :: Ap :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXmtmp;try rewrite HT2 in HOoAApBpXmtmp.
	assert(HT := rule_4 (Oo :: Bp :: nil) (A :: Ap :: Bp :: X :: nil) (Bp :: nil) 3 1 2 HOoAApBpXmtmp HBpmtmp HOoBpMtmp Hincl); apply HT.
}
try clear HOoBpM1. try clear HOoBpM2. try clear HOoBpM3. try clear HOoBpm4. try clear HOoBpm3. try clear HOoBpm2. try clear HOoBpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X ::  de rang :  3 et 3 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApBpXm3 : rk(A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpXeq : rk(Oo :: A :: Ap :: Bp :: X :: nil) = 3) by (apply LOoAApBpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpXmtmp : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Bp :: X :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXmtmp;try rewrite HT2 in HOoAApBpXmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Bp :: X :: nil) (Ap :: Bp :: nil) 3 2 2 HOoAApBpXmtmp HApBpmtmp HOoApBpMtmp Hincl); apply HT.
}


assert(HAApBpXM : rk(A :: Ap :: Bp :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpXm : rk(A :: Ap :: Bp :: X ::  nil) >= 1) by (solve_hyps_min HAApBpXeq HAApBpXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApX requis par la preuve de (?)ApX pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApXm2 : rk(Ap :: X :: nil) >= 2).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HAApBpXeq : rk(A :: Ap :: Bp :: X :: nil) = 3) by (apply LAApBpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAApBpXmtmp : rk(A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HAApBpXeq HAApBpXm3).
	try assert(HXeq : rk(X :: nil) = 1) by (apply LX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HXmtmp : rk(X :: nil) >= 1) by (solve_hyps_min HXeq HXm1).
	assert(Hincl : incl (X :: nil) (list_inter (Ap :: X :: nil) (A :: Bp :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: X :: nil) (Ap :: X :: A :: Bp :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: X :: A :: Bp :: X :: nil) ((Ap :: X :: nil) ++ (A :: Bp :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpXmtmp;try rewrite HT2 in HAApBpXmtmp.
	assert(HT := rule_2 (Ap :: X :: nil) (A :: Bp :: X :: nil) (X :: nil) 3 1 2 HAApBpXmtmp HXmtmp HABpXMtmp Hincl);apply HT.
}
try clear HXM1. try clear HXM2. try clear HXM3. try clear HXm4. try clear HXm3. try clear HXm2. try clear HXm1. 

assert(HApXM : rk(Ap :: X ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApXeq HApXM2).
assert(HApXm : rk(Ap :: X ::  nil) >= 1) by (solve_hyps_min HApXeq HApXm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApX *)
(* dans la couche 0 *)
Lemma LOoABApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApX requis par la preuve de (?)OoABApX pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BApX requis par la preuve de (?)OoABApX pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApX requis par la preuve de (?)OoABApX pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApX requis par la preuve de (?)OoABApX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXm2 : rk(Oo :: A :: B :: Ap :: X :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABApXM3 : rk(Oo :: A :: B :: Ap :: X :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: nil) (Oo :: A :: B :: B :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: Ap :: X :: nil) ((Oo :: A :: B :: nil) ++ (B :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (B :: Ap :: X :: nil) (B :: nil) 2 2 1 HOoABMtmp HBApXMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXm3 : rk(Oo :: A :: B :: Ap :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApXM : rk(Oo :: A :: B :: Ap :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApXm : rk(Oo :: A :: B :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HOoABApXeq HOoABApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: X ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApX requis par la preuve de (?)OoAApX pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApX requis par la preuve de (?)OoAApX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXm3 : rk(Oo :: A :: Ap :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApXM3 : rk(Oo :: A :: Ap :: X :: nil) <= 3).
{
	try assert(HOoABApXeq : rk(Oo :: A :: B :: Ap :: X :: nil) = 3) by (apply LOoABApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApXMtmp : rk(Oo :: A :: B :: Ap :: X :: nil) <= 3) by (solve_hyps_max HOoABApXeq HOoABApXM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: X :: nil) (Oo :: A :: B :: Ap :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: Ap :: X :: nil) (Oo :: A :: B :: Ap :: X :: nil) 3 3 HOoABApXMtmp Hcomp Hincl);apply HT.
}


assert(HOoAApXM : rk(Oo :: A :: Ap :: X ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApXm : rk(Oo :: A :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HOoAApXeq HOoAApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApX : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: Ap :: X ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HBApXM : rk(B :: Ap :: X ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApXeq HBApXM3).
assert(HBApXm : rk(B :: Ap :: X ::  nil) >= 1) by (solve_hyps_min HBApXeq HBApXm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Y ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HYM : rk(Y ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HYeq HYM1).
assert(HYm : rk(Y ::  nil) >= 1) by (solve_hyps_min HYeq HYm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApY *)
(* dans constructLemma(), requis par LAApCpY *)
(* dans constructLemma(), requis par LOoAApCpY *)
(* dans la couche 0 *)
Lemma LACpY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HACpYM : rk(A :: Cp :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpYeq HACpYM3).
assert(HACpYm : rk(A :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HACpYeq HACpYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpY requis par la preuve de (?)OoAApCpY pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpY requis par la preuve de (?)OoAApCpY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpYm3 : rk(Oo :: A :: Ap :: Cp :: Y :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Y :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoAApCpYM3 : rk(Oo :: A :: Ap :: Cp :: Y :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Y :: nil) (Oo :: Ap :: Cp :: A :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Cp :: Y :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (A :: Cp :: Y :: nil) (Cp :: nil) 2 2 1 HOoApCpMtmp HACpYMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoAApCpYM : rk(Oo :: A :: Ap :: Cp :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpYm : rk(Oo :: A :: Ap :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HOoAApCpYeq HOoAApCpYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Ap :: Cp :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApCpY requis par la preuve de (?)AApCpY pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpCpY requis par la preuve de (?)AApCpY pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCpY requis par la preuve de (?)OoAApBpCpY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpCpYm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: Y :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Y :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApCpY requis par la preuve de (?)AApCpY pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpY requis par la preuve de (?)AApCpY pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApCpYM3 : rk(A :: Ap :: Cp :: Y :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: Y :: nil) (Ap :: A :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: Cp :: Y :: nil) ((Ap :: nil) ++ (A :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: Cp :: Y :: nil) (nil) 1 2 0 HApMtmp HACpYMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: Y ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApCpYm2 : rk(A :: Ap :: Cp :: Y :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpCpYmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: Y :: nil) >= 3) by (solve_hyps_min HOoAApBpCpYeq HOoAApBpCpYm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: Y :: nil) (Oo :: Ap :: Bp :: A :: Ap :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: Cp :: Y :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpYmtmp;try rewrite HT2 in HOoAApBpCpYmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: Cp :: Y :: nil) (Ap :: nil) 3 1 2 HOoAApBpCpYmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpCpYM1. try clear HOoAApBpCpYM2. try clear HOoAApBpCpYM3. try clear HOoAApBpCpYm4. try clear HOoAApBpCpYm3. try clear HOoAApBpCpYm2. try clear HOoAApBpCpYm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: Y ::  de rang :  3 et 3 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HAApCpYm3 : rk(A :: Ap :: Cp :: Y :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpYeq : rk(Oo :: A :: Ap :: Cp :: Y :: nil) = 3) by (apply LOoAApCpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApCpYmtmp : rk(Oo :: A :: Ap :: Cp :: Y :: nil) >= 3) by (solve_hyps_min HOoAApCpYeq HOoAApCpYm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Y :: nil) (Oo :: Ap :: Cp :: A :: Ap :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Ap :: Cp :: Y :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Ap :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpYmtmp;try rewrite HT2 in HOoAApCpYmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Y :: nil) (Ap :: Cp :: nil) 3 2 2 HOoAApCpYmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HAApCpYM : rk(A :: Ap :: Cp :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpYm : rk(A :: Ap :: Cp :: Y ::  nil) >= 1) by (solve_hyps_min HAApCpYeq HAApCpYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApY requis par la preuve de (?)ApY pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApYm2 : rk(Ap :: Y :: nil) >= 2).
{
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	try assert(HAApCpYeq : rk(A :: Ap :: Cp :: Y :: nil) = 3) by (apply LAApCpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAApCpYmtmp : rk(A :: Ap :: Cp :: Y :: nil) >= 3) by (solve_hyps_min HAApCpYeq HAApCpYm3).
	try assert(HYeq : rk(Y :: nil) = 1) by (apply LY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HYmtmp : rk(Y :: nil) >= 1) by (solve_hyps_min HYeq HYm1).
	assert(Hincl : incl (Y :: nil) (list_inter (Ap :: Y :: nil) (A :: Cp :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: Y :: nil) (Ap :: Y :: A :: Cp :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Y :: A :: Cp :: Y :: nil) ((Ap :: Y :: nil) ++ (A :: Cp :: Y :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpYmtmp;try rewrite HT2 in HAApCpYmtmp.
	assert(HT := rule_2 (Ap :: Y :: nil) (A :: Cp :: Y :: nil) (Y :: nil) 3 1 2 HAApCpYmtmp HYmtmp HACpYMtmp Hincl);apply HT.
}
try clear HYM1. try clear HYM2. try clear HYM3. try clear HYm4. try clear HYm3. try clear HYm2. try clear HYm1. 

assert(HApYM : rk(Ap :: Y ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApYeq HApYM2).
assert(HApYm : rk(Ap :: Y ::  nil) >= 1) by (solve_hyps_min HApYeq HApYm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApY *)
(* dans la couche 0 *)
Lemma LOoACApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApY requis par la preuve de (?)OoACApY pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CApY requis par la preuve de (?)OoACApY pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApY requis par la preuve de (?)OoACApY pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApY requis par la preuve de (?)OoACApY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYm2 : rk(Oo :: A :: C :: Ap :: Y :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Ap :: Y :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoACApYM3 : rk(Oo :: A :: C :: Ap :: Y :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: nil) (C :: Ap :: Y :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: nil) (Oo :: A :: C :: C :: Ap :: Y :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: C :: Ap :: Y :: nil) ((Oo :: A :: C :: nil) ++ (C :: Ap :: Y :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (C :: Ap :: Y :: nil) (C :: nil) 2 2 1 HOoACMtmp HCApYMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYm3 : rk(Oo :: A :: C :: Ap :: Y :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApYM : rk(Oo :: A :: C :: Ap :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApYm : rk(Oo :: A :: C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HOoACApYeq HOoACApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Y ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApY requis par la preuve de (?)OoAApY pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApY requis par la preuve de (?)OoAApY pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYm3 : rk(Oo :: A :: Ap :: Y :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Y :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApYM3 : rk(Oo :: A :: Ap :: Y :: nil) <= 3).
{
	try assert(HOoACApYeq : rk(Oo :: A :: C :: Ap :: Y :: nil) = 3) by (apply LOoACApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApYMtmp : rk(Oo :: A :: C :: Ap :: Y :: nil) <= 3) by (solve_hyps_max HOoACApYeq HOoACApYM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: Y :: nil) (Oo :: A :: C :: Ap :: Y :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: A :: Ap :: Y :: nil) (Oo :: A :: C :: Ap :: Y :: nil) 3 3 HOoACApYMtmp Hcomp Hincl);apply HT.
}


assert(HOoAApYM : rk(Oo :: A :: Ap :: Y ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApYm : rk(Oo :: A :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HOoAApYeq HOoAApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApY : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: Ap :: Y ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HCApYM : rk(C :: Ap :: Y ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApYeq HCApYM3).
assert(HCApYm : rk(C :: Ap :: Y ::  nil) >= 1) by (solve_hyps_min HCApYeq HCApYm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(M ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HMM : rk(M ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HMeq HMM1).
assert(HMm : rk(M ::  nil) >= 1) by (solve_hyps_min HMeq HMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBM *)
(* dans constructLemma(), requis par LABApCpM *)
(* dans constructLemma(), requis par LOoABApCpM *)
(* dans constructLemma(), requis par LOoABApBpCpM *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoABCApBpCpMM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpMm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpCpM requis par la preuve de (?)OoABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCpM requis par la preuve de (?)OoABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCpM requis par la preuve de (?)OoABApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpMm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApBpCpMm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (C :: Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) (nil) 4 0 1 HOoABCApBpCpMmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoABApBpCpMm4 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoABApBpCpMM : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpCpMm : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoABApBpCpMeq HOoABApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpM requis par la preuve de (?)OoABApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpM requis par la preuve de (?)OoABApCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpM requis par la preuve de (?)OoABApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpMm2 : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpMm3 : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoABApCpMm4 : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	try assert(HOoABApBpCpMeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpMmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApBpCpMeq HOoABApBpCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: B :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: B :: Ap :: Cp :: M :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: B :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpMmtmp;try rewrite HT2 in HOoABApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABApBpCpMmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}


assert(HOoABApCpMM : rk(Oo :: A :: B :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpMm : rk(Oo :: A :: B :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoABApCpMeq HOoABApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpM requis par la preuve de (?)ABApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpMm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpMm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApBpCpMm2 : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABApBpCpMm3 : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (C :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Ap :: Bp :: Cp :: M :: nil) ((C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil) (nil) 4 0 1 HABCApBpCpMmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABApBpCpMm4 : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HABCApBpCpMmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpM requis par la preuve de (?)ABApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpM requis par la preuve de (?)ABApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpMm2 : rk(A :: B :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HABApCpMm3 : rk(A :: B :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HABApBpCpMmtmp : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABApBpCpMeq HABApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: B :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: Cp :: M :: nil) (Bp :: A :: B :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: B :: Ap :: Cp :: M :: nil) ((Bp :: nil) ++ (A :: B :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpCpMmtmp;try rewrite HT2 in HABApBpCpMmtmp.
	assert(HT := rule_4 (Bp :: nil) (A :: B :: Ap :: Cp :: M :: nil) (nil) 4 0 1 HABApBpCpMmtmp Hmtmp HBpMtmp Hincl); apply HT.
}
try clear HABApBpCpMM1. try clear HABApBpCpMM2. try clear HABApBpCpMM3. try clear HABApBpCpMm4. try clear HABApBpCpMm3. try clear HABApBpCpMm2. try clear HABApBpCpMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HABApCpMm4 : rk(A :: B :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoABApCpMeq : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApCpMmtmp : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApCpMeq HOoABApCpMm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: A :: B :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: B :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: B :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpMmtmp;try rewrite HT2 in HOoABApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: M :: nil) (Ap :: Cp :: nil) 4 2 2 HOoABApCpMmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HABApCpMM : rk(A :: B :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpMm : rk(A :: B :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HABApCpMeq HABApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BM requis par la preuve de (?)BM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBMm2 : rk(B :: M :: nil) >= 2).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 3) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpMtmp : rk(A :: B :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HABApCpeq HABApCpM3).
	try assert(HABApCpMeq : rk(A :: B :: Ap :: Cp :: M :: nil) = 4) by (apply LABApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpMmtmp : rk(A :: B :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABApCpMeq HABApCpMm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (B :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: M :: nil) (A :: B :: Ap :: Cp :: B :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: B :: M :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (B :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpMmtmp;try rewrite HT2 in HABApCpMmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Cp :: nil) (B :: M :: nil) (B :: nil) 4 1 3 HABApCpMmtmp HBmtmp HABApCpMtmp Hincl); apply HT.
}


assert(HBMM : rk(B :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBMeq HBMM2).
assert(HBMm : rk(B :: M ::  nil) >= 1) by (solve_hyps_min HBMeq HBMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABM requis par la preuve de (?)ABM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABM requis par la preuve de (?)ABM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABMm2 : rk(A :: B :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HABMm3 : rk(A :: B :: M :: nil) >= 3).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 3) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpMtmp : rk(A :: B :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HABApCpeq HABApCpM3).
	try assert(HABApCpMeq : rk(A :: B :: Ap :: Cp :: M :: nil) = 4) by (apply LABApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpMmtmp : rk(A :: B :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABApCpMeq HABApCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (A :: B :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: M :: nil) (A :: B :: Ap :: Cp :: A :: B :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: A :: B :: M :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (A :: B :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpMmtmp;try rewrite HT2 in HABApCpMmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Cp :: nil) (A :: B :: M :: nil) (A :: B :: nil) 4 2 3 HABApCpMmtmp HABmtmp HABApCpMtmp Hincl); apply HT.
}


assert(HABMM : rk(A :: B :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABMeq HABMM3).
assert(HABMm : rk(A :: B :: M ::  nil) >= 1) by (solve_hyps_min HABMeq HABMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABM requis par la preuve de (?)OoABM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABM requis par la preuve de (?)OoABM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABM requis par la preuve de (?)OoABM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABMm2 : rk(Oo :: A :: B :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABMM3 : rk(Oo :: A :: B :: M :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: M :: nil) (Oo :: A :: B :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: nil) ((Oo :: A :: B :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (M :: nil) (nil) 2 1 0 HOoABMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoABMm3 : rk(Oo :: A :: B :: M :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoABApCpMeq : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApCpMmtmp : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApCpMeq HOoABApCpMm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: B :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: Oo :: A :: B :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: B :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: B :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpMmtmp;try rewrite HT2 in HOoABApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: B :: M :: nil) (Oo :: nil) 4 1 2 HOoABApCpMmtmp HOomtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoABMM : rk(Oo :: A :: B :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABMm : rk(Oo :: A :: B :: M ::  nil) >= 1) by (solve_hyps_min HOoABMeq HOoABMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCM *)
(* dans constructLemma(), requis par LACApCpM *)
(* dans constructLemma(), requis par LOoACApCpM *)
(* dans la couche 0 *)
Lemma LOoACApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpM requis par la preuve de (?)OoACApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpM requis par la preuve de (?)OoACApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoACApBpCpMm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 4 1 2 HOoABCApBpCpMmtmp HAmtmp HABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoACApBpCpMm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: C :: nil) 4 2 2 HOoABCApBpCpMmtmp HACmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoACApBpCpMM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpMm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpMeq HOoACApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApCpM requis par la preuve de (?)OoACApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCpM requis par la preuve de (?)OoACApCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCpM requis par la preuve de (?)OoACApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpMm2 : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpMm3 : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApCpMm4 : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	try assert(HOoACApBpCpMeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoACApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpMmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApBpCpMeq HOoACApBpCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: C :: Ap :: Cp :: M :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpMmtmp;try rewrite HT2 in HOoACApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoACApBpCpMmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}


assert(HOoACApCpMM : rk(Oo :: A :: C :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpMm : rk(Oo :: A :: C :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoACApCpMeq HOoACApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApCpM requis par la preuve de (?)ACApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpMm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpMm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApBpCpMm3 : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 4 1 2 HOoABCApBpCpMmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HACApBpCpMm4 : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: C :: nil) 4 2 2 HABCApBpCpMmtmp HACmtmp HABCMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApCpM requis par la preuve de (?)ACApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApCpM requis par la preuve de (?)ACApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApCpMm2 : rk(A :: C :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Ap :: Cp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HACApCpMm3 : rk(A :: C :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HACApBpCpMmtmp : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACApBpCpMeq HACApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: M :: nil) (Bp :: A :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: C :: Ap :: Cp :: M :: nil) ((Bp :: nil) ++ (A :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpMmtmp;try rewrite HT2 in HACApBpCpMmtmp.
	assert(HT := rule_4 (Bp :: nil) (A :: C :: Ap :: Cp :: M :: nil) (nil) 4 0 1 HACApBpCpMmtmp Hmtmp HBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HACApCpMm4 : rk(A :: C :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoACApCpMeq : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApCpMmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApCpMeq HOoACApCpMm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: A :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: C :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMmtmp;try rewrite HT2 in HOoACApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: C :: Ap :: Cp :: M :: nil) (Ap :: Cp :: nil) 4 2 2 HOoACApCpMmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HACApCpMM : rk(A :: C :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApCpMm : rk(A :: C :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACApCpMeq HACApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CM requis par la preuve de (?)CM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HCMm2 : rk(C :: M :: nil) >= 2).
{
	try assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	try assert(HACApCpMeq : rk(A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACApCpMmtmp : rk(A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACApCpMeq HACApCpMm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (C :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Cp :: M :: nil) (A :: C :: Ap :: Cp :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: C :: M :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (C :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApCpMmtmp;try rewrite HT2 in HACApCpMmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (C :: M :: nil) (C :: nil) 4 1 3 HACApCpMmtmp HCmtmp HACApCpMtmp Hincl); apply HT.
}


assert(HCMM : rk(C :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCMeq HCMM2).
assert(HCMm : rk(C :: M ::  nil) >= 1) by (solve_hyps_min HCMeq HCMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACM requis par la preuve de (?)ACM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACMm2 : rk(A :: C :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HACMm3 : rk(A :: C :: M :: nil) >= 3).
{
	try assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	try assert(HACApCpMeq : rk(A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACApCpMmtmp : rk(A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACApCpMeq HACApCpMm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (A :: C :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Cp :: M :: nil) (A :: C :: Ap :: Cp :: A :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: A :: C :: M :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (A :: C :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApCpMmtmp;try rewrite HT2 in HACApCpMmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (A :: C :: M :: nil) (A :: C :: nil) 4 2 3 HACApCpMmtmp HACmtmp HACApCpMtmp Hincl); apply HT.
}


assert(HACMM : rk(A :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACMeq HACMM3).
assert(HACMm : rk(A :: C :: M ::  nil) >= 1) by (solve_hyps_min HACMeq HACMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACM requis par la preuve de (?)OoACM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACM requis par la preuve de (?)OoACM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACM requis par la preuve de (?)OoACM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACMm2 : rk(Oo :: A :: C :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACMM3 : rk(Oo :: A :: C :: M :: nil) <= 3).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: C :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: M :: nil) (Oo :: A :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: M :: nil) ((Oo :: A :: C :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: C :: nil) (M :: nil) (nil) 2 1 0 HOoACMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoACMm3 : rk(Oo :: A :: C :: M :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoACApCpMeq : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApCpMmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApCpMeq HOoACApCpMm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: C :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: Oo :: A :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: C :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMmtmp;try rewrite HT2 in HOoACApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: C :: M :: nil) (Oo :: nil) 4 1 2 HOoACApCpMmtmp HOomtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoACMM : rk(Oo :: A :: C :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACMm : rk(Oo :: A :: C :: M ::  nil) >= 1) by (solve_hyps_min HOoACMeq HOoACMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCM *)
(* dans constructLemma(), requis par LBCApCpM *)
(* dans constructLemma(), requis par LOoBCApCpM *)
(* dans la couche 0 *)
Lemma LOoABCApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApCpM requis par la preuve de (?)OoABCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApCpM requis par la preuve de (?)OoABCApCpM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpM requis par la preuve de (?)OoABCApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpMm2 : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpMm3 : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoABCApCpMm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABCApBpCpMmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}


assert(HOoABCApCpMM : rk(Oo :: A :: B :: C :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpMm : rk(Oo :: A :: B :: C :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoABCApCpMeq HOoABCApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApCpM requis par la preuve de (?)OoBCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpCpM requis par la preuve de (?)OoBCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpM requis par la preuve de (?)OoBCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpM requis par la preuve de (?)OoBCApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpMm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: nil) 4 1 2 HOoABCApBpCpMmtmp HBmtmp HABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpMm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (A :: B :: C :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: C :: nil) 4 2 2 HOoABCApBpCpMmtmp HBCmtmp HABCMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApCpM requis par la preuve de (?)OoBCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApCpM requis par la preuve de (?)OoBCApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApCpMm2 : rk(Oo :: B :: C :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Ap :: Cp :: M :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoBCApCpMm3 : rk(Oo :: B :: C :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HOoBCApBpCpMmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpMeq HOoBCApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Bp :: Oo :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: B :: C :: Ap :: Cp :: M :: nil) ((Bp :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpMmtmp;try rewrite HT2 in HOoBCApBpCpMmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: B :: C :: Ap :: Cp :: M :: nil) (nil) 4 0 1 HOoBCApBpCpMmtmp Hmtmp HBpMtmp Hincl); apply HT.
}
try clear HOoBCApBpCpMM1. try clear HOoBCApBpCpMM2. try clear HOoBCApBpCpMM3. try clear HOoBCApBpCpMm4. try clear HOoBCApBpCpMm3. try clear HOoBCApBpCpMm2. try clear HOoBCApBpCpMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: B :: C :: Cp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Cp ::   de rang : 3 et 3 *)
assert(HOoBCApCpMm4 : rk(Oo :: B :: C :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 3) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCCpMtmp : rk(Oo :: A :: B :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCCpeq HOoABCCpM3).
	try assert(HOoABCApCpMeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApCpMeq HOoABCApCpMm4).
	try assert(HOoBCCpeq : rk(Oo :: B :: C :: Cp :: nil) = 3) by (apply LOoBCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCCpmtmp : rk(Oo :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HOoBCCpeq HOoBCCpm3).
	assert(Hincl : incl (Oo :: B :: C :: Cp :: nil) (list_inter (Oo :: A :: B :: C :: Cp :: nil) (Oo :: B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: B :: C :: Cp :: Oo :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Cp :: Oo :: B :: C :: Ap :: Cp :: M :: nil) ((Oo :: A :: B :: C :: Cp :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpMmtmp;try rewrite HT2 in HOoABCApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Cp :: nil) (Oo :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: B :: C :: Cp :: nil) 4 3 3 HOoABCApCpMmtmp HOoBCCpmtmp HOoABCCpMtmp Hincl); apply HT.
}


assert(HOoBCApCpMM : rk(Oo :: B :: C :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApCpMm : rk(Oo :: B :: C :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoBCApCpMeq HOoBCApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpM requis par la preuve de (?)BCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCApBpCpM requis par la preuve de (?)BCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)BCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpMm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpMm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBpCpM requis par la preuve de (?)BCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBpCpM requis par la preuve de (?)BCApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApBpCpMm3 : rk(B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: nil) 4 1 2 HOoABCApBpCpMmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HBCApBpCpMm4 : rk(B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (A :: B :: C :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: C :: nil) 4 2 2 HABCApBpCpMmtmp HBCmtmp HABCMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApCpM requis par la preuve de (?)BCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpM requis par la preuve de (?)BCApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApCpMm2 : rk(B :: C :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: Cp :: M :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HBCApCpMm3 : rk(B :: C :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HBCApBpCpMmtmp : rk(B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HBCApBpCpMeq HBCApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: Cp :: M :: nil) (Bp :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: C :: Ap :: Cp :: M :: nil) ((Bp :: nil) ++ (B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpCpMmtmp;try rewrite HT2 in HBCApBpCpMmtmp.
	assert(HT := rule_4 (Bp :: nil) (B :: C :: Ap :: Cp :: M :: nil) (nil) 4 0 1 HBCApBpCpMmtmp Hmtmp HBpMtmp Hincl); apply HT.
}
try clear HBCApBpCpMM1. try clear HBCApBpCpMM2. try clear HBCApBpCpMM3. try clear HBCApBpCpMm4. try clear HBCApBpCpMm3. try clear HBCApBpCpMm2. try clear HBCApBpCpMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HBCApCpMm4 : rk(B :: C :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoBCApCpMeq : rk(Oo :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoBCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCApCpMmtmp : rk(Oo :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoBCApCpMeq HOoBCApCpMm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: B :: C :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApCpMmtmp;try rewrite HT2 in HOoBCApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: M :: nil) (Ap :: Cp :: nil) 4 2 2 HOoBCApCpMmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HBCApCpMM : rk(B :: C :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpMm : rk(B :: C :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HBCApCpMeq HBCApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCM requis par la preuve de (?)BCM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCM requis par la preuve de (?)BCM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCMm2 : rk(B :: C :: M :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: M :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : B :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBCMm3 : rk(B :: C :: M :: nil) >= 3).
{
	try assert(HBCApCpeq : rk(B :: C :: Ap :: Cp :: nil) = 3) by (apply LBCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApCpMtmp : rk(B :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HBCApCpeq HBCApCpM3).
	try assert(HBCApCpMeq : rk(B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LBCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApCpMmtmp : rk(B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HBCApCpMeq HBCApCpMm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (B :: C :: Ap :: Cp :: nil) (B :: C :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: M :: nil) (B :: C :: Ap :: Cp :: B :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: Cp :: B :: C :: M :: nil) ((B :: C :: Ap :: Cp :: nil) ++ (B :: C :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpMmtmp;try rewrite HT2 in HBCApCpMmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: Cp :: nil) (B :: C :: M :: nil) (B :: C :: nil) 4 2 3 HBCApCpMmtmp HBCmtmp HBCApCpMtmp Hincl); apply HT.
}


assert(HBCMM : rk(B :: C :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCMeq HBCMM3).
assert(HBCMm : rk(B :: C :: M ::  nil) >= 1) by (solve_hyps_min HBCMeq HBCMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCM *)
(* dans la couche 0 *)
Lemma LABCApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpM requis par la preuve de (?)ABCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpMm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpMm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpM requis par la preuve de (?)ABCApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpM requis par la preuve de (?)ABCApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApCpMm2 : rk(A :: B :: C :: Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HABCApCpMm3 : rk(A :: B :: C :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Bp :: A :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: B :: C :: Ap :: Cp :: M :: nil) ((Bp :: nil) ++ (A :: B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (Bp :: nil) (A :: B :: C :: Ap :: Cp :: M :: nil) (nil) 4 0 1 HABCApBpCpMmtmp Hmtmp HBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HABCApCpMm4 : rk(A :: B :: C :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoABCApCpMeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApCpMeq HOoABCApCpMm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: B :: C :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: A :: B :: C :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: B :: C :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: B :: C :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpMmtmp;try rewrite HT2 in HOoABCApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: B :: C :: Ap :: Cp :: M :: nil) (Ap :: Cp :: nil) 4 2 2 HOoABCApCpMmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HABCApCpMM : rk(A :: B :: C :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpMm : rk(A :: B :: C :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HABCApCpMeq HABCApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: C :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCM requis par la preuve de (?)ABCM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCM requis par la preuve de (?)ABCM pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCM requis par la preuve de (?)ABCM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCMm2 : rk(A :: B :: C :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABCMM3 : rk(A :: B :: C :: M :: nil) <= 3).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: C :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: M :: nil) (A :: B :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: M :: nil) ((A :: B :: C :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: C :: nil) (M :: nil) (nil) 2 1 0 HABCMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HABCMm3 : rk(A :: B :: C :: M :: nil) >= 3).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 3) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpMtmp : rk(A :: B :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HABApCpeq HABApCpM3).
	try assert(HABCApCpMeq : rk(A :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LABCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApCpMmtmp : rk(A :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApCpMeq HABCApCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (A :: B :: C :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: M :: nil) (A :: B :: Ap :: Cp :: A :: B :: C :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: A :: B :: C :: M :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (A :: B :: C :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpMmtmp;try rewrite HT2 in HABCApCpMmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Cp :: nil) (A :: B :: C :: M :: nil) (A :: B :: nil) 4 2 3 HABCApCpMmtmp HABmtmp HABApCpMtmp Hincl); apply HT.
}


assert(HABCMM : rk(A :: B :: C :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCMm : rk(A :: B :: C :: M ::  nil) >= 1) by (solve_hyps_min HABCMeq HABCMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApM *)
(* dans la couche 0 *)
Lemma LOoAApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoAApMM : rk(Oo :: A :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMm : rk(Oo :: A :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoAApMeq HOoAApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: M ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApM requis par la preuve de (?)ApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: M ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 3 et 3 *)
assert(HApMm2 : rk(Ap :: M :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 3) by (solve_hyps_max HOoAApeq HOoAApM3).
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Ap :: M :: nil) ((Oo :: A :: Ap :: nil) ++ (Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMmtmp;try rewrite HT2 in HOoAApMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Ap :: M :: nil) (Ap :: nil) 4 1 3 HOoAApMmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HApMM : rk(Ap :: M ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApMeq HApMM2).
assert(HApMm : rk(Ap :: M ::  nil) >= 1) by (solve_hyps_min HApMeq HApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApM *)
(* dans la couche 0 *)
Lemma LOoABApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApM requis par la preuve de (?)OoABApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm2 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMm3 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoABApMm4 : rk(Oo :: A :: B :: Ap :: M :: nil) >= 4).
{
	try assert(HOoAApCpeq : rk(Oo :: A :: Ap :: Cp :: nil) = 3) by (apply LOoAApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApCpMtmp : rk(Oo :: A :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoAApCpeq HOoAApCpM3).
	try assert(HOoABApCpMeq : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApCpMmtmp : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApCpMeq HOoABApCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: Cp :: Oo :: A :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Cp :: Oo :: A :: B :: Ap :: M :: nil) ((Oo :: A :: Ap :: Cp :: nil) ++ (Oo :: A :: B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpMmtmp;try rewrite HT2 in HOoABApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABApCpMmtmp HOoAApmtmp HOoAApCpMtmp Hincl); apply HT.
}


assert(HOoABApMM : rk(Oo :: A :: B :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMm : rk(Oo :: A :: B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoABApMeq HOoABApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApM requis par la preuve de (?)BApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApM requis par la preuve de (?)BApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HBApMm2 : rk(B :: Ap :: M :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	try assert(HOoABApCpMeq : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApCpMmtmp : rk(Oo :: A :: B :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApCpMeq HOoABApCpMm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: B :: Ap :: M :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpMmtmp;try rewrite HT2 in HOoABApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (B :: Ap :: M :: nil) (B :: nil) 4 1 3 HOoABApCpMmtmp HBmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: M ::  de rang :  4 et 4 	 AiB : B :: M ::  de rang :  2 et 2 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HBApMm3 : rk(B :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	try assert(HOoABApMeq : rk(Oo :: A :: B :: Ap :: M :: nil) = 4) by (apply LOoABApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApMmtmp : rk(Oo :: A :: B :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoABApMeq HOoABApMm4).
	try assert(HBMeq : rk(B :: M :: nil) = 2) by (apply LBM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBMmtmp : rk(B :: M :: nil) >= 2) by (solve_hyps_min HBMeq HBMm2).
	assert(Hincl : incl (B :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (B :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: nil) (Oo :: A :: B :: M :: B :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: B :: Ap :: M :: nil) ((Oo :: A :: B :: M :: nil) ++ (B :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMmtmp;try rewrite HT2 in HOoABApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (B :: Ap :: M :: nil) (B :: M :: nil) 4 2 3 HOoABApMmtmp HBMmtmp HOoABMMtmp Hincl); apply HT.
}
try clear HBMM1. try clear HBMM2. try clear HBMM3. try clear HBMm4. try clear HBMm3. try clear HBMm2. try clear HBMm1. 

assert(HBApMM : rk(B :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApMeq HBApMM3).
assert(HBApMm : rk(B :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HBApMeq HBApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApM *)
(* dans la couche 0 *)
Lemma LOoACApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApM requis par la preuve de (?)OoACApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm2 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Ap :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApMm3 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoACApMm4 : rk(Oo :: A :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HOoAApCpeq : rk(Oo :: A :: Ap :: Cp :: nil) = 3) by (apply LOoAApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApCpMtmp : rk(Oo :: A :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoAApCpeq HOoAApCpM3).
	try assert(HOoACApCpMeq : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApCpMmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApCpMeq HOoACApCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: Cp :: Oo :: A :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Cp :: Oo :: A :: C :: Ap :: M :: nil) ((Oo :: A :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMmtmp;try rewrite HT2 in HOoACApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoACApCpMmtmp HOoAApmtmp HOoAApCpMtmp Hincl); apply HT.
}


assert(HOoACApMM : rk(Oo :: A :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApMm : rk(Oo :: A :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoACApMeq HOoACApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: Ap :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApM requis par la preuve de (?)CApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApM requis par la preuve de (?)CApM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : C ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Cp ::   de rang : 3 et 3 *)
assert(HCApMm2 : rk(C :: Ap :: M :: nil) >= 2).
{
	try assert(HOoACCpeq : rk(Oo :: A :: C :: Cp :: nil) = 3) by (apply LOoACCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACCpMtmp : rk(Oo :: A :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoACCpeq HOoACCpM3).
	try assert(HOoACApCpMeq : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApCpMmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApCpMeq HOoACApCpMm4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (Oo :: A :: C :: Cp :: nil) (C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: C :: Cp :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Cp :: C :: Ap :: M :: nil) ((Oo :: A :: C :: Cp :: nil) ++ (C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMmtmp;try rewrite HT2 in HOoACApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Cp :: nil) (C :: Ap :: M :: nil) (C :: nil) 4 1 3 HOoACApCpMmtmp HCmtmp HOoACCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: M ::  de rang :  4 et 4 	 AiB : C :: M ::  de rang :  2 et 2 	 A : Oo :: A :: C :: M ::   de rang : 3 et 3 *)
assert(HCApMm3 : rk(C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoACMeq : rk(Oo :: A :: C :: M :: nil) = 3) by (apply LOoACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMMtmp : rk(Oo :: A :: C :: M :: nil) <= 3) by (solve_hyps_max HOoACMeq HOoACMM3).
	try assert(HOoACApMeq : rk(Oo :: A :: C :: Ap :: M :: nil) = 4) by (apply LOoACApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApMmtmp : rk(Oo :: A :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoACApMeq HOoACApMm4).
	try assert(HCMeq : rk(C :: M :: nil) = 2) by (apply LCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMmtmp : rk(C :: M :: nil) >= 2) by (solve_hyps_min HCMeq HCMm2).
	assert(Hincl : incl (C :: M :: nil) (list_inter (Oo :: A :: C :: M :: nil) (C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: M :: nil) (Oo :: A :: C :: M :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: M :: C :: Ap :: M :: nil) ((Oo :: A :: C :: M :: nil) ++ (C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApMmtmp;try rewrite HT2 in HOoACApMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: M :: nil) (C :: Ap :: M :: nil) (C :: M :: nil) 4 2 3 HOoACApMmtmp HCMmtmp HOoACMMtmp Hincl); apply HT.
}
try clear HCMM1. try clear HCMM2. try clear HCMM3. try clear HCMm4. try clear HCMm3. try clear HCMm2. try clear HCMm1. 

assert(HCApMM : rk(C :: Ap :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApMeq HCApMM3).
assert(HCApMm : rk(C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HCApMeq HCApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCApM *)
(* dans constructLemma(), requis par LABCApM *)
(* dans la couche 0 *)
Lemma LOoABCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApM requis par la preuve de (?)OoABCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApM requis par la preuve de (?)OoABCApM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApM requis par la preuve de (?)OoABCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMm2 : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMm3 : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoABCApMm4 : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HOoAApCpeq : rk(Oo :: A :: Ap :: Cp :: nil) = 3) by (apply LOoAApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApCpMtmp : rk(Oo :: A :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoAApCpeq HOoAApCpM3).
	try assert(HOoABCApCpMeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApCpMeq HOoABCApCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: Cp :: Oo :: A :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Cp :: Oo :: A :: B :: C :: Ap :: M :: nil) ((Oo :: A :: Ap :: Cp :: nil) ++ (Oo :: A :: B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpMmtmp;try rewrite HT2 in HOoABCApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Cp :: nil) (Oo :: A :: B :: C :: Ap :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABCApCpMmtmp HOoAApmtmp HOoAApCpMtmp Hincl); apply HT.
}


assert(HOoABCApMM : rk(Oo :: A :: B :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApMm : rk(Oo :: A :: B :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HOoABCApMeq HOoABCApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApM requis par la preuve de (?)ABCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApM requis par la preuve de (?)ABCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApM requis par la preuve de (?)ABCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApMm2 : rk(A :: B :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HABCApMm3 : rk(A :: B :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	try assert(HOoABCApCpMeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApCpMeq HOoABCApCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: B :: Cp :: A :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: B :: C :: Ap :: M :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpMmtmp;try rewrite HT2 in HOoABCApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: B :: C :: Ap :: M :: nil) (A :: B :: nil) 4 2 3 HOoABCApCpMmtmp HABmtmp HOoABCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: M ::  de rang :  4 et 4 	 AiB : A :: B :: M ::  de rang :  3 et 3 	 A : Oo :: A :: B :: M ::   de rang : 3 et 3 *)
assert(HABCApMm4 : rk(A :: B :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HOoABMeq : rk(Oo :: A :: B :: M :: nil) = 3) by (apply LOoABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMMtmp : rk(Oo :: A :: B :: M :: nil) <= 3) by (solve_hyps_max HOoABMeq HOoABMM3).
	try assert(HOoABCApMeq : rk(Oo :: A :: B :: C :: Ap :: M :: nil) = 4) by (apply LOoABCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApMmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoABCApMeq HOoABCApMm4).
	try assert(HABMeq : rk(A :: B :: M :: nil) = 3) by (apply LABM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMmtmp : rk(A :: B :: M :: nil) >= 3) by (solve_hyps_min HABMeq HABMm3).
	assert(Hincl : incl (A :: B :: M :: nil) (list_inter (Oo :: A :: B :: M :: nil) (A :: B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: nil) (Oo :: A :: B :: M :: A :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: M :: A :: B :: C :: Ap :: M :: nil) ((Oo :: A :: B :: M :: nil) ++ (A :: B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMmtmp;try rewrite HT2 in HOoABCApMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: M :: nil) (A :: B :: C :: Ap :: M :: nil) (A :: B :: M :: nil) 4 3 3 HOoABCApMmtmp HABMmtmp HOoABMMtmp Hincl); apply HT.
}


assert(HABCApMM : rk(A :: B :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApMm : rk(A :: B :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HABCApMeq HABCApMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: Ap :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApM requis par la preuve de (?)BCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApM requis par la preuve de (?)BCApM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApM requis par la preuve de (?)BCApM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApMm2 : rk(B :: C :: Ap :: M :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: M :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: Cp ::   de rang : 3 et 3 *)
assert(HBCApMm3 : rk(B :: C :: Ap :: M :: nil) >= 3).
{
	try assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 3) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCCpMtmp : rk(Oo :: A :: B :: C :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCCpeq HOoABCCpM3).
	try assert(HOoABCApCpMeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoABCApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApCpMeq HOoABCApCpMm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (Oo :: A :: B :: C :: Cp :: nil) (B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: M :: nil) (Oo :: A :: B :: C :: Cp :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Cp :: B :: C :: Ap :: M :: nil) ((Oo :: A :: B :: C :: Cp :: nil) ++ (B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpMmtmp;try rewrite HT2 in HOoABCApCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Cp :: nil) (B :: C :: Ap :: M :: nil) (B :: C :: nil) 4 2 3 HOoABCApCpMmtmp HBCmtmp HOoABCCpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: M ::  de rang :  4 et 4 	 AiB : B :: C :: M ::  de rang :  3 et 3 	 A : A :: B :: C :: M ::   de rang : 3 et 3 *)
assert(HBCApMm4 : rk(B :: C :: Ap :: M :: nil) >= 4).
{
	try assert(HABCMeq : rk(A :: B :: C :: M :: nil) = 3) by (apply LABCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMMtmp : rk(A :: B :: C :: M :: nil) <= 3) by (solve_hyps_max HABCMeq HABCMM3).
	try assert(HABCApMeq : rk(A :: B :: C :: Ap :: M :: nil) = 4) by (apply LABCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApMmtmp : rk(A :: B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HABCApMeq HABCApMm4).
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hincl : incl (B :: C :: M :: nil) (list_inter (A :: B :: C :: M :: nil) (B :: C :: Ap :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: M :: nil) (A :: B :: C :: M :: B :: C :: Ap :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: M :: B :: C :: Ap :: M :: nil) ((A :: B :: C :: M :: nil) ++ (B :: C :: Ap :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApMmtmp;try rewrite HT2 in HABCApMmtmp.
	assert(HT := rule_4 (A :: B :: C :: M :: nil) (B :: C :: Ap :: M :: nil) (B :: C :: M :: nil) 4 3 3 HABCApMmtmp HBCMmtmp HABCMMtmp Hincl); apply HT.
}


assert(HBCApMM : rk(B :: C :: Ap :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApMm : rk(B :: C :: Ap :: M ::  nil) >= 1) by (solve_hyps_min HBCApMeq HBCApMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpM *)
(* dans constructLemma(), requis par LOoAApCpM *)
(* dans la couche 0 *)
Lemma LOoAApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpCpM requis par la preuve de (?)OoAApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpCpM requis par la preuve de (?)OoAApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpM requis par la preuve de (?)OoAApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpM requis par la preuve de (?)OoACApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoACApBpCpMm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 4 1 2 HOoABCApBpCpMmtmp HAmtmp HABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCpM requis par la preuve de (?)OoAApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  de rang :  3 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpMm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMtmp : rk(A :: C :: nil) <= 2) by (solve_hyps_max HACeq HACM2).
	assert(HOoACApBpCpMmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoACApBpCpMeq HOoACApBpCpMm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: C :: Oo :: A :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Oo :: A :: Ap :: Bp :: Cp :: M :: nil) ((A :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpMmtmp;try rewrite HT2 in HOoACApBpCpMmtmp.
	assert(HT := rule_4 (A :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 3 1 2 HOoACApBpCpMmtmp HAmtmp HACMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpMm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: M :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpMmtmp HOomtmp HOoBCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoAApBpCpMm4 : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApBpCpMeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpMmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApBpCpMeq HOoABApBpCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpMmtmp;try rewrite HT2 in HOoABApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABApBpCpMmtmp HOoAApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoAApBpCpMM : rk(Oo :: A :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpMm : rk(Oo :: A :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpMeq HOoAApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpM requis par la preuve de (?)OoAApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpM requis par la preuve de (?)OoAApCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpMm3 : rk(Oo :: A :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoAApCpMm4 : rk(Oo :: A :: Ap :: Cp :: M :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	try assert(HOoAApBpCpMeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoAApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpMmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMeq HOoAApBpCpMm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: M :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMmtmp;try rewrite HT2 in HOoAApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: M :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoAApBpCpMmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}


assert(HOoAApCpMM : rk(Oo :: A :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpMm : rk(Oo :: A :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoAApCpMeq HOoAApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpM requis par la preuve de (?)ACpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpM requis par la preuve de (?)ACpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HACpMm2 : rk(A :: Cp :: M :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoAApBpCpMeq : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoAApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpMmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoAApBpCpMeq HOoAApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: M :: nil) (Oo :: Ap :: Bp :: A :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Cp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpMmtmp;try rewrite HT2 in HOoAApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Cp :: M :: nil) (nil) 4 0 2 HOoAApBpCpMmtmp Hmtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HACpMm3 : rk(A :: Cp :: M :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoAApCpMeq : rk(Oo :: A :: Ap :: Cp :: M :: nil) = 4) by (apply LOoAApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApCpMmtmp : rk(Oo :: A :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoAApCpMeq HOoAApCpMm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: A :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMmtmp;try rewrite HT2 in HOoAApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: Cp :: M :: nil) (Cp :: nil) 4 1 2 HOoAApCpMmtmp HCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HACpMM : rk(A :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpMeq HACpMM3).
assert(HACpMm : rk(A :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACpMeq HACpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACCpM *)
(* dans la couche 0 *)
Lemma LOoACCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: C :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpM requis par la preuve de (?)OoACCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACCpMm2 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Cp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpMm3 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HOoACApBpCpMeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoACApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApBpCpMmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApBpCpMeq HOoACApBpCpMm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: C :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: Ap :: Bp :: Oo :: A :: C :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: C :: Cp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpMmtmp;try rewrite HT2 in HOoACApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: C :: Cp :: M :: nil) (Oo :: nil) 4 1 2 HOoACApBpCpMmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoACCpMm4 : rk(Oo :: A :: C :: Cp :: M :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoACApCpMeq : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) = 4) by (apply LOoACApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACApCpMmtmp : rk(Oo :: A :: C :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACApCpMeq HOoACApCpMm4).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: Oo :: A :: C :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Oo :: A :: C :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpMmtmp;try rewrite HT2 in HOoACApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Oo :: A :: C :: Cp :: M :: nil) (Oo :: Cp :: nil) 4 2 2 HOoACApCpMmtmp HOoCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HOoACCpMM : rk(Oo :: A :: C :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpMm : rk(Oo :: A :: C :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoACCpMeq HOoACCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpMm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpMm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApBpCpMm3 : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 4 1 2 HOoABCApBpCpMmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HACApBpCpMm4 : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: C :: nil) 4 2 2 HABCApBpCpMmtmp HACmtmp HABCMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpM requis par la preuve de (?)ACCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpMm2 : rk(A :: C :: Cp :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACCpMm3 : rk(A :: C :: Cp :: M :: nil) >= 3).
{
	try assert(HACApBpeq : rk(A :: C :: Ap :: Bp :: nil) = 3) by (apply LACApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACApBpMtmp : rk(A :: C :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HACApBpeq HACApBpM3).
	assert(HACApBpCpMmtmp : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACApBpCpMeq HACApBpCpMm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: Bp :: nil) (A :: C :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: C :: Ap :: Bp :: A :: C :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Bp :: A :: C :: Cp :: M :: nil) ((A :: C :: Ap :: Bp :: nil) ++ (A :: C :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpMmtmp;try rewrite HT2 in HACApBpCpMmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Bp :: nil) (A :: C :: Cp :: M :: nil) (A :: C :: nil) 4 2 3 HACApBpCpMmtmp HACmtmp HACApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C :: M ::  de rang :  3 et 3 	 A : Oo :: A :: C :: M ::   de rang : 3 et 3 *)
assert(HACCpMm4 : rk(A :: C :: Cp :: M :: nil) >= 4).
{
	try assert(HOoACMeq : rk(Oo :: A :: C :: M :: nil) = 3) by (apply LOoACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMMtmp : rk(Oo :: A :: C :: M :: nil) <= 3) by (solve_hyps_max HOoACMeq HOoACMM3).
	try assert(HOoACCpMeq : rk(Oo :: A :: C :: Cp :: M :: nil) = 4) by (apply LOoACCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACCpMmtmp : rk(Oo :: A :: C :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoACCpMeq HOoACCpMm4).
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hincl : incl (A :: C :: M :: nil) (list_inter (Oo :: A :: C :: M :: nil) (A :: C :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: M :: nil) (Oo :: A :: C :: M :: A :: C :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: M :: A :: C :: Cp :: M :: nil) ((Oo :: A :: C :: M :: nil) ++ (A :: C :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpMmtmp;try rewrite HT2 in HOoACCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: M :: nil) (A :: C :: Cp :: M :: nil) (A :: C :: M :: nil) 4 3 3 HOoACCpMmtmp HACMmtmp HOoACMMtmp Hincl); apply HT.
}


assert(HACCpMM : rk(A :: C :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpMm : rk(A :: C :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACCpMeq HACCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpM *)
(* dans la couche 0 *)
Lemma LOoApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: nil) ((Oo :: A :: B :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Bp :: nil) (nil) 2 1 0 HOoABMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpM requis par la preuve de (?)OoApCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Bp ::   de rang : 2 et 3 *)
assert(HOoApCpMm2 : rk(Oo :: Ap :: Cp :: M :: nil) >= 2).
{
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	try assert(HOoABApBpCpMeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpMmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABApBpCpMeq HOoABApBpCpMm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: Bp :: Oo :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: Oo :: Ap :: Cp :: M :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (Oo :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpMmtmp;try rewrite HT2 in HOoABApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Cp :: M :: nil) (Oo :: nil) 4 1 3 HOoABApBpCpMmtmp HOomtmp HOoABBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: M ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: Cp ::   de rang : 2 et 2 *)
assert(HOoApCpMm3 : rk(Oo :: Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpMtmp : rk(A :: Cp :: nil) <= 2) by (solve_hyps_max HACpeq HACpM2).
	try assert(HOoAApCpMeq : rk(Oo :: A :: Ap :: Cp :: M :: nil) = 4) by (apply LOoAApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApCpMmtmp : rk(Oo :: A :: Ap :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoAApCpMeq HOoAApCpMm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: Cp :: nil) (Oo :: Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: M :: nil) (A :: Cp :: Oo :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Oo :: Ap :: Cp :: M :: nil) ((A :: Cp :: nil) ++ (Oo :: Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpMmtmp;try rewrite HT2 in HOoAApCpMmtmp.
	assert(HT := rule_4 (A :: Cp :: nil) (Oo :: Ap :: Cp :: M :: nil) (Cp :: nil) 4 1 2 HOoAApCpMmtmp HCpmtmp HACpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApCpMM3 : rk(Oo :: Ap :: Cp :: M :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Cp :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (M :: nil) (nil) 2 1 0 HOoApCpMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoApCpMM : rk(Oo :: Ap :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpMm : rk(Oo :: Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoApCpMeq HOoApCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Cp :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpM requis par la preuve de (?)ApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApBpCpM requis par la preuve de (?)ApCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpCpM requis par la preuve de (?)OoApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpM requis par la preuve de (?)OoApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpM requis par la preuve de (?)OoACApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoACApBpCpMm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 4 1 2 HOoABCApBpCpMmtmp HAmtmp HABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpCpM requis par la preuve de (?)OoApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: M ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C ::   de rang : 2 et 2 *)
assert(HOoApBpCpMm2 : rk(Oo :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HOoACeq : rk(Oo :: A :: C :: nil) = 2) by (apply LOoAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACMtmp : rk(Oo :: A :: C :: nil) <= 2) by (solve_hyps_max HOoACeq HOoACM2).
	assert(HOoACApBpCpMmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoACApBpCpMeq HOoACApBpCpMm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Oo :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpMmtmp;try rewrite HT2 in HOoACApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: nil) (Oo :: Ap :: Bp :: Cp :: M :: nil) (Oo :: nil) 3 1 2 HOoACApBpCpMmtmp HOomtmp HOoACMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoApBpCpMm3 : rk(Oo :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 2) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCMtmp : rk(Oo :: A :: B :: C :: nil) <= 2) by (solve_hyps_max HOoABCeq HOoABCM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: C :: nil) (Oo :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: C :: Oo :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Oo :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: C :: nil) ++ (Oo :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: nil) (Oo :: Ap :: Bp :: Cp :: M :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpMmtmp HOomtmp HOoABCMtmp Hincl); apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpM requis par la preuve de (?)ApCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp :: M ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HApCpMm2 : rk(Ap :: Cp :: M :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoApBpCpMmtmp : rk(Oo :: Ap :: Bp :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoApBpCpMeq HOoApBpCpMm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: M :: nil) (Oo :: Ap :: Bp :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpMmtmp;try rewrite HT2 in HOoApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Ap :: Cp :: M :: nil) (Ap :: nil) 3 1 2 HOoApBpCpMmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoApBpCpMM1. try clear HOoApBpCpMM2. try clear HOoApBpCpMM3. try clear HOoApBpCpMm4. try clear HOoApBpCpMm3. try clear HOoApBpCpMm2. try clear HOoApBpCpMm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Cp :: M ::  de rang :  3 et 3 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HApCpMm3 : rk(Ap :: Cp :: M :: nil) >= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoApCpMeq : rk(Oo :: Ap :: Cp :: M :: nil) = 3) by (apply LOoApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMmtmp : rk(Oo :: Ap :: Cp :: M :: nil) >= 3) by (solve_hyps_min HOoApCpMeq HOoApCpMm3).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Ap :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: M :: nil) (Oo :: Ap :: Cp :: Ap :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Ap :: Cp :: M :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Ap :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpMmtmp;try rewrite HT2 in HOoApCpMmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Ap :: Cp :: M :: nil) (Ap :: Cp :: nil) 3 2 2 HOoApCpMmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HApCpMM : rk(Ap :: Cp :: M ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpMeq HApCpMM3).
assert(HApCpMm : rk(Ap :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HApCpMeq HApCpMm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApBpCpM *)
(* dans la couche 0 *)
Lemma LABCApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpM requis par la preuve de (?)ABCApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpMm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpMm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpMmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCApBpCpMM : rk(A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpMm : rk(A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpCpM requis par la preuve de (?)ABApBpCpM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApBpCpMm2 : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABApBpCpMm3 : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCApBpCpMeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (C :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Ap :: Bp :: Cp :: M :: nil) ((C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil) (nil) 4 0 1 HABCApBpCpMmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABApBpCpMm4 : rk(A :: B :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCApBpCpMeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: nil) 4 2 2 HABCApBpCpMmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABApBpCpMM : rk(A :: B :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApBpCpMm : rk(A :: B :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HABApBpCpMeq HABApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpM requis par la preuve de (?)ACApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HACApBpCpMm3 : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: nil) 4 1 2 HOoABCApBpCpMmtmp HAmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HACApBpCpMm4 : rk(A :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCApBpCpMeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: A :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: C :: nil) 4 2 2 HABCApBpCpMmtmp HACmtmp HABCMtmp Hincl); apply HT.
}


assert(HACApBpCpMM : rk(A :: C :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpCpMm : rk(A :: C :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HACApBpCpMeq HACApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBpCpM requis par la preuve de (?)BCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBpCpM requis par la preuve de (?)BCApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HBCApBpCpMm3 : rk(B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: A :: B :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (Oo :: A :: B :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((Oo :: A :: B :: nil) ++ (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: nil) 4 1 2 HOoABCApBpCpMmtmp HBmtmp HOoABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HBCApBpCpMm4 : rk(B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCApBpCpMeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApBpCpMmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HABCApBpCpMeq HABCApBpCpMm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (A :: B :: C :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpMmtmp;try rewrite HT2 in HABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: C :: nil) 4 2 2 HABCApBpCpMmtmp HBCmtmp HABCMtmp Hincl); apply HT.
}


assert(HBCApBpCpMM : rk(B :: C :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApBpCpMm : rk(B :: C :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HBCApBpCpMeq HBCApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpCpM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpM requis par la preuve de (?)OoBCApBpCpM pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpM requis par la preuve de (?)OoBCApBpCpM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpMm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: nil) 4 1 2 HOoABCApBpCpMmtmp HBmtmp HABMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  de rang :  4 et 4 	 AiB : B :: C ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpMm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpMeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) = 4) by (apply LOoABCApBpCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpMmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpMeq HOoABCApBpCpMm4).
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hincl : incl (B :: C :: nil) (list_inter (A :: B :: C :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (A :: B :: C :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) ((A :: B :: C :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpMmtmp;try rewrite HT2 in HOoABCApBpCpMmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: M :: nil) (B :: C :: nil) 4 2 2 HOoABCApBpCpMmtmp HBCmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoBCApBpCpMM : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpCpMm : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) >= 1) by (solve_hyps_min HOoBCApBpCpMeq HOoBCApBpCpMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApXM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: Ap :: X :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApXM requis par la preuve de (?)BApXM pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApXM requis par la preuve de (?)BApXM pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApXM requis par la preuve de (?)BApXM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApXM requis par la preuve de (?)OoABApXM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApXM requis par la preuve de (?)OoABApXM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXMm2 : rk(Oo :: A :: B :: Ap :: X :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXMm3 : rk(Oo :: A :: B :: Ap :: X :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApXM requis par la preuve de (?)BApXM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: M ::  de rang :  3 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: X ::   de rang : 3 et 3 *)
assert(HBApXMm2 : rk(B :: Ap :: X :: M :: nil) >= 2).
{
	try assert(HOoAApXeq : rk(Oo :: A :: Ap :: X :: nil) = 3) by (apply LOoAApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApXMtmp : rk(Oo :: A :: Ap :: X :: nil) <= 3) by (solve_hyps_max HOoAApXeq HOoAApXM3).
	assert(HOoABApXMmtmp : rk(Oo :: A :: B :: Ap :: X :: M :: nil) >= 3) by (solve_hyps_min HOoABApXMeq HOoABApXMm3).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (Oo :: A :: Ap :: X :: nil) (B :: Ap :: X :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: M :: nil) (Oo :: A :: Ap :: X :: B :: Ap :: X :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: X :: B :: Ap :: X :: M :: nil) ((Oo :: A :: Ap :: X :: nil) ++ (B :: Ap :: X :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXMmtmp;try rewrite HT2 in HOoABApXMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: X :: nil) (B :: Ap :: X :: M :: nil) (Ap :: X :: nil) 3 2 3 HOoABApXMmtmp HApXmtmp HOoAApXMtmp Hincl); apply HT.
}
try clear HOoABApXMM1. try clear HOoABApXMM2. try clear HOoABApXMM3. try clear HOoABApXMm4. try clear HOoABApXMm3. try clear HOoABApXMm2. try clear HOoABApXMm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBApXMM3 : rk(B :: Ap :: X :: M :: nil) <= 3).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: X :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: X :: M :: nil) (B :: Ap :: X :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: M :: nil) ((B :: Ap :: X :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Ap :: X :: nil) (M :: nil) (nil) 2 1 0 HBApXMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApXMm3 : rk(B :: Ap :: X :: M :: nil) >= 3).
{
	try assert(HBApMeq : rk(B :: Ap :: M :: nil) = 3) by (apply LBApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBApMmtmp : rk(B :: Ap :: M :: nil) >= 3) by (solve_hyps_min HBApMeq HBApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: M :: nil) (B :: Ap :: X :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: M :: nil) (B :: Ap :: X :: M :: nil) 3 3 HBApMmtmp Hcomp Hincl);apply HT.
}


assert(HBApXMM : rk(B :: Ap :: X :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApXMm : rk(B :: Ap :: X :: M ::  nil) >= 1) by (solve_hyps_min HBApXMeq HBApXMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApYM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: Ap :: Y :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApYM requis par la preuve de (?)CApYM pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApYM requis par la preuve de (?)CApYM pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApYM requis par la preuve de (?)CApYM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApYM requis par la preuve de (?)OoACApYM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApYM requis par la preuve de (?)OoACApYM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMm2 : rk(Oo :: A :: C :: Ap :: Y :: M :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Ap :: Y :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Ap :: Y :: M :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApYMm3 : rk(Oo :: A :: C :: Ap :: Y :: M :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Y :: M :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApYM requis par la preuve de (?)CApYM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Y :: M ::  de rang :  3 et 4 	 AiB : Ap :: Y ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Y ::   de rang : 3 et 3 *)
assert(HCApYMm2 : rk(C :: Ap :: Y :: M :: nil) >= 2).
{
	try assert(HOoAApYeq : rk(Oo :: A :: Ap :: Y :: nil) = 3) by (apply LOoAApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApYMtmp : rk(Oo :: A :: Ap :: Y :: nil) <= 3) by (solve_hyps_max HOoAApYeq HOoAApYM3).
	assert(HOoACApYMmtmp : rk(Oo :: A :: C :: Ap :: Y :: M :: nil) >= 3) by (solve_hyps_min HOoACApYMeq HOoACApYMm3).
	try assert(HApYeq : rk(Ap :: Y :: nil) = 2) by (apply LApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApYmtmp : rk(Ap :: Y :: nil) >= 2) by (solve_hyps_min HApYeq HApYm2).
	assert(Hincl : incl (Ap :: Y :: nil) (list_inter (Oo :: A :: Ap :: Y :: nil) (C :: Ap :: Y :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Y :: M :: nil) (Oo :: A :: Ap :: Y :: C :: Ap :: Y :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Y :: C :: Ap :: Y :: M :: nil) ((Oo :: A :: Ap :: Y :: nil) ++ (C :: Ap :: Y :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApYMmtmp;try rewrite HT2 in HOoACApYMmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Y :: nil) (C :: Ap :: Y :: M :: nil) (Ap :: Y :: nil) 3 2 3 HOoACApYMmtmp HApYmtmp HOoAApYMtmp Hincl); apply HT.
}
try clear HApYM1. try clear HApYM2. try clear HApYM3. try clear HApYm4. try clear HApYm3. try clear HApYm2. try clear HApYm1. try clear HOoACApYMM1. try clear HOoACApYMM2. try clear HOoACApYMM3. try clear HOoACApYMm4. try clear HOoACApYMm3. try clear HOoACApYMm2. try clear HOoACApYMm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCApYMM3 : rk(C :: Ap :: Y :: M :: nil) <= 3).
{
	try assert(HCApYeq : rk(C :: Ap :: Y :: nil) = 2) by (apply LCApY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCApYMtmp : rk(C :: Ap :: Y :: nil) <= 2) by (solve_hyps_max HCApYeq HCApYM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: Y :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Y :: M :: nil) (C :: Ap :: Y :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: M :: nil) ((C :: Ap :: Y :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: Ap :: Y :: nil) (M :: nil) (nil) 2 1 0 HCApYMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCApYMm3 : rk(C :: Ap :: Y :: M :: nil) >= 3).
{
	try assert(HCApMeq : rk(C :: Ap :: M :: nil) = 3) by (apply LCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCApMmtmp : rk(C :: Ap :: M :: nil) >= 3) by (solve_hyps_min HCApMeq HCApMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: M :: nil) (C :: Ap :: Y :: M :: nil) 3 3 HCApMmtmp Hcomp Hincl);apply HT.
}


assert(HCApYMM : rk(C :: Ap :: Y :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApYMm : rk(C :: Ap :: Y :: M ::  nil) >= 1) by (solve_hyps_min HCApYMeq HCApYMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpYM : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: Cp :: Y :: M ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpYM requis par la preuve de (?)ACpYM pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpYM requis par la preuve de (?)ACpYM pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpYM requis par la preuve de (?)ACpYM pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpYM requis par la preuve de (?)OoABCpYM pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpYM requis par la preuve de (?)OoABCpYM pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMm2 : rk(Oo :: A :: B :: Cp :: Y :: M :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Cp :: Y :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Cp :: Y :: M :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpYMm3 : rk(Oo :: A :: B :: Cp :: Y :: M :: nil) >= 3).
{
	try assert(HOoACpeq : rk(Oo :: A :: Cp :: nil) = 3) by (apply LOoACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoACpmtmp : rk(Oo :: A :: Cp :: nil) >= 3) by (solve_hyps_min HOoACpeq HOoACpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: nil) (Oo :: A :: B :: Cp :: Y :: M :: nil) 3 3 HOoACpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpYM requis par la preuve de (?)ACpYM pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: Y :: M ::  de rang :  3 et 4 	 AiB : A :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HACpYMm2 : rk(A :: Cp :: Y :: M :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCpYMmtmp : rk(Oo :: A :: B :: Cp :: Y :: M :: nil) >= 3) by (solve_hyps_min HOoABCpYMeq HOoABCpYMm3).
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hincl : incl (A :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: Y :: M :: nil) (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: A :: Cp :: Y :: M :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (A :: Cp :: Y :: M :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpYMmtmp;try rewrite HT2 in HOoABCpYMmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (A :: Cp :: Y :: M :: nil) (A :: Cp :: nil) 3 2 3 HOoABCpYMmtmp HACpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCpYMM1. try clear HOoABCpYMM2. try clear HOoABCpYMM3. try clear HOoABCpYMm4. try clear HOoABCpYMm3. try clear HOoABCpYMm2. try clear HOoABCpYMm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACpYMM3 : rk(A :: Cp :: Y :: M :: nil) <= 3).
{
	try assert(HACpYeq : rk(A :: Cp :: Y :: nil) = 2) by (apply LACpY with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpYMtmp : rk(A :: Cp :: Y :: nil) <= 2) by (solve_hyps_max HACpYeq HACpYM2).
	try assert(HMeq : rk(M :: nil) = 1) by (apply LM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HMMtmp : rk(M :: nil) <= 1) by (solve_hyps_max HMeq HMM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Cp :: Y :: nil) (M :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Y :: M :: nil) (A :: Cp :: Y :: M :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Y :: M :: nil) ((A :: Cp :: Y :: nil) ++ (M :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Cp :: Y :: nil) (M :: nil) (nil) 2 1 0 HACpYMtmp HMMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpYMm3 : rk(A :: Cp :: Y :: M :: nil) >= 3).
{
	try assert(HACpMeq : rk(A :: Cp :: M :: nil) = 3) by (apply LACpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpMmtmp : rk(A :: Cp :: M :: nil) >= 3) by (solve_hyps_min HACpMeq HACpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: M :: nil) (A :: Cp :: Y :: M :: nil) 3 3 HACpMmtmp Hcomp Hincl);apply HT.
}


assert(HACpYMM : rk(A :: Cp :: Y :: M ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpYMm : rk(A :: Cp :: Y :: M ::  nil) >= 1) by (solve_hyps_min HACpYMeq HACpYMm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(N ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HNM : rk(N ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HNeq HNM1).
assert(HNm : rk(N ::  nil) >= 1) by (solve_hyps_min HNeq HNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpN *)
(* dans la couche 0 *)
Lemma LApBpNQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HApBpNQM : rk(Ap :: Bp :: N :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpNQm : rk(Ap :: Bp :: N :: Q ::  nil) >= 1) by (solve_hyps_min HApBpNQeq HApBpNQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpN *)
(* dans constructLemma(), requis par LApQ *)
(* dans constructLemma(), requis par LOoApCpQ *)
(* dans la couche 0 *)
Lemma LQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Q ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HQM : rk(Q ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HQeq HQM1).
assert(HQm : rk(Q ::  nil) >= 1) by (solve_hyps_min HQeq HQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: Q ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApCpQ requis par la preuve de (?)OoApCpQ pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpQ requis par la preuve de (?)OoApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpQm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApBpCpQm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (nil) 4 0 1 HOoABCApBpCpQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoABApBpCpQm4 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpQmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpQ requis par la preuve de (?)OoACApBpCpQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoACApBpCpQm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) ((A :: B :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: nil) 4 1 2 HOoABCApBpCpQmtmp HAmtmp HABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  3 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpQm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMtmp : rk(A :: C :: nil) <= 2) by (solve_hyps_max HACeq HACM2).
	assert(HOoACApBpCpQmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 3) by (solve_hyps_min HOoACApBpCpQeq HOoACApBpCpQm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) ((A :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpQmtmp;try rewrite HT2 in HOoACApBpCpQmtmp.
	assert(HT := rule_4 (A :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (A :: nil) 3 1 2 HOoACApBpCpQmtmp HAmtmp HACMtmp Hincl); apply HT.
}
try clear HOoACApBpCpQM1. try clear HOoACApBpCpQM2. try clear HOoACApBpCpQM3. try clear HOoACApBpCpQm4. try clear HOoACApBpCpQm3. try clear HOoACApBpCpQm2. try clear HOoACApBpCpQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpQm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpQmtmp HOomtmp HOoBCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoAApBpCpQm4 : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpCpQmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABApBpCpQeq HOoABApBpCpQm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpQmtmp;try rewrite HT2 in HOoABApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABApBpCpQmtmp HOoAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpQ requis par la preuve de (?)OoAApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpQ requis par la preuve de (?)OoAApCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpQm3 : rk(Oo :: A :: Ap :: Cp :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoAApCpQm4 : rk(Oo :: A :: Ap :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	assert(HOoAApBpCpQmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoAApBpCpQeq HOoAApBpCpQm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: Q :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpQmtmp;try rewrite HT2 in HOoAApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoAApBpCpQmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpCpQM1. try clear HOoAApBpCpQM2. try clear HOoAApBpCpQM3. try clear HOoAApBpCpQm4. try clear HOoAApBpCpQm3. try clear HOoAApBpCpQm2. try clear HOoAApBpCpQm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpQ requis par la preuve de (?)OoApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: nil) ((Oo :: A :: B :: nil) ++ (Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (Bp :: nil) (nil) 2 1 0 HOoABMtmp HBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpQ requis par la preuve de (?)OoApCpQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Bp ::   de rang : 2 et 3 *)
assert(HOoApCpQm2 : rk(Oo :: Ap :: Cp :: Q :: nil) >= 2).
{
	assert(HOoABBpMtmp : rk(Oo :: A :: B :: Bp :: nil) <= 3) by (solve_hyps_max HOoABBpeq HOoABBpM3).
	assert(HOoABApBpCpQmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABApBpCpQeq HOoABApBpCpQm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: B :: Bp :: Oo :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: Oo :: Ap :: Cp :: Q :: nil) ((Oo :: A :: B :: Bp :: nil) ++ (Oo :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpQmtmp;try rewrite HT2 in HOoABApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: nil) (Oo :: Ap :: Cp :: Q :: nil) (Oo :: nil) 4 1 3 HOoABApBpCpQmtmp HOomtmp HOoABBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: Cp ::   de rang : 2 et 2 *)
assert(HOoApCpQm3 : rk(Oo :: Ap :: Cp :: Q :: nil) >= 3).
{
	try assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpMtmp : rk(A :: Cp :: nil) <= 2) by (solve_hyps_max HACpeq HACpM2).
	assert(HOoAApCpQmtmp : rk(Oo :: A :: Ap :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoAApCpQeq HOoAApCpQm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: Cp :: nil) (Oo :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: Q :: nil) (A :: Cp :: Oo :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Oo :: Ap :: Cp :: Q :: nil) ((A :: Cp :: nil) ++ (Oo :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpQmtmp;try rewrite HT2 in HOoAApCpQmtmp.
	assert(HT := rule_4 (A :: Cp :: nil) (Oo :: Ap :: Cp :: Q :: nil) (Cp :: nil) 4 1 2 HOoAApCpQmtmp HCpmtmp HACpMtmp Hincl); apply HT.
}
try clear HOoAApCpQM1. try clear HOoAApCpQM2. try clear HOoAApCpQM3. try clear HOoAApCpQm4. try clear HOoAApCpQm3. try clear HOoAApCpQm2. try clear HOoAApCpQm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApCpQM3 : rk(Oo :: Ap :: Cp :: Q :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Cp :: nil) (Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: Q :: nil) (Oo :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Q :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Q :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (Q :: nil) (nil) 2 1 0 HOoApCpMtmp HQMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoApCpQM : rk(Oo :: Ap :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpQm : rk(Oo :: Ap :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HOoApCpQeq HOoApCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApQ requis par la preuve de (?)ApQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Cp :: Q ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HApQm2 : rk(Ap :: Q :: nil) >= 2).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoApCpQeq : rk(Oo :: Ap :: Cp :: Q :: nil) = 3) by (apply LOoApCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpQmtmp : rk(Oo :: Ap :: Cp :: Q :: nil) >= 3) by (solve_hyps_min HOoApCpQeq HOoApCpQm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (Ap :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: Q :: nil) (Oo :: Ap :: Cp :: Ap :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Ap :: Q :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Ap :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpQmtmp;try rewrite HT2 in HOoApCpQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (Ap :: Q :: nil) (Ap :: nil) 3 1 2 HOoApCpQmtmp HApmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HApQM : rk(Ap :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApQeq HApQM2).
assert(HApQm : rk(Ap :: Q ::  nil) >= 1) by (solve_hyps_min HApQeq HApQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Bp :: N ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpN requis par la preuve de (?)BpN pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HBpNm2 : rk(Bp :: N :: nil) >= 2).
{
	try assert(HApQeq : rk(Ap :: Q :: nil) = 2) by (apply LApQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApQMtmp : rk(Ap :: Q :: nil) <= 2) by (solve_hyps_max HApQeq HApQM2).
	try assert(HApBpNQeq : rk(Ap :: Bp :: N :: Q :: nil) = 4) by (apply LApBpNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpNQmtmp : rk(Ap :: Bp :: N :: Q :: nil) >= 4) by (solve_hyps_min HApBpNQeq HApBpNQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: N :: nil) (Ap :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: N :: Q :: nil) (Bp :: N :: Ap :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: N :: Ap :: Q :: nil) ((Bp :: N :: nil) ++ (Ap :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpNQmtmp;try rewrite HT2 in HApBpNQmtmp.
	assert(HT := rule_2 (Bp :: N :: nil) (Ap :: Q :: nil) (nil) 4 0 2 HApBpNQmtmp Hmtmp HApQMtmp Hincl);apply HT.
}
try clear HApQM1. try clear HApQM2. try clear HApQM3. try clear HApQm4. try clear HApQm3. try clear HApQm2. try clear HApQm1. 

assert(HBpNM : rk(Bp :: N ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpNeq HBpNM2).
assert(HBpNm : rk(Bp :: N ::  nil) >= 1) by (solve_hyps_min HBpNeq HBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoBBpNM : rk(Oo :: B :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpNm : rk(Oo :: B :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBBpNeq HOoBBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpN requis par la preuve de (?)OoABBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm2 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpNm4 : rk(Oo :: A :: B :: Bp :: N :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpNM : rk(Oo :: A :: B :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpNm : rk(Oo :: A :: B :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABBpNeq HOoABBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCBpN requis par la preuve de (?)OoABCBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpN requis par la preuve de (?)OoABCBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNm2 : rk(Oo :: A :: B :: C :: Bp :: N :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpNm4 : rk(Oo :: A :: B :: C :: Bp :: N :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: C :: Bp :: N :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpNM : rk(Oo :: A :: B :: C :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpNm : rk(Oo :: A :: B :: C :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoABCBpNeq HOoABCBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNm2 : rk(Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HApBpNm3 : rk(Ap :: Bp :: N :: nil) >= 3).
{
	try assert(HQeq : rk(Q :: nil) = 1) by (apply LQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HQMtmp : rk(Q :: nil) <= 1) by (solve_hyps_max HQeq HQM1).
	try assert(HApBpNQeq : rk(Ap :: Bp :: N :: Q :: nil) = 4) by (apply LApBpNQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpNQmtmp : rk(Ap :: Bp :: N :: Q :: nil) >= 4) by (solve_hyps_min HApBpNQeq HApBpNQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: N :: nil) (Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: N :: Q :: nil) (Ap :: Bp :: N :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: N :: Q :: nil) ((Ap :: Bp :: N :: nil) ++ (Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpNQmtmp;try rewrite HT2 in HApBpNQmtmp.
	assert(HT := rule_2 (Ap :: Bp :: N :: nil) (Q :: nil) (nil) 4 0 1 HApBpNQmtmp Hmtmp HQMtmp Hincl);apply HT.
}
try clear HQM1. try clear HQM2. try clear HQM3. try clear HQm4. try clear HQm3. try clear HQm2. try clear HQm1. try clear HApBpNQM1. try clear HApBpNQM2. try clear HApBpNQM3. try clear HApBpNQm4. try clear HApBpNQm3. try clear HApBpNQm2. try clear HApBpNQm1. 

assert(HApBpNM : rk(Ap :: Bp :: N ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpNeq HApBpNM3).
assert(HApBpNm : rk(Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HApBpNeq HApBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpN *)
(* dans la couche 0 *)
Lemma LOoBApBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: N ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpN requis par la preuve de (?)OoBApBpN pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpN requis par la preuve de (?)OoBApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNm2 : rk(Oo :: B :: Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNm4 : rk(Oo :: B :: Ap :: Bp :: N :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApBpNM : rk(Oo :: B :: Ap :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpNm : rk(Oo :: B :: Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoBApBpNeq HOoBApBpNm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpN *)
(* dans la couche 0 *)
Lemma LOoApBpN : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: N ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApBpN requis par la preuve de (?)OoApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpN requis par la preuve de (?)BApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApBpNm2 : rk(B :: Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (B :: Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (B :: Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpN requis par la preuve de (?)OoApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNm2 : rk(Oo :: Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpNM3 : rk(Oo :: Ap :: Bp :: N :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: nil) (Oo :: Ap :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (N :: nil) (nil) 2 1 0 HOoApBpMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoApBpNm3 : rk(Oo :: Ap :: Bp :: N :: nil) >= 3).
{
	assert(HBApBpNMtmp : rk(B :: Ap :: Bp :: N :: nil) <= 4) by (solve_hyps_max HBApBpNeq HBApBpNM4).
	try assert(HOoBApBpNeq : rk(Oo :: B :: Ap :: Bp :: N :: nil) = 4) by (apply LOoBApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBApBpNmtmp : rk(Oo :: B :: Ap :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBApBpNeq HOoBApBpNm4).
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (B :: Ap :: Bp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: N :: nil) (Oo :: Ap :: Bp :: N :: B :: Ap :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: B :: Ap :: Bp :: N :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (B :: Ap :: Bp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpNmtmp;try rewrite HT2 in HOoBApBpNmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: N :: nil) (B :: Ap :: Bp :: N :: nil) (Ap :: Bp :: N :: nil) 4 3 4 HOoBApBpNmtmp HApBpNmtmp HBApBpNMtmp Hincl);apply HT.
}
try clear HBApBpNM1. try clear HBApBpNM2. try clear HBApBpNM3. try clear HBApBpNm4. try clear HBApBpNm3. try clear HBApBpNm2. try clear HBApBpNm1. 

assert(HOoApBpNM : rk(Oo :: Ap :: Bp :: N ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpNm : rk(Oo :: Ap :: Bp :: N ::  nil) >= 1) by (solve_hyps_min HOoApBpNeq HOoApBpNm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(P ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HPM : rk(P ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HPeq HPM1).
assert(HPm : rk(P ::  nil) >= 1) by (solve_hyps_min HPeq HPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoP *)
(* dans la couche 0 *)
Lemma LOoABpP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Bp :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoABpPM : rk(Oo :: A :: Bp :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpPm : rk(Oo :: A :: Bp :: P ::  nil) >= 1) by (solve_hyps_min HOoABpPeq HOoABpPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoP *)
(* dans la couche 0 *)
Lemma LOoP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpP requis par la preuve de (?)OoP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpP requis par la preuve de (?)ABpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpP requis par la preuve de (?)OoAApBpP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpPm3 : rk(Oo :: A :: Ap :: Bp :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpP requis par la preuve de (?)ABpP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: P ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HABpPm2 : rk(A :: Bp :: P :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpPmtmp : rk(Oo :: A :: Ap :: Bp :: P :: nil) >= 3) by (solve_hyps_min HOoAApBpPeq HOoAApBpPm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: P :: nil) (Oo :: Ap :: Bp :: A :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Bp :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpPmtmp;try rewrite HT2 in HOoAApBpPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Bp :: P :: nil) (Bp :: nil) 3 1 2 HOoAApBpPmtmp HBpmtmp HOoApBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoP requis par la preuve de (?)OoP pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoPm2 : rk(Oo :: P :: nil) >= 2).
{
	assert(HABpPMtmp : rk(A :: Bp :: P :: nil) <= 3) by (solve_hyps_max HABpPeq HABpPM3).
	try assert(HOoABpPeq : rk(Oo :: A :: Bp :: P :: nil) = 4) by (apply LOoABpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABpPmtmp : rk(Oo :: A :: Bp :: P :: nil) >= 4) by (solve_hyps_min HOoABpPeq HOoABpPm4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (Oo :: P :: nil) (A :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: P :: nil) (Oo :: P :: A :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: P :: A :: Bp :: P :: nil) ((Oo :: P :: nil) ++ (A :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpPmtmp;try rewrite HT2 in HOoABpPmtmp.
	assert(HT := rule_2 (Oo :: P :: nil) (A :: Bp :: P :: nil) (P :: nil) 4 1 3 HOoABpPmtmp HPmtmp HABpPMtmp Hincl);apply HT.
}
try clear HABpPM1. try clear HABpPM2. try clear HABpPM3. try clear HABpPm4. try clear HABpPm3. try clear HABpPm2. try clear HABpPm1. 

assert(HOoPM : rk(Oo :: P ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoPeq HOoPM2).
assert(HOoPm : rk(Oo :: P ::  nil) >= 1) by (solve_hyps_min HOoPeq HOoPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAP *)
(* dans constructLemma(), requis par LBpP *)
(* dans la couche 0 *)
Lemma LApBpMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Bp :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HApBpMPM : rk(Ap :: Bp :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpMPm : rk(Ap :: Bp :: M :: P ::  nil) >= 1) by (solve_hyps_min HApBpMPeq HApBpMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Bp :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpP requis par la preuve de (?)BpP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: P ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: M ::   de rang : 2 et 2 *)
assert(HBpPm2 : rk(Bp :: P :: nil) >= 2).
{
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMMtmp : rk(Ap :: M :: nil) <= 2) by (solve_hyps_max HApMeq HApMM2).
	try assert(HApBpMPeq : rk(Ap :: Bp :: M :: P :: nil) = 4) by (apply LApBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpMPmtmp : rk(Ap :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HApBpMPeq HApBpMPm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: M :: nil) (Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: P :: nil) (Ap :: M :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Bp :: P :: nil) ((Ap :: M :: nil) ++ (Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMPmtmp;try rewrite HT2 in HApBpMPmtmp.
	assert(HT := rule_4 (Ap :: M :: nil) (Bp :: P :: nil) (nil) 4 0 2 HApBpMPmtmp Hmtmp HApMMtmp Hincl); apply HT.
}


assert(HBpPM : rk(Bp :: P ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpPeq HBpPM2).
assert(HBpPm : rk(Bp :: P ::  nil) >= 1) by (solve_hyps_min HBpPeq HBpPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAP requis par la preuve de (?)OoAP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpP requis par la preuve de (?)OoAP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpP requis par la preuve de (?)OoAApBpP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpPm3 : rk(Oo :: A :: Ap :: Bp :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAP requis par la preuve de (?)OoAP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: P ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoAPm2 : rk(Oo :: A :: P :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpPmtmp : rk(Oo :: A :: Ap :: Bp :: P :: nil) >= 3) by (solve_hyps_min HOoAApBpPeq HOoAApBpPm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: P :: nil) (Oo :: Ap :: Bp :: Oo :: A :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpPmtmp;try rewrite HT2 in HOoAApBpPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: P :: nil) (Oo :: nil) 3 1 2 HOoAApBpPmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAPm3 : rk(Oo :: A :: P :: nil) >= 3).
{
	try assert(HBpPeq : rk(Bp :: P :: nil) = 2) by (apply LBpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpPMtmp : rk(Bp :: P :: nil) <= 2) by (solve_hyps_max HBpPeq HBpPM2).
	try assert(HOoABpPeq : rk(Oo :: A :: Bp :: P :: nil) = 4) by (apply LOoABpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABpPmtmp : rk(Oo :: A :: Bp :: P :: nil) >= 4) by (solve_hyps_min HOoABpPeq HOoABpPm4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (Oo :: A :: P :: nil) (Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: P :: nil) (Oo :: A :: P :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: P :: Bp :: P :: nil) ((Oo :: A :: P :: nil) ++ (Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpPmtmp;try rewrite HT2 in HOoABpPmtmp.
	assert(HT := rule_2 (Oo :: A :: P :: nil) (Bp :: P :: nil) (P :: nil) 4 1 2 HOoABpPmtmp HPmtmp HBpPMtmp Hincl);apply HT.
}


assert(HOoAPM : rk(Oo :: A :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAPeq HOoAPM3).
assert(HOoAPm : rk(Oo :: A :: P ::  nil) >= 1) by (solve_hyps_min HOoAPeq HOoAPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBP *)
(* dans la couche 0 *)
Lemma LOoBBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpNPT requis par la preuve de (?)OoBBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpNPTm4 : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Bp :: N :: P :: T :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBBpNPTM : rk(Oo :: B :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpNPTm : rk(Oo :: B :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBBpNPTeq HOoBBpNPTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBP *)
(* dans la couche 0 *)
Lemma LBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Bp :: N :: P :: T ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HBpNPTM : rk(Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpNPTm : rk(Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HBpNPTeq HBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBP requis par la preuve de (?)OoBP pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApBpNP requis par la preuve de (?)OoBP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpNP requis par la preuve de (?)OoBApBpNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpNP requis par la preuve de (?)OoBApBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNPm2 : rk(Oo :: B :: Ap :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNPm4 : rk(Oo :: B :: Ap :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBP requis par la preuve de (?)OoBP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp :: N ::   de rang : 3 et 3 *)
assert(HOoBPm2 : rk(Oo :: B :: P :: nil) >= 2).
{
	try assert(HOoApBpNeq : rk(Oo :: Ap :: Bp :: N :: nil) = 3) by (apply LOoApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpNMtmp : rk(Oo :: Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HOoApBpNeq HOoApBpNM3).
	assert(HOoBApBpNPmtmp : rk(Oo :: B :: Ap :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoBApBpNPeq HOoBApBpNPm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: N :: nil) (Oo :: B :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: N :: P :: nil) (Oo :: Ap :: Bp :: N :: Oo :: B :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: N :: Oo :: B :: P :: nil) ((Oo :: Ap :: Bp :: N :: nil) ++ (Oo :: B :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpNPmtmp;try rewrite HT2 in HOoBApBpNPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: N :: nil) (Oo :: B :: P :: nil) (Oo :: nil) 4 1 3 HOoBApBpNPmtmp HOomtmp HOoApBpNMtmp Hincl); apply HT.
}
try clear HOoBApBpNPM1. try clear HOoBApBpNPM2. try clear HOoBApBpNPM3. try clear HOoBApBpNPm4. try clear HOoBApBpNPm3. try clear HOoBApBpNPm2. try clear HOoBApBpNPm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBPm3 : rk(Oo :: B :: P :: nil) >= 3).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoBBpNPTeq : rk(Oo :: B :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNPTmtmp : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBBpNPTeq HOoBBpNPTm4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (Oo :: B :: P :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: N :: P :: T :: nil) (Oo :: B :: P :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: P :: Bp :: N :: P :: T :: nil) ((Oo :: B :: P :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpNPTmtmp;try rewrite HT2 in HOoBBpNPTmtmp.
	assert(HT := rule_2 (Oo :: B :: P :: nil) (Bp :: N :: P :: T :: nil) (P :: nil) 4 1 2 HOoBBpNPTmtmp HPmtmp HBpNPTMtmp Hincl);apply HT.
}


assert(HOoBPM : rk(Oo :: B :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBPeq HOoBPM3).
assert(HOoBPm : rk(Oo :: B :: P ::  nil) >= 1) by (solve_hyps_min HOoBPeq HOoBPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABP *)
(* dans la couche 0 *)
Lemma LOoABApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApMP requis par la preuve de (?)OoABApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApMP requis par la preuve de (?)OoABApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApMP requis par la preuve de (?)OoABApMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMPm2 : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMPm3 : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApMPm4 : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: Ap :: M :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApMPM : rk(Oo :: A :: B :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApMPm : rk(Oo :: A :: B :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABApMPeq HOoABApMPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABP *)
(* dans la couche 0 *)
Lemma LOoAApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMP requis par la preuve de (?)OoAApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMP requis par la preuve de (?)OoAApMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMPm3 : rk(Oo :: A :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMPm4 : rk(Oo :: A :: Ap :: M :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMPM : rk(Oo :: A :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMPm : rk(Oo :: A :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoAApMPeq HOoAApMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABP requis par la preuve de (?)OoABP pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABP requis par la preuve de (?)OoABP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABP requis par la preuve de (?)OoABP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABPm2 : rk(Oo :: A :: B :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABPM3 : rk(Oo :: A :: B :: P :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: P :: nil) (Oo :: A :: B :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: nil) ((Oo :: A :: B :: nil) ++ (P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (P :: nil) (nil) 2 1 0 HOoABMtmp HPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABPm3 : rk(Oo :: A :: B :: P :: nil) >= 3).
{
	try assert(HOoAApMPeq : rk(Oo :: A :: Ap :: M :: P :: nil) = 4) by (apply LOoAApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMPMtmp : rk(Oo :: A :: Ap :: M :: P :: nil) <= 4) by (solve_hyps_max HOoAApMPeq HOoAApMPM4).
	try assert(HOoABApMPeq : rk(Oo :: A :: B :: Ap :: M :: P :: nil) = 4) by (apply LOoABApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApMPmtmp : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABApMPeq HOoABApMPm4).
	try assert(HOoAPeq : rk(Oo :: A :: P :: nil) = 3) by (apply LOoAP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAPmtmp : rk(Oo :: A :: P :: nil) >= 3) by (solve_hyps_min HOoAPeq HOoAPm3).
	assert(Hincl : incl (Oo :: A :: P :: nil) (list_inter (Oo :: A :: B :: P :: nil) (Oo :: A :: Ap :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: P :: nil) (Oo :: A :: B :: P :: Oo :: A :: Ap :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: Oo :: A :: Ap :: M :: P :: nil) ((Oo :: A :: B :: P :: nil) ++ (Oo :: A :: Ap :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMPmtmp;try rewrite HT2 in HOoABApMPmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: P :: nil) (Oo :: A :: Ap :: M :: P :: nil) (Oo :: A :: P :: nil) 4 3 4 HOoABApMPmtmp HOoAPmtmp HOoAApMPMtmp Hincl);apply HT.
}


assert(HOoABPM : rk(Oo :: A :: B :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABPm : rk(Oo :: A :: B :: P ::  nil) >= 1) by (solve_hyps_min HOoABPeq HOoABPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApP *)
(* dans la couche 0 *)
Lemma LApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: M :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApMP requis par la preuve de (?)ApMP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: M :: P ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HApMPm3 : rk(Ap :: M :: P :: nil) >= 3).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HApBpMPeq : rk(Ap :: Bp :: M :: P :: nil) = 4) by (apply LApBpMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpMPmtmp : rk(Ap :: Bp :: M :: P :: nil) >= 4) by (solve_hyps_min HApBpMPeq HApBpMPm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Ap :: Bp :: nil) (Ap :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: M :: P :: nil) (Ap :: Bp :: Ap :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Ap :: M :: P :: nil) ((Ap :: Bp :: nil) ++ (Ap :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpMPmtmp;try rewrite HT2 in HApBpMPmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Ap :: M :: P :: nil) (Ap :: nil) 4 1 2 HApBpMPmtmp HApmtmp HApBpMtmp Hincl); apply HT.
}
try clear HApBpMPM1. try clear HApBpMPM2. try clear HApBpMPM3. try clear HApBpMPm4. try clear HApBpMPm3. try clear HApBpMPm2. try clear HApBpMPm1. 

assert(HApMPM : rk(Ap :: M :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApMPeq HApMPM3).
assert(HApMPm : rk(Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HApMPeq HApMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: P ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApP requis par la preuve de (?)ApP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: M :: P ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : Ap :: M ::   de rang : 2 et 2 *)
assert(HApPm2 : rk(Ap :: P :: nil) >= 2).
{
	try assert(HApMeq : rk(Ap :: M :: nil) = 2) by (apply LApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMMtmp : rk(Ap :: M :: nil) <= 2) by (solve_hyps_max HApMeq HApMM2).
	try assert(HApMPeq : rk(Ap :: M :: P :: nil) = 3) by (apply LApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMPmtmp : rk(Ap :: M :: P :: nil) >= 3) by (solve_hyps_min HApMPeq HApMPm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Ap :: M :: nil) (Ap :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: M :: P :: nil) (Ap :: M :: Ap :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: M :: Ap :: P :: nil) ((Ap :: M :: nil) ++ (Ap :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApMPmtmp;try rewrite HT2 in HApMPmtmp.
	assert(HT := rule_4 (Ap :: M :: nil) (Ap :: P :: nil) (Ap :: nil) 3 1 2 HApMPmtmp HApmtmp HApMMtmp Hincl); apply HT.
}
try clear HApMM1. try clear HApMM2. try clear HApMM3. try clear HApMm4. try clear HApMm3. try clear HApMm2. try clear HApMm1. try clear HApMPM1. try clear HApMPM2. try clear HApMPM3. try clear HApMPm4. try clear HApMPm3. try clear HApMPm2. try clear HApMPm1. 

assert(HApPM : rk(Ap :: P ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApPeq HApPM2).
assert(HApPm : rk(Ap :: P ::  nil) >= 1) by (solve_hyps_min HApPeq HApPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApP *)
(* dans la couche 0 *)
Lemma LOoAApMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: M :: P :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApMPU requis par la preuve de (?)OoAApMPU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApMPU requis par la preuve de (?)OoAApMPU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMPUm3 : rk(Oo :: A :: Ap :: M :: P :: U :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: M :: P :: U :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApMPUm4 : rk(Oo :: A :: Ap :: M :: P :: U :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: P :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: Ap :: M :: P :: U :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApMPUM : rk(Oo :: A :: Ap :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApMPUm : rk(Oo :: A :: Ap :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HOoAApMPUeq HOoAApMPUm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApP *)
(* dans la couche 0 *)
Lemma LAMPU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: M :: P :: U ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HAMPUM : rk(A :: M :: P :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAMPUm : rk(A :: M :: P :: U ::  nil) >= 1) by (solve_hyps_min HAMPUeq HAMPUm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApP requis par la preuve de (?)OoApP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApP requis par la preuve de (?)OoApP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApP requis par la preuve de (?)OoAApP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApPm3 : rk(Oo :: A :: Ap :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAP requis par la preuve de (?)OoApP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpP requis par la preuve de (?)OoAP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpP requis par la preuve de (?)OoAApBpP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpPm3 : rk(Oo :: A :: Ap :: Bp :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAP requis par la preuve de (?)OoAP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: P ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoAPm2 : rk(Oo :: A :: P :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpPmtmp : rk(Oo :: A :: Ap :: Bp :: P :: nil) >= 3) by (solve_hyps_min HOoAApBpPeq HOoAApBpPm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Oo :: A :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: P :: nil) (Oo :: Ap :: Bp :: Oo :: A :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Oo :: A :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Oo :: A :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpPmtmp;try rewrite HT2 in HOoAApBpPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Oo :: A :: P :: nil) (Oo :: nil) 3 1 2 HOoAApBpPmtmp HOomtmp HOoApBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApP requis par la preuve de (?)OoApP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: Ap :: P ::  de rang :  3 et 4 	 AiB : Oo :: P ::  de rang :  2 et 2 	 A : Oo :: A :: P ::   de rang : 2 et 3 *)
assert(HOoApPm2 : rk(Oo :: Ap :: P :: nil) >= 2).
{
	assert(HOoAPMtmp : rk(Oo :: A :: P :: nil) <= 3) by (solve_hyps_max HOoAPeq HOoAPM3).
	assert(HOoAApPmtmp : rk(Oo :: A :: Ap :: P :: nil) >= 3) by (solve_hyps_min HOoAApPeq HOoAApPm3).
	try assert(HOoPeq : rk(Oo :: P :: nil) = 2) by (apply LOoP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoPmtmp : rk(Oo :: P :: nil) >= 2) by (solve_hyps_min HOoPeq HOoPm2).
	assert(Hincl : incl (Oo :: P :: nil) (list_inter (Oo :: A :: P :: nil) (Oo :: Ap :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: P :: nil) (Oo :: A :: P :: Oo :: Ap :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: P :: Oo :: Ap :: P :: nil) ((Oo :: A :: P :: nil) ++ (Oo :: Ap :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApPmtmp;try rewrite HT2 in HOoAApPmtmp.
	assert(HT := rule_4 (Oo :: A :: P :: nil) (Oo :: Ap :: P :: nil) (Oo :: P :: nil) 3 2 3 HOoAApPmtmp HOoPmtmp HOoAPMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApPm3 : rk(Oo :: Ap :: P :: nil) >= 3).
{
	try assert(HAMPUeq : rk(A :: M :: P :: U :: nil) = 2) by (apply LAMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAMPUMtmp : rk(A :: M :: P :: U :: nil) <= 2) by (solve_hyps_max HAMPUeq HAMPUM2).
	try assert(HOoAApMPUeq : rk(Oo :: A :: Ap :: M :: P :: U :: nil) = 4) by (apply LOoAApMPU with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMPUmtmp : rk(Oo :: A :: Ap :: M :: P :: U :: nil) >= 4) by (solve_hyps_min HOoAApMPUeq HOoAApMPUm4).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPmtmp : rk(P :: nil) >= 1) by (solve_hyps_min HPeq HPm1).
	assert(Hincl : incl (P :: nil) (list_inter (Oo :: Ap :: P :: nil) (A :: M :: P :: U :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: M :: P :: U :: nil) (Oo :: Ap :: P :: A :: M :: P :: U :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: P :: A :: M :: P :: U :: nil) ((Oo :: Ap :: P :: nil) ++ (A :: M :: P :: U :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApMPUmtmp;try rewrite HT2 in HOoAApMPUmtmp.
	assert(HT := rule_2 (Oo :: Ap :: P :: nil) (A :: M :: P :: U :: nil) (P :: nil) 4 1 2 HOoAApMPUmtmp HPmtmp HAMPUMtmp Hincl);apply HT.
}
try clear HAMPUM1. try clear HAMPUM2. try clear HAMPUM3. try clear HAMPUm4. try clear HAMPUm3. try clear HAMPUm2. try clear HAMPUm1. 

assert(HOoApPM : rk(Oo :: Ap :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApPeq HOoApPM3).
assert(HOoApPm : rk(Oo :: Ap :: P ::  nil) >= 1) by (solve_hyps_min HOoApPeq HOoApPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApP *)
(* dans constructLemma(), requis par LOoAApBpNPT *)
(* dans la couche 0 *)
Lemma LOoABApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpNPT requis par la preuve de (?)OoABApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpNPT requis par la preuve de (?)OoABApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpNPT requis par la preuve de (?)OoABApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNPTm2 : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNPTm3 : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpNPTm4 : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpNPTM : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpNPTm : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoABApBpNPTeq HOoABApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpNPT requis par la preuve de (?)OoAApBpNPT pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpNPT requis par la preuve de (?)OoAApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpNPTm3 : rk(Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: N :: P :: T ::  de rang :  4 et 4 	 AiB : Oo :: A :: P ::  de rang :  3 et 3 	 A : Oo :: A :: B :: P ::   de rang : 3 et 3 *)
assert(HOoAApBpNPTm4 : rk(Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoABPeq : rk(Oo :: A :: B :: P :: nil) = 3) by (apply LOoABP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABPMtmp : rk(Oo :: A :: B :: P :: nil) <= 3) by (solve_hyps_max HOoABPeq HOoABPM3).
	try assert(HOoABApBpNPTeq : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoABApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpNPTmtmp : rk(Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoABApBpNPTeq HOoABApBpNPTm4).
	try assert(HOoAPeq : rk(Oo :: A :: P :: nil) = 3) by (apply LOoAP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAPmtmp : rk(Oo :: A :: P :: nil) >= 3) by (solve_hyps_min HOoAPeq HOoAPm3).
	assert(Hincl : incl (Oo :: A :: P :: nil) (list_inter (Oo :: A :: B :: P :: nil) (Oo :: A :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: A :: B :: P :: Oo :: A :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: A :: B :: P :: nil) ++ (Oo :: A :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpNPTmtmp;try rewrite HT2 in HOoABApBpNPTmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: P :: nil) (Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: A :: P :: nil) 4 3 3 HOoABApBpNPTmtmp HOoAPmtmp HOoABPMtmp Hincl); apply HT.
}


assert(HOoAApBpNPTM : rk(Oo :: A :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpNPTm : rk(Oo :: A :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoAApBpNPTeq HOoAApBpNPTm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApP *)
(* dans la couche 0 *)
Lemma LOoApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: N :: P :: T ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpNPT requis par la preuve de (?)OoApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpNPT requis par la preuve de (?)OoApBpNPT pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpNPT requis par la preuve de (?)OoApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNPTm2 : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApBpNPTM3 : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: Ap :: Bp :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Bp :: N :: P :: T :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (Bp :: N :: P :: T :: nil) (Bp :: nil) 2 2 1 HOoApBpMtmp HBpNPTMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpNPTm3 : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) >= 3).
{
	try assert(HApBpNeq : rk(Ap :: Bp :: N :: nil) = 3) by (apply LApBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpNmtmp : rk(Ap :: Bp :: N :: nil) >= 3) by (solve_hyps_min HApBpNeq HApBpNm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: N :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: N :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil) 3 3 HApBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoApBpNPTM : rk(Oo :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpNPTm : rk(Oo :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoApBpNPTeq HOoApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApP requis par la preuve de (?)OoAApP pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApP requis par la preuve de (?)OoAApP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApPm3 : rk(Oo :: A :: Ap :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAApPm4 : rk(Oo :: A :: Ap :: P :: nil) >= 4).
{
	try assert(HOoApBpNPTeq : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) = 3) by (apply LOoApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpNPTMtmp : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) <= 3) by (solve_hyps_max HOoApBpNPTeq HOoApBpNPTM3).
	try assert(HOoAApBpNPTeq : rk(Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoAApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpNPTmtmp : rk(Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoAApBpNPTeq HOoAApBpNPTm4).
	try assert(HOoApPeq : rk(Oo :: Ap :: P :: nil) = 3) by (apply LOoApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApPmtmp : rk(Oo :: Ap :: P :: nil) >= 3) by (solve_hyps_min HOoApPeq HOoApPm3).
	assert(Hincl : incl (Oo :: Ap :: P :: nil) (list_inter (Oo :: A :: Ap :: P :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: A :: Ap :: P :: Oo :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: P :: Oo :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: A :: Ap :: P :: nil) ++ (Oo :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpNPTmtmp;try rewrite HT2 in HOoAApBpNPTmtmp.
	assert(HT := rule_2 (Oo :: A :: Ap :: P :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: Ap :: P :: nil) 4 3 3 HOoAApBpNPTmtmp HOoApPmtmp HOoApBpNPTMtmp Hincl);apply HT.
}


assert(HOoAApPM : rk(Oo :: A :: Ap :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApPm : rk(Oo :: A :: Ap :: P ::  nil) >= 1) by (solve_hyps_min HOoAApPeq HOoAApPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApP *)
(* dans la couche 0 *)
Lemma LOoBApBpNPT : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: N :: P :: T ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpNPT requis par la preuve de (?)OoBApBpNPT pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpNPT requis par la preuve de (?)OoBApBpNPT pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNPTm2 : rk(Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNPTm4 : rk(Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: T :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApBpNPTM : rk(Oo :: B :: Ap :: Bp :: N :: P :: T ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpNPTm : rk(Oo :: B :: Ap :: Bp :: N :: P :: T ::  nil) >= 1) by (solve_hyps_min HOoBApBpNPTeq HOoBApBpNPTm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApP requis par la preuve de (?)OoBApP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApP requis par la preuve de (?)OoBApP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApP requis par la preuve de (?)OoABApP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApP requis par la preuve de (?)OoABApP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApPm2 : rk(Oo :: A :: B :: Ap :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApPm3 : rk(Oo :: A :: B :: Ap :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABP requis par la preuve de (?)OoBApP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABP requis par la preuve de (?)OoABP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABP requis par la preuve de (?)OoABP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABPm2 : rk(Oo :: A :: B :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABPM3 : rk(Oo :: A :: B :: P :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: P :: nil) (Oo :: A :: B :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: nil) ((Oo :: A :: B :: nil) ++ (P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (P :: nil) (nil) 2 1 0 HOoABMtmp HPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApP requis par la preuve de (?)OoBApP pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBApP pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBCApYMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBCApYMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBCApYMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApYMPm2 : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApYMPm3 : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 3).
{
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) 3 3 HBCMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApYMPm4 : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApP requis par la preuve de (?)OoBApP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Y :: M :: P ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap :: Y :: M ::   de rang : 3 et 3 *)
assert(HOoBApPm2 : rk(Oo :: B :: Ap :: P :: nil) >= 2).
{
	try assert(HCApYMeq : rk(C :: Ap :: Y :: M :: nil) = 3) by (apply LCApYM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCApYMMtmp : rk(C :: Ap :: Y :: M :: nil) <= 3) by (solve_hyps_max HCApYMeq HCApYMM3).
	assert(HOoBCApYMPmtmp : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 4) by (solve_hyps_min HOoBCApYMPeq HOoBCApYMPm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: Y :: M :: nil) (Oo :: B :: Ap :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) (C :: Ap :: Y :: M :: Oo :: B :: Ap :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Y :: M :: Oo :: B :: Ap :: P :: nil) ((C :: Ap :: Y :: M :: nil) ++ (Oo :: B :: Ap :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApYMPmtmp;try rewrite HT2 in HOoBCApYMPmtmp.
	assert(HT := rule_4 (C :: Ap :: Y :: M :: nil) (Oo :: B :: Ap :: P :: nil) (Ap :: nil) 4 1 3 HOoBCApYMPmtmp HApmtmp HCApYMMtmp Hincl); apply HT.
}
try clear HOoBCApYMPM1. try clear HOoBCApYMPM2. try clear HOoBCApYMPM3. try clear HOoBCApYMPm4. try clear HOoBCApYMPm3. try clear HOoBCApYMPm2. try clear HOoBCApYMPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: P ::  de rang :  3 et 4 	 AiB : Oo :: B :: P ::  de rang :  3 et 3 	 A : Oo :: A :: B :: P ::   de rang : 2 et 3 *)
assert(HOoBApPm3 : rk(Oo :: B :: Ap :: P :: nil) >= 3).
{
	assert(HOoABPMtmp : rk(Oo :: A :: B :: P :: nil) <= 3) by (solve_hyps_max HOoABPeq HOoABPM3).
	assert(HOoABApPmtmp : rk(Oo :: A :: B :: Ap :: P :: nil) >= 3) by (solve_hyps_min HOoABApPeq HOoABApPm3).
	try assert(HOoBPeq : rk(Oo :: B :: P :: nil) = 3) by (apply LOoBP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBPmtmp : rk(Oo :: B :: P :: nil) >= 3) by (solve_hyps_min HOoBPeq HOoBPm3).
	assert(Hincl : incl (Oo :: B :: P :: nil) (list_inter (Oo :: A :: B :: P :: nil) (Oo :: B :: Ap :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: B :: P :: Oo :: B :: Ap :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: Oo :: B :: Ap :: P :: nil) ((Oo :: A :: B :: P :: nil) ++ (Oo :: B :: Ap :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApPmtmp;try rewrite HT2 in HOoABApPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: P :: nil) (Oo :: B :: Ap :: P :: nil) (Oo :: B :: P :: nil) 3 3 3 HOoABApPmtmp HOoBPmtmp HOoABPMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApPm4 : rk(Oo :: B :: Ap :: P :: nil) >= 4).
{
	try assert(HOoApBpNPTeq : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) = 3) by (apply LOoApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpNPTMtmp : rk(Oo :: Ap :: Bp :: N :: P :: T :: nil) <= 3) by (solve_hyps_max HOoApBpNPTeq HOoApBpNPTM3).
	try assert(HOoBApBpNPTeq : rk(Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBApBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBApBpNPTmtmp : rk(Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBApBpNPTeq HOoBApBpNPTm4).
	try assert(HOoApPeq : rk(Oo :: Ap :: P :: nil) = 3) by (apply LOoApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApPmtmp : rk(Oo :: Ap :: P :: nil) >= 3) by (solve_hyps_min HOoApPeq HOoApPm3).
	assert(Hincl : incl (Oo :: Ap :: P :: nil) (list_inter (Oo :: B :: Ap :: P :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: B :: Ap :: P :: Oo :: Ap :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: P :: Oo :: Ap :: Bp :: N :: P :: T :: nil) ((Oo :: B :: Ap :: P :: nil) ++ (Oo :: Ap :: Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpNPTmtmp;try rewrite HT2 in HOoBApBpNPTmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: P :: nil) (Oo :: Ap :: Bp :: N :: P :: T :: nil) (Oo :: Ap :: P :: nil) 4 3 3 HOoBApBpNPTmtmp HOoApPmtmp HOoApBpNPTMtmp Hincl);apply HT.
}


assert(HOoBApPM : rk(Oo :: B :: Ap :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApPm : rk(Oo :: B :: Ap :: P ::  nil) >= 1) by (solve_hyps_min HOoBApPeq HOoBApPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApP requis par la preuve de (?)OoABApP pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApP requis par la preuve de (?)OoABApP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApP requis par la preuve de (?)OoABApP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApPm2 : rk(Oo :: A :: B :: Ap :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApPm3 : rk(Oo :: A :: B :: Ap :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABApPm4 : rk(Oo :: A :: B :: Ap :: P :: nil) >= 4).
{
	try assert(HOoAApMPeq : rk(Oo :: A :: Ap :: M :: P :: nil) = 4) by (apply LOoAApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMPMtmp : rk(Oo :: A :: Ap :: M :: P :: nil) <= 4) by (solve_hyps_max HOoAApMPeq HOoAApMPM4).
	try assert(HOoABApMPeq : rk(Oo :: A :: B :: Ap :: M :: P :: nil) = 4) by (apply LOoABApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApMPmtmp : rk(Oo :: A :: B :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABApMPeq HOoABApMPm4).
	try assert(HOoAApPeq : rk(Oo :: A :: Ap :: P :: nil) = 4) by (apply LOoAApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApPmtmp : rk(Oo :: A :: Ap :: P :: nil) >= 4) by (solve_hyps_min HOoAApPeq HOoAApPm4).
	assert(Hincl : incl (Oo :: A :: Ap :: P :: nil) (list_inter (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: Ap :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: M :: P :: nil) (Oo :: A :: B :: Ap :: P :: Oo :: A :: Ap :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: P :: Oo :: A :: Ap :: M :: P :: nil) ((Oo :: A :: B :: Ap :: P :: nil) ++ (Oo :: A :: Ap :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApMPmtmp;try rewrite HT2 in HOoABApMPmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: Ap :: M :: P :: nil) (Oo :: A :: Ap :: P :: nil) 4 4 4 HOoABApMPmtmp HOoAApPmtmp HOoAApMPMtmp Hincl);apply HT.
}


assert(HOoABApPM : rk(Oo :: A :: B :: Ap :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApPm : rk(Oo :: A :: B :: Ap :: P ::  nil) >= 1) by (solve_hyps_min HOoABApPeq HOoABApPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCApP *)
(* dans la couche 0 *)
Lemma LOoABCApMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApMP requis par la preuve de (?)OoABCApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApMP requis par la preuve de (?)OoABCApMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApMP requis par la preuve de (?)OoABCApMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMPm2 : rk(Oo :: A :: B :: C :: Ap :: M :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: M :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMPm3 : rk(Oo :: A :: B :: C :: Ap :: M :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: M :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApMPm4 : rk(Oo :: A :: B :: C :: Ap :: M :: P :: nil) >= 4).
{
	try assert(HOoAApMeq : rk(Oo :: A :: Ap :: M :: nil) = 4) by (apply LOoAApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMmtmp : rk(Oo :: A :: Ap :: M :: nil) >= 4) by (solve_hyps_min HOoAApMeq HOoAApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: C :: Ap :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: M :: nil) (Oo :: A :: B :: C :: Ap :: M :: P :: nil) 4 4 HOoAApMmtmp Hcomp Hincl);apply HT.
}
try clear HOoAApMM1. try clear HOoAApMM2. try clear HOoAApMM3. try clear HOoAApMm4. try clear HOoAApMm3. try clear HOoAApMm2. try clear HOoAApMm1. 

assert(HOoABCApMPM : rk(Oo :: A :: B :: C :: Ap :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApMPm : rk(Oo :: A :: B :: C :: Ap :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoABCApMPeq HOoABCApMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApP requis par la preuve de (?)OoABCApP pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApP requis par la preuve de (?)OoABCApP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApP requis par la preuve de (?)OoABCApP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApPm2 : rk(Oo :: A :: B :: C :: Ap :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApPm3 : rk(Oo :: A :: B :: C :: Ap :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCApPm4 : rk(Oo :: A :: B :: C :: Ap :: P :: nil) >= 4).
{
	try assert(HOoAApMPeq : rk(Oo :: A :: Ap :: M :: P :: nil) = 4) by (apply LOoAApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApMPMtmp : rk(Oo :: A :: Ap :: M :: P :: nil) <= 4) by (solve_hyps_max HOoAApMPeq HOoAApMPM4).
	try assert(HOoABCApMPeq : rk(Oo :: A :: B :: C :: Ap :: M :: P :: nil) = 4) by (apply LOoABCApMP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApMPmtmp : rk(Oo :: A :: B :: C :: Ap :: M :: P :: nil) >= 4) by (solve_hyps_min HOoABCApMPeq HOoABCApMPm4).
	try assert(HOoAApPeq : rk(Oo :: A :: Ap :: P :: nil) = 4) by (apply LOoAApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApPmtmp : rk(Oo :: A :: Ap :: P :: nil) >= 4) by (solve_hyps_min HOoAApPeq HOoAApPm4).
	assert(Hincl : incl (Oo :: A :: Ap :: P :: nil) (list_inter (Oo :: A :: B :: C :: Ap :: P :: nil) (Oo :: A :: Ap :: M :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: M :: P :: nil) (Oo :: A :: B :: C :: Ap :: P :: Oo :: A :: Ap :: M :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: P :: Oo :: A :: Ap :: M :: P :: nil) ((Oo :: A :: B :: C :: Ap :: P :: nil) ++ (Oo :: A :: Ap :: M :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApMPmtmp;try rewrite HT2 in HOoABCApMPmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: C :: Ap :: P :: nil) (Oo :: A :: Ap :: M :: P :: nil) (Oo :: A :: Ap :: P :: nil) 4 4 4 HOoABCApMPmtmp HOoAApPmtmp HOoAApMPMtmp Hincl);apply HT.
}


assert(HOoABCApPM : rk(Oo :: A :: B :: C :: Ap :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApPm : rk(Oo :: A :: B :: C :: Ap :: P ::  nil) >= 1) by (solve_hyps_min HOoABCApPeq HOoABCApPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Bp :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpP requis par la preuve de (?)OoBpP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: P ::  de rang :  4 et 4 	 AiB : Oo :: P ::  de rang :  2 et 2 	 A : Oo :: A :: P ::   de rang : 3 et 3 *)
assert(HOoBpPm3 : rk(Oo :: Bp :: P :: nil) >= 3).
{
	try assert(HOoAPeq : rk(Oo :: A :: P :: nil) = 3) by (apply LOoAP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAPMtmp : rk(Oo :: A :: P :: nil) <= 3) by (solve_hyps_max HOoAPeq HOoAPM3).
	try assert(HOoABpPeq : rk(Oo :: A :: Bp :: P :: nil) = 4) by (apply LOoABpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABpPmtmp : rk(Oo :: A :: Bp :: P :: nil) >= 4) by (solve_hyps_min HOoABpPeq HOoABpPm4).
	try assert(HOoPeq : rk(Oo :: P :: nil) = 2) by (apply LOoP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoPmtmp : rk(Oo :: P :: nil) >= 2) by (solve_hyps_min HOoPeq HOoPm2).
	assert(Hincl : incl (Oo :: P :: nil) (list_inter (Oo :: A :: P :: nil) (Oo :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: P :: nil) (Oo :: A :: P :: Oo :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: P :: Oo :: Bp :: P :: nil) ((Oo :: A :: P :: nil) ++ (Oo :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpPmtmp;try rewrite HT2 in HOoABpPmtmp.
	assert(HT := rule_4 (Oo :: A :: P :: nil) (Oo :: Bp :: P :: nil) (Oo :: P :: nil) 4 2 3 HOoABpPmtmp HOoPmtmp HOoAPMtmp Hincl); apply HT.
}


assert(HOoBpPM : rk(Oo :: Bp :: P ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpPeq HOoBpPM3).
assert(HOoBpPm : rk(Oo :: Bp :: P ::  nil) >= 1) by (solve_hyps_min HOoBpPeq HOoBpPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBpP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Bp :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpP requis par la preuve de (?)OoBBpP pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpP requis par la preuve de (?)OoBBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm2 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm4 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpXN requis par la preuve de (?)OoABBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpXN requis par la preuve de (?)ABpXN pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpXN requis par la preuve de (?)ABpXN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpXN requis par la preuve de (?)OoAApBpXN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXNm3 : rk(Oo :: A :: Ap :: Bp :: X :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpXN requis par la preuve de (?)ABpXN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X :: N ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HABpXNm2 : rk(A :: Bp :: X :: N :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpXNmtmp : rk(Oo :: A :: Ap :: Bp :: X :: N :: nil) >= 3) by (solve_hyps_min HOoAApBpXNeq HOoAApBpXNm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: N :: nil) (Oo :: Ap :: Bp :: A :: Bp :: X :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Bp :: X :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Bp :: X :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXNmtmp;try rewrite HT2 in HOoAApBpXNmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: N :: nil) (Bp :: nil) 3 1 2 HOoAApBpXNmtmp HBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpXNM1. try clear HOoAApBpXNM2. try clear HOoAApBpXNM3. try clear HOoAApBpXNm4. try clear HOoAApBpXNm3. try clear HOoAApBpXNm2. try clear HOoAApBpXNm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpXNM3 : rk(A :: Bp :: X :: N :: nil) <= 3).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: X :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: X :: N :: nil) (A :: Bp :: X :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: X :: N :: nil) ((A :: Bp :: X :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Bp :: X :: nil) (N :: nil) (nil) 2 1 0 HABpXMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpP requis par la preuve de (?)OoABBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpP requis par la preuve de (?)OoABBpP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpPm2 : rk(Oo :: A :: B :: Bp :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: X :: N :: P ::  de rang :  4 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : A :: Bp :: X :: N ::   de rang : 2 et 3 *)
assert(HOoABBpPm3 : rk(Oo :: A :: B :: Bp :: P :: nil) >= 3).
{
	assert(HABpXNMtmp : rk(A :: Bp :: X :: N :: nil) <= 3) by (solve_hyps_max HABpXNeq HABpXNM3).
	assert(HOoABBpXNPmtmp : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABBpXNPeq HOoABBpXNPm4).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (A :: Bp :: X :: N :: nil) (Oo :: A :: B :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: X :: N :: P :: nil) (A :: Bp :: X :: N :: Oo :: A :: B :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: X :: N :: Oo :: A :: B :: Bp :: P :: nil) ((A :: Bp :: X :: N :: nil) ++ (Oo :: A :: B :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpXNPmtmp;try rewrite HT2 in HOoABBpXNPmtmp.
	assert(HT := rule_4 (A :: Bp :: X :: N :: nil) (Oo :: A :: B :: Bp :: P :: nil) (A :: Bp :: nil) 4 2 3 HOoABBpXNPmtmp HABpmtmp HABpXNMtmp Hincl); apply HT.
}
try clear HABpXNM1. try clear HABpXNM2. try clear HABpXNM3. try clear HABpXNm4. try clear HABpXNm3. try clear HABpXNm2. try clear HABpXNm1. try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. try clear HOoABBpXNPM1. try clear HOoABBpXNPM2. try clear HOoABBpXNPM3. try clear HOoABBpXNPm4. try clear HOoABBpXNPm3. try clear HOoABBpXNPm2. try clear HOoABBpXNPm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABP requis par la preuve de (?)OoBBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABP requis par la preuve de (?)OoABP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABP requis par la preuve de (?)OoABP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABPm2 : rk(Oo :: A :: B :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABPM3 : rk(Oo :: A :: B :: P :: nil) <= 3).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: B :: nil) (P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: P :: nil) (Oo :: A :: B :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: nil) ((Oo :: A :: B :: nil) ++ (P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: B :: nil) (P :: nil) (nil) 2 1 0 HOoABMtmp HPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpP requis par la preuve de (?)OoBBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpNP requis par la preuve de (?)OoBBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpNP requis par la preuve de (?)OoBCBpNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNP requis par la preuve de (?)OoBCBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNPm2 : rk(Oo :: B :: C :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNPm4 : rk(Oo :: B :: C :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpN requis par la preuve de (?)OoBBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpN requis par la preuve de (?)CBpN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: N ::  de rang :  4 et 4 	 AiB : Bp :: N ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Bp :: N ::   de rang : 4 et 4 *)
assert(HCBpNm2 : rk(C :: Bp :: N :: nil) >= 2).
{
	try assert(HOoABBpNeq : rk(Oo :: A :: B :: Bp :: N :: nil) = 4) by (apply LOoABBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABBpNMtmp : rk(Oo :: A :: B :: Bp :: N :: nil) <= 4) by (solve_hyps_max HOoABBpNeq HOoABBpNM4).
	try assert(HOoABCBpNeq : rk(Oo :: A :: B :: C :: Bp :: N :: nil) = 4) by (apply LOoABCBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCBpNmtmp : rk(Oo :: A :: B :: C :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoABCBpNeq HOoABCBpNm4).
	try assert(HBpNeq : rk(Bp :: N :: nil) = 2) by (apply LBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpNmtmp : rk(Bp :: N :: nil) >= 2) by (solve_hyps_min HBpNeq HBpNm2).
	assert(Hincl : incl (Bp :: N :: nil) (list_inter (Oo :: A :: B :: Bp :: N :: nil) (C :: Bp :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: N :: C :: Bp :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: N :: C :: Bp :: N :: nil) ((Oo :: A :: B :: Bp :: N :: nil) ++ (C :: Bp :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpNmtmp;try rewrite HT2 in HOoABCBpNmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: N :: nil) (C :: Bp :: N :: nil) (Bp :: N :: nil) 4 2 4 HOoABCBpNmtmp HBpNmtmp HOoABBpNMtmp Hincl); apply HT.
}
try clear HBpNM1. try clear HBpNM2. try clear HBpNM3. try clear HBpNm4. try clear HBpNm3. try clear HBpNm2. try clear HBpNm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpP requis par la preuve de (?)OoBBpP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: N :: P ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : C :: Bp :: N ::   de rang : 2 et 3 *)
assert(HOoBBpPm2 : rk(Oo :: B :: Bp :: P :: nil) >= 2).
{
	assert(HCBpNMtmp : rk(C :: Bp :: N :: nil) <= 3) by (solve_hyps_max HCBpNeq HCBpNM3).
	assert(HOoBCBpNPmtmp : rk(Oo :: B :: C :: Bp :: N :: P :: nil) >= 4) by (solve_hyps_min HOoBCBpNPeq HOoBCBpNPm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (C :: Bp :: N :: nil) (Oo :: B :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: N :: P :: nil) (C :: Bp :: N :: Oo :: B :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: N :: Oo :: B :: Bp :: P :: nil) ((C :: Bp :: N :: nil) ++ (Oo :: B :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpNPmtmp;try rewrite HT2 in HOoBCBpNPmtmp.
	assert(HT := rule_4 (C :: Bp :: N :: nil) (Oo :: B :: Bp :: P :: nil) (Bp :: nil) 4 1 3 HOoBCBpNPmtmp HBpmtmp HCBpNMtmp Hincl); apply HT.
}
try clear HCBpNM1. try clear HCBpNM2. try clear HCBpNM3. try clear HCBpNm4. try clear HCBpNm3. try clear HCBpNm2. try clear HCBpNm1. try clear HOoBCBpNPM1. try clear HOoBCBpNPM2. try clear HOoBCBpNPM3. try clear HOoBCBpNPm4. try clear HOoBCBpNPm3. try clear HOoBCBpNPm2. try clear HOoBCBpNPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: P ::  de rang :  3 et 4 	 AiB : Oo :: B :: P ::  de rang :  3 et 3 	 A : Oo :: A :: B :: P ::   de rang : 2 et 3 *)
assert(HOoBBpPm3 : rk(Oo :: B :: Bp :: P :: nil) >= 3).
{
	assert(HOoABPMtmp : rk(Oo :: A :: B :: P :: nil) <= 3) by (solve_hyps_max HOoABPeq HOoABPM3).
	assert(HOoABBpPmtmp : rk(Oo :: A :: B :: Bp :: P :: nil) >= 3) by (solve_hyps_min HOoABBpPeq HOoABBpPm3).
	try assert(HOoBPeq : rk(Oo :: B :: P :: nil) = 3) by (apply LOoBP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBPmtmp : rk(Oo :: B :: P :: nil) >= 3) by (solve_hyps_min HOoBPeq HOoBPm3).
	assert(Hincl : incl (Oo :: B :: P :: nil) (list_inter (Oo :: A :: B :: P :: nil) (Oo :: B :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: P :: nil) (Oo :: A :: B :: P :: Oo :: B :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: Oo :: B :: Bp :: P :: nil) ((Oo :: A :: B :: P :: nil) ++ (Oo :: B :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpPmtmp;try rewrite HT2 in HOoABBpPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: P :: nil) (Oo :: B :: Bp :: P :: nil) (Oo :: B :: P :: nil) 3 3 3 HOoABBpPmtmp HOoBPmtmp HOoABPMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBBpPm4 : rk(Oo :: B :: Bp :: P :: nil) >= 4).
{
	try assert(HBpNPTeq : rk(Bp :: N :: P :: T :: nil) = 2) by (apply LBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpNPTMtmp : rk(Bp :: N :: P :: T :: nil) <= 2) by (solve_hyps_max HBpNPTeq HBpNPTM2).
	try assert(HOoBBpNPTeq : rk(Oo :: B :: Bp :: N :: P :: T :: nil) = 4) by (apply LOoBBpNPT with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNPTmtmp : rk(Oo :: B :: Bp :: N :: P :: T :: nil) >= 4) by (solve_hyps_min HOoBBpNPTeq HOoBBpNPTm4).
	try assert(HBpPeq : rk(Bp :: P :: nil) = 2) by (apply LBpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpPmtmp : rk(Bp :: P :: nil) >= 2) by (solve_hyps_min HBpPeq HBpPm2).
	assert(Hincl : incl (Bp :: P :: nil) (list_inter (Oo :: B :: Bp :: P :: nil) (Bp :: N :: P :: T :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: N :: P :: T :: nil) (Oo :: B :: Bp :: P :: Bp :: N :: P :: T :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: P :: Bp :: N :: P :: T :: nil) ((Oo :: B :: Bp :: P :: nil) ++ (Bp :: N :: P :: T :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpNPTmtmp;try rewrite HT2 in HOoBBpNPTmtmp.
	assert(HT := rule_2 (Oo :: B :: Bp :: P :: nil) (Bp :: N :: P :: T :: nil) (Bp :: P :: nil) 4 2 2 HOoBBpNPTmtmp HBpPmtmp HBpNPTMtmp Hincl);apply HT.
}
try clear HBpPM1. try clear HBpPM2. try clear HBpPM3. try clear HBpPm4. try clear HBpPm3. try clear HBpPm2. try clear HBpPm1. try clear HOoBBpNPTM1. try clear HOoBBpNPTM2. try clear HOoBBpNPTM3. try clear HOoBBpNPTm4. try clear HOoBBpNPTm3. try clear HOoBBpNPTm2. try clear HOoBBpNPTm1. 

assert(HOoBBpPM : rk(Oo :: B :: Bp :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpPm : rk(Oo :: B :: Bp :: P ::  nil) >= 1) by (solve_hyps_min HOoBBpPeq HOoBBpPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpP requis par la preuve de (?)OoABBpP pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm2 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm4 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpXN requis par la preuve de (?)OoABBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpXN requis par la preuve de (?)ABpXN pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpXN requis par la preuve de (?)ABpXN pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpXN requis par la preuve de (?)OoAApBpXN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXNm3 : rk(Oo :: A :: Ap :: Bp :: X :: N :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: N :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpXN requis par la preuve de (?)ABpXN pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X :: N ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HABpXNm2 : rk(A :: Bp :: X :: N :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpXNmtmp : rk(Oo :: A :: Ap :: Bp :: X :: N :: nil) >= 3) by (solve_hyps_min HOoAApBpXNeq HOoAApBpXNm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: N :: nil) (Oo :: Ap :: Bp :: A :: Bp :: X :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Bp :: X :: N :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Bp :: X :: N :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXNmtmp;try rewrite HT2 in HOoAApBpXNmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Bp :: X :: N :: nil) (Bp :: nil) 3 1 2 HOoAApBpXNmtmp HBpmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoAApBpXNM1. try clear HOoAApBpXNM2. try clear HOoAApBpXNM3. try clear HOoAApBpXNm4. try clear HOoAApBpXNm3. try clear HOoAApBpXNm2. try clear HOoAApBpXNm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpXNM3 : rk(A :: Bp :: X :: N :: nil) <= 3).
{
	try assert(HABpXeq : rk(A :: Bp :: X :: nil) = 2) by (apply LABpX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpXMtmp : rk(A :: Bp :: X :: nil) <= 2) by (solve_hyps_max HABpXeq HABpXM2).
	try assert(HNeq : rk(N :: nil) = 1) by (apply LN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HNMtmp : rk(N :: nil) <= 1) by (solve_hyps_max HNeq HNM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: X :: nil) (N :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: X :: N :: nil) (A :: Bp :: X :: N :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: X :: N :: nil) ((A :: Bp :: X :: nil) ++ (N :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Bp :: X :: nil) (N :: nil) (nil) 2 1 0 HABpXMtmp HNMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpP requis par la preuve de (?)OoABBpP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpP requis par la preuve de (?)OoABBpP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpPm2 : rk(Oo :: A :: B :: Bp :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: X :: N :: P ::  de rang :  4 et 4 	 AiB : A :: Bp ::  de rang :  2 et 2 	 A : A :: Bp :: X :: N ::   de rang : 2 et 3 *)
assert(HOoABBpPm3 : rk(Oo :: A :: B :: Bp :: P :: nil) >= 3).
{
	assert(HABpXNMtmp : rk(A :: Bp :: X :: N :: nil) <= 3) by (solve_hyps_max HABpXNeq HABpXNM3).
	assert(HOoABBpXNPmtmp : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 4) by (solve_hyps_min HOoABBpXNPeq HOoABBpXNPm4).
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hincl : incl (A :: Bp :: nil) (list_inter (A :: Bp :: X :: N :: nil) (Oo :: A :: B :: Bp :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: X :: N :: P :: nil) (A :: Bp :: X :: N :: Oo :: A :: B :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: X :: N :: Oo :: A :: B :: Bp :: P :: nil) ((A :: Bp :: X :: N :: nil) ++ (Oo :: A :: B :: Bp :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpXNPmtmp;try rewrite HT2 in HOoABBpXNPmtmp.
	assert(HT := rule_4 (A :: Bp :: X :: N :: nil) (Oo :: A :: B :: Bp :: P :: nil) (A :: Bp :: nil) 4 2 3 HOoABBpXNPmtmp HABpmtmp HABpXNMtmp Hincl); apply HT.
}
try clear HABpXNM1. try clear HABpXNM2. try clear HABpXNM3. try clear HABpXNm4. try clear HABpXNm3. try clear HABpXNm2. try clear HABpXNm1. try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. try clear HOoABBpXNPM1. try clear HOoABBpXNPM2. try clear HOoABBpXNPM3. try clear HOoABBpXNPm4. try clear HOoABBpXNPm3. try clear HOoABBpXNPm2. try clear HOoABBpXNPm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpPm4 : rk(Oo :: A :: B :: Bp :: P :: nil) >= 4).
{
	try assert(HOoABpPeq : rk(Oo :: A :: Bp :: P :: nil) = 4) by (apply LOoABpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABpPmtmp : rk(Oo :: A :: Bp :: P :: nil) >= 4) by (solve_hyps_min HOoABpPeq HOoABpPm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: P :: nil) (Oo :: A :: B :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: P :: nil) (Oo :: A :: B :: Bp :: P :: nil) 4 4 HOoABpPmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpPM : rk(Oo :: A :: B :: Bp :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpPm : rk(Oo :: A :: B :: Bp :: P ::  nil) >= 1) by (solve_hyps_min HOoABBpPeq HOoABBpPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpP requis par la preuve de (?)OoApBpP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApBpP requis par la preuve de (?)OoApBpP pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpP requis par la preuve de (?)OoApBpP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpPm2 : rk(Oo :: Ap :: Bp :: P :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: P :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpPM3 : rk(Oo :: Ap :: Bp :: P :: nil) <= 3).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Bp :: nil) (P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: P :: nil) (Oo :: Ap :: Bp :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: P :: nil) ((Oo :: Ap :: Bp :: nil) ++ (P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Bp :: nil) (P :: nil) (nil) 2 1 0 HOoApBpMtmp HPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpPm3 : rk(Oo :: Ap :: Bp :: P :: nil) >= 3).
{
	try assert(HOoBpPeq : rk(Oo :: Bp :: P :: nil) = 3) by (apply LOoBpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBpPmtmp : rk(Oo :: Bp :: P :: nil) >= 3) by (solve_hyps_min HOoBpPeq HOoBpPm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: P :: nil) (Oo :: Ap :: Bp :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: P :: nil) (Oo :: Ap :: Bp :: P :: nil) 3 3 HOoBpPmtmp Hcomp Hincl);apply HT.
}
try clear HOoBpPM1. try clear HOoBpPM2. try clear HOoBpPM3. try clear HOoBpPm4. try clear HOoBpPm3. try clear HOoBpPm2. try clear HOoBpPm1. 

assert(HOoApBpPM : rk(Oo :: Ap :: Bp :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpPm : rk(Oo :: Ap :: Bp :: P ::  nil) >= 1) by (solve_hyps_min HOoApBpPeq HOoApBpPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApXP *)
(* dans constructLemma(), requis par LOoBApBpXP *)
(* dans la couche 0 *)
Lemma LOoABApBpXP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: X :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpXP requis par la preuve de (?)OoABApBpXP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpXP requis par la preuve de (?)OoABApBpXP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpXP requis par la preuve de (?)OoABApBpXP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpXPm2 : rk(Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpXPm3 : rk(Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpXPm4 : rk(Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) >= 4).
{
	try assert(HOoABpPeq : rk(Oo :: A :: Bp :: P :: nil) = 4) by (apply LOoABpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABpPmtmp : rk(Oo :: A :: Bp :: P :: nil) >= 4) by (solve_hyps_min HOoABpPeq HOoABpPm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: P :: nil) (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: P :: nil) (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) 4 4 HOoABpPmtmp Hcomp Hincl);apply HT.
}
try clear HOoABpPM1. try clear HOoABpPM2. try clear HOoABpPM3. try clear HOoABpPm4. try clear HOoABpPm3. try clear HOoABpPm2. try clear HOoABpPm1. 

assert(HOoABApBpXPM : rk(Oo :: A :: B :: Ap :: Bp :: X :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpXPm : rk(Oo :: A :: B :: Ap :: Bp :: X :: P ::  nil) >= 1) by (solve_hyps_min HOoABApBpXPeq HOoABApBpXPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpXP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: X :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpXP requis par la preuve de (?)OoBApBpXP pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApBpXNP requis par la preuve de (?)OoBApBpXP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpXNP requis par la preuve de (?)OoBApBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpXNP requis par la preuve de (?)OoBApBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpXNPm2 : rk(Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpXNPm4 : rk(Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpN requis par la preuve de (?)OoBApBpXP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpN requis par la preuve de (?)ApBpN pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpNm2 : rk(Ap :: Bp :: N :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: N :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpXP requis par la preuve de (?)OoBApBpXP pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpXP requis par la preuve de (?)OoBApBpXP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpXPm2 : rk(Oo :: B :: Ap :: Bp :: X :: P :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: X :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: X :: P :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: X :: N :: P ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: N ::   de rang : 2 et 3 *)
assert(HOoBApBpXPm3 : rk(Oo :: B :: Ap :: Bp :: X :: P :: nil) >= 3).
{
	assert(HApBpNMtmp : rk(Ap :: Bp :: N :: nil) <= 3) by (solve_hyps_max HApBpNeq HApBpNM3).
	assert(HOoBApBpXNPmtmp : rk(Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) >= 4) by (solve_hyps_min HOoBApBpXNPeq HOoBApBpXNPm4).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: X :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) (Ap :: Bp :: N :: Oo :: B :: Ap :: Bp :: X :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: N :: Oo :: B :: Ap :: Bp :: X :: P :: nil) ((Ap :: Bp :: N :: nil) ++ (Oo :: B :: Ap :: Bp :: X :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpXNPmtmp;try rewrite HT2 in HOoBApBpXNPmtmp.
	assert(HT := rule_4 (Ap :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: X :: P :: nil) (Ap :: Bp :: nil) 4 2 3 HOoBApBpXNPmtmp HApBpmtmp HApBpNMtmp Hincl); apply HT.
}
try clear HApBpNM1. try clear HApBpNM2. try clear HApBpNM3. try clear HApBpNm4. try clear HApBpNm3. try clear HApBpNm2. try clear HApBpNm1. try clear HOoBApBpXNPM1. try clear HOoBApBpXNPM2. try clear HOoBApBpXNPM3. try clear HOoBApBpXNPm4. try clear HOoBApBpXNPm3. try clear HOoBApBpXNPm2. try clear HOoBApBpXNPm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: X :: P ::  de rang :  4 et 4 	 AiB : Oo :: B :: Bp :: P ::  de rang :  4 et 4 	 A : Oo :: A :: B :: Bp :: P ::   de rang : 4 et 4 *)
assert(HOoBApBpXPm4 : rk(Oo :: B :: Ap :: Bp :: X :: P :: nil) >= 4).
{
	try assert(HOoABBpPeq : rk(Oo :: A :: B :: Bp :: P :: nil) = 4) by (apply LOoABBpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABBpPMtmp : rk(Oo :: A :: B :: Bp :: P :: nil) <= 4) by (solve_hyps_max HOoABBpPeq HOoABBpPM4).
	try assert(HOoABApBpXPeq : rk(Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) = 4) by (apply LOoABApBpXP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpXPmtmp : rk(Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) >= 4) by (solve_hyps_min HOoABApBpXPeq HOoABApBpXPm4).
	try assert(HOoBBpPeq : rk(Oo :: B :: Bp :: P :: nil) = 4) by (apply LOoBBpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpPmtmp : rk(Oo :: B :: Bp :: P :: nil) >= 4) by (solve_hyps_min HOoBBpPeq HOoBBpPm4).
	assert(Hincl : incl (Oo :: B :: Bp :: P :: nil) (list_inter (Oo :: A :: B :: Bp :: P :: nil) (Oo :: B :: Ap :: Bp :: X :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: X :: P :: nil) (Oo :: A :: B :: Bp :: P :: Oo :: B :: Ap :: Bp :: X :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Bp :: P :: Oo :: B :: Ap :: Bp :: X :: P :: nil) ((Oo :: A :: B :: Bp :: P :: nil) ++ (Oo :: B :: Ap :: Bp :: X :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpXPmtmp;try rewrite HT2 in HOoABApBpXPmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Bp :: P :: nil) (Oo :: B :: Ap :: Bp :: X :: P :: nil) (Oo :: B :: Bp :: P :: nil) 4 4 4 HOoABApBpXPmtmp HOoBBpPmtmp HOoABBpPMtmp Hincl); apply HT.
}


assert(HOoBApBpXPM : rk(Oo :: B :: Ap :: Bp :: X :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpXPm : rk(Oo :: B :: Ap :: Bp :: X :: P ::  nil) >= 1) by (solve_hyps_min HOoBApBpXPeq HOoBApBpXPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApXP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: Ap :: X :: P ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApXP requis par la preuve de (?)BApXP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApXP requis par la preuve de (?)BApXP pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApXP requis par la preuve de (?)BApXP pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApXP requis par la preuve de (?)OoABApXP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApXP requis par la preuve de (?)OoABApXP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXPm2 : rk(Oo :: A :: B :: Ap :: X :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXPm3 : rk(Oo :: A :: B :: Ap :: X :: P :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: P :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApXP requis par la preuve de (?)BApXP pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: P ::  de rang :  3 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: X ::   de rang : 3 et 3 *)
assert(HBApXPm2 : rk(B :: Ap :: X :: P :: nil) >= 2).
{
	try assert(HOoAApXeq : rk(Oo :: A :: Ap :: X :: nil) = 3) by (apply LOoAApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApXMtmp : rk(Oo :: A :: Ap :: X :: nil) <= 3) by (solve_hyps_max HOoAApXeq HOoAApXM3).
	assert(HOoABApXPmtmp : rk(Oo :: A :: B :: Ap :: X :: P :: nil) >= 3) by (solve_hyps_min HOoABApXPeq HOoABApXPm3).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (Oo :: A :: Ap :: X :: nil) (B :: Ap :: X :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: P :: nil) (Oo :: A :: Ap :: X :: B :: Ap :: X :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: X :: B :: Ap :: X :: P :: nil) ((Oo :: A :: Ap :: X :: nil) ++ (B :: Ap :: X :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXPmtmp;try rewrite HT2 in HOoABApXPmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: X :: nil) (B :: Ap :: X :: P :: nil) (Ap :: X :: nil) 3 2 3 HOoABApXPmtmp HApXmtmp HOoAApXMtmp Hincl); apply HT.
}
try clear HOoABApXPM1. try clear HOoABApXPM2. try clear HOoABApXPM3. try clear HOoABApXPm4. try clear HOoABApXPm3. try clear HOoABApXPm2. try clear HOoABApXPm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBApXPM3 : rk(B :: Ap :: X :: P :: nil) <= 3).
{
	try assert(HBApXeq : rk(B :: Ap :: X :: nil) = 2) by (apply LBApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBApXMtmp : rk(B :: Ap :: X :: nil) <= 2) by (solve_hyps_max HBApXeq HBApXM2).
	try assert(HPeq : rk(P :: nil) = 1) by (apply LP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HPMtmp : rk(P :: nil) <= 1) by (solve_hyps_max HPeq HPM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: X :: nil) (P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: X :: P :: nil) (B :: Ap :: X :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: P :: nil) ((B :: Ap :: X :: nil) ++ (P :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Ap :: X :: nil) (P :: nil) (nil) 2 1 0 HBApXMtmp HPMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: X :: P ::  de rang :  4 et 4 	 AiB : Ap :: P ::  de rang :  2 et 2 	 A : Oo :: Ap :: Bp :: P ::   de rang : 3 et 3 *)
assert(HBApXPm3 : rk(B :: Ap :: X :: P :: nil) >= 3).
{
	try assert(HOoApBpPeq : rk(Oo :: Ap :: Bp :: P :: nil) = 3) by (apply LOoApBpP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpPMtmp : rk(Oo :: Ap :: Bp :: P :: nil) <= 3) by (solve_hyps_max HOoApBpPeq HOoApBpPM3).
	try assert(HOoBApBpXPeq : rk(Oo :: B :: Ap :: Bp :: X :: P :: nil) = 4) by (apply LOoBApBpXP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBApBpXPmtmp : rk(Oo :: B :: Ap :: Bp :: X :: P :: nil) >= 4) by (solve_hyps_min HOoBApBpXPeq HOoBApBpXPm4).
	try assert(HApPeq : rk(Ap :: P :: nil) = 2) by (apply LApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApPmtmp : rk(Ap :: P :: nil) >= 2) by (solve_hyps_min HApPeq HApPm2).
	assert(Hincl : incl (Ap :: P :: nil) (list_inter (Oo :: Ap :: Bp :: P :: nil) (B :: Ap :: X :: P :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: X :: P :: nil) (Oo :: Ap :: Bp :: P :: B :: Ap :: X :: P :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: P :: B :: Ap :: X :: P :: nil) ((Oo :: Ap :: Bp :: P :: nil) ++ (B :: Ap :: X :: P :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpXPmtmp;try rewrite HT2 in HOoBApBpXPmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: P :: nil) (B :: Ap :: X :: P :: nil) (Ap :: P :: nil) 4 2 3 HOoBApBpXPmtmp HApPmtmp HOoApBpPMtmp Hincl); apply HT.
}
try clear HApPM1. try clear HApPM2. try clear HApPM3. try clear HApPm4. try clear HApPm3. try clear HApPm2. try clear HApPm1. 

assert(HBApXPM : rk(B :: Ap :: X :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApXPm : rk(B :: Ap :: X :: P ::  nil) >= 1) by (solve_hyps_min HBApXPeq HBApXPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApYMP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Y :: M :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBCApYMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBCApYMP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApYMP requis par la preuve de (?)OoBCApYMP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApYMPm2 : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApYMPm3 : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 3).
{
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) 3 3 HBCMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCApYMPm4 : rk(Oo :: B :: C :: Ap :: Y :: M :: P :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (Oo :: B :: C :: Ap :: Y :: M :: P :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCApYMPM : rk(Oo :: B :: C :: Ap :: Y :: M :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApYMPm : rk(Oo :: B :: C :: Ap :: Y :: M :: P ::  nil) >= 1) by (solve_hyps_min HOoBCApYMPeq HOoBCApYMPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpNP requis par la preuve de (?)OoBCBpNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpNP requis par la preuve de (?)OoBCBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNPm2 : rk(Oo :: B :: C :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpNPm4 : rk(Oo :: B :: C :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: C :: Bp :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCBpNPM : rk(Oo :: B :: C :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpNPm : rk(Oo :: B :: C :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoBCBpNPeq HOoBCBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpNP requis par la preuve de (?)OoBApBpNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpNP requis par la preuve de (?)OoBApBpNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNPm2 : rk(Oo :: B :: Ap :: Bp :: N :: P :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpNPm4 : rk(Oo :: B :: Ap :: Bp :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApBpNPM : rk(Oo :: B :: Ap :: Bp :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpNPm : rk(Oo :: B :: Ap :: Bp :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoBApBpNPeq HOoBApBpNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpXNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: X :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpXNP requis par la preuve de (?)OoABBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm2 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpXNPm4 : rk(Oo :: A :: B :: Bp :: X :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: A :: B :: Bp :: X :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpXNPM : rk(Oo :: A :: B :: Bp :: X :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpXNPm : rk(Oo :: A :: B :: Bp :: X :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoABBpXNPeq HOoABBpXNPm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpXNP : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: X :: N :: P ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpXNP requis par la preuve de (?)OoBApBpXNP pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpXNP requis par la preuve de (?)OoBApBpXNP pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpXNPm2 : rk(Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpXNPm4 : rk(Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) >= 4).
{
	try assert(HOoBBpNeq : rk(Oo :: B :: Bp :: N :: nil) = 4) by (apply LOoBBpN with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBBpNmtmp : rk(Oo :: B :: Bp :: N :: nil) >= 4) by (solve_hyps_min HOoBBpNeq HOoBBpNm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Bp :: N :: nil) (Oo :: B :: Ap :: Bp :: X :: N :: P :: nil) 4 4 HOoBBpNmtmp Hcomp Hincl);apply HT.
}
try clear HOoBBpNM1. try clear HOoBBpNM2. try clear HOoBBpNM3. try clear HOoBBpNm4. try clear HOoBBpNm3. try clear HOoBBpNm2. try clear HOoBBpNm1. 

assert(HOoBApBpXNPM : rk(Oo :: B :: Ap :: Bp :: X :: N :: P ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpXNPm : rk(Oo :: B :: Ap :: Bp :: X :: N :: P ::  nil) >= 1) by (solve_hyps_min HOoBApBpXNPeq HOoBApBpXNPm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBQ *)
(* dans constructLemma(), requis par LABApCpQ *)
(* dans constructLemma(), requis par LOoABApCpQ *)
(* dans constructLemma(), requis par LOoABApBpCpQ *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoABCApBpCpQM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpQm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApBpCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCpQ requis par la preuve de (?)OoABApBpCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpQm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HOoABApBpCpQm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoABCApBpCpQeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (nil) 4 0 1 HOoABCApBpCpQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HOoABApBpCpQm4 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HOoABCApBpCpQeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((A :: B :: C :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpQmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HOoABApBpCpQM : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpCpQm : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HOoABApBpCpQeq HOoABApBpCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpQ requis par la preuve de (?)OoABApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpQ requis par la preuve de (?)OoABApCpQ pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpQ requis par la preuve de (?)OoABApCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpQm2 : rk(Oo :: A :: B :: Ap :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpQm3 : rk(Oo :: A :: B :: Ap :: Cp :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoABApCpQm4 : rk(Oo :: A :: B :: Ap :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	try assert(HOoABApBpCpQeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpQmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABApBpCpQeq HOoABApBpCpQm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: B :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: B :: Ap :: Cp :: Q :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: B :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpQmtmp;try rewrite HT2 in HOoABApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Cp :: Q :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABApBpCpQmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}


assert(HOoABApCpQM : rk(Oo :: A :: B :: Ap :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpQm : rk(Oo :: A :: B :: Ap :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HOoABApCpQeq HOoABApCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpQ requis par la preuve de (?)ABApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpQ requis par la preuve de (?)ABCApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpQ requis par la preuve de (?)ABCApBpCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpQm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpQm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpQeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpQmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApBpCpQm2 : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABApBpCpQm3 : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABCApBpCpQmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HABCApBpCpQeq HABCApBpCpQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpQmtmp;try rewrite HT2 in HABCApBpCpQmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil) (nil) 4 0 1 HABCApBpCpQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABApBpCpQm4 : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	assert(HABCApBpCpQmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HABCApBpCpQeq HABCApBpCpQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpQmtmp;try rewrite HT2 in HABCApBpCpQmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: nil) 4 2 2 HABCApBpCpQmtmp HABmtmp HABCMtmp Hincl); apply HT.
}
try clear HABCApBpCpQM1. try clear HABCApBpCpQM2. try clear HABCApBpCpQM3. try clear HABCApBpCpQm4. try clear HABCApBpCpQm3. try clear HABCApBpCpQm2. try clear HABCApBpCpQm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpQ requis par la preuve de (?)ABApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpQ requis par la preuve de (?)ABApCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpQm2 : rk(A :: B :: Ap :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HABApCpQm3 : rk(A :: B :: Ap :: Cp :: Q :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HABApBpCpQmtmp : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HABApBpCpQeq HABApBpCpQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: B :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: Cp :: Q :: nil) (Bp :: A :: B :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: B :: Ap :: Cp :: Q :: nil) ((Bp :: nil) ++ (A :: B :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpCpQmtmp;try rewrite HT2 in HABApBpCpQmtmp.
	assert(HT := rule_4 (Bp :: nil) (A :: B :: Ap :: Cp :: Q :: nil) (nil) 4 0 1 HABApBpCpQmtmp Hmtmp HBpMtmp Hincl); apply HT.
}
try clear HABApBpCpQM1. try clear HABApBpCpQM2. try clear HABApBpCpQM3. try clear HABApBpCpQm4. try clear HABApBpCpQm3. try clear HABApBpCpQm2. try clear HABApBpCpQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Oo :: Ap :: Cp ::   de rang : 2 et 2 *)
assert(HABApCpQm4 : rk(A :: B :: Ap :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HOoABApCpQeq : rk(Oo :: A :: B :: Ap :: Cp :: Q :: nil) = 4) by (apply LOoABApCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApCpQmtmp : rk(Oo :: A :: B :: Ap :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABApCpQeq HOoABApCpQm4).
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Oo :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: Q :: nil) (Oo :: Ap :: Cp :: A :: B :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: A :: B :: Ap :: Cp :: Q :: nil) ((Oo :: Ap :: Cp :: nil) ++ (A :: B :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpQmtmp;try rewrite HT2 in HOoABApCpQmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: Q :: nil) (Ap :: Cp :: nil) 4 2 2 HOoABApCpQmtmp HApCpmtmp HOoApCpMtmp Hincl); apply HT.
}


assert(HABApCpQM : rk(A :: B :: Ap :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpQm : rk(A :: B :: Ap :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HABApCpQeq HABApCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: Q ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BQ requis par la preuve de (?)BQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: Q ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBQm2 : rk(B :: Q :: nil) >= 2).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 3) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpMtmp : rk(A :: B :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HABApCpeq HABApCpM3).
	try assert(HABApCpQeq : rk(A :: B :: Ap :: Cp :: Q :: nil) = 4) by (apply LABApCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABApCpQmtmp : rk(A :: B :: Ap :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HABApCpQeq HABApCpQm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (B :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: Q :: nil) (A :: B :: Ap :: Cp :: B :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: B :: Q :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (B :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpQmtmp;try rewrite HT2 in HABApCpQmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Cp :: nil) (B :: Q :: nil) (B :: nil) 4 1 3 HABApCpQmtmp HBmtmp HABApCpMtmp Hincl); apply HT.
}


assert(HBQM : rk(B :: Q ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBQeq HBQM2).
assert(HBQm : rk(B :: Q ::  nil) >= 1) by (solve_hyps_min HBQeq HBQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApCpQ *)
(* dans la couche 0 *)
Lemma LOoAApBpCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpQ requis par la preuve de (?)OoACApBpCpQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B ::   de rang : 2 et 2 *)
assert(HOoACApBpCpQm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABMtmp : rk(A :: B :: nil) <= 2) by (solve_hyps_max HABeq HABM2).
	try assert(HOoABCApBpCpQeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) ((A :: B :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (A :: B :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: nil) 4 1 2 HOoABCApBpCpQmtmp HAmtmp HABMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpCpQ requis par la preuve de (?)OoAApBpCpQ pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  3 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpQm2 : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMtmp : rk(A :: C :: nil) <= 2) by (solve_hyps_max HACeq HACM2).
	assert(HOoACApBpCpQmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 3) by (solve_hyps_min HOoACApBpCpQeq HOoACApBpCpQm3).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) ((A :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpQmtmp;try rewrite HT2 in HOoACApBpCpQmtmp.
	assert(HT := rule_4 (A :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (A :: nil) 3 1 2 HOoACApBpCpQmtmp HAmtmp HACMtmp Hincl); apply HT.
}
try clear HOoACApBpCpQM1. try clear HOoACApBpCpQM2. try clear HOoACApBpCpQM3. try clear HOoACApBpCpQm4. try clear HOoACApBpCpQm3. try clear HOoACApBpCpQm2. try clear HOoACApBpCpQm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C ::   de rang : 2 et 2 *)
assert(HOoAApBpCpQm3 : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HOoBCeq : rk(Oo :: B :: C :: nil) = 2) by (apply LOoBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBCMtmp : rk(Oo :: B :: C :: nil) <= 2) by (solve_hyps_max HOoBCeq HOoBCM2).
	try assert(HOoABCApBpCpQeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) ((Oo :: B :: C :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpQmtmp HOomtmp HOoBCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoAApBpCpQm4 : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApBpCpQeq : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApBpCpQmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABApBpCpQeq HOoABApBpCpQm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpQmtmp;try rewrite HT2 in HOoABApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoABApBpCpQmtmp HOoAApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HOoAApBpCpQM : rk(Oo :: A :: Ap :: Bp :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpCpQm : rk(Oo :: A :: Ap :: Bp :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HOoAApBpCpQeq HOoAApBpCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpQ requis par la preuve de (?)OoAApCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpQ requis par la preuve de (?)OoAApCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpQm3 : rk(Oo :: A :: Ap :: Cp :: Q :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : Oo :: A :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoAApCpQm4 : rk(Oo :: A :: Ap :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoAApBpeq : rk(Oo :: A :: Ap :: Bp :: nil) = 3) by (apply LOoAApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpMtmp : rk(Oo :: A :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoAApBpeq HOoAApBpM3).
	try assert(HOoAApBpCpQeq : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoAApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApBpCpQmtmp : rk(Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoAApBpCpQeq HOoAApBpCpQm4).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: Oo :: A :: Ap :: Cp :: Q :: nil) ((Oo :: A :: Ap :: Bp :: nil) ++ (Oo :: A :: Ap :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpCpQmtmp;try rewrite HT2 in HOoAApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Cp :: Q :: nil) (Oo :: A :: Ap :: nil) 4 3 3 HOoAApBpCpQmtmp HOoAApmtmp HOoAApBpMtmp Hincl); apply HT.
}


assert(HOoAApCpQM : rk(Oo :: A :: Ap :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpQm : rk(Oo :: A :: Ap :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HOoAApCpQeq HOoAApCpQm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApBpCpQ *)
(* dans la couche 0 *)
Lemma LABCApBpCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpQ requis par la preuve de (?)ABCApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpQ requis par la preuve de (?)ABCApBpCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpQm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B ::   de rang : 2 et 2 *)
assert(HABCApBpCpQm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HOoABeq : rk(Oo :: A :: B :: nil) = 2) by (apply LOoAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABMtmp : rk(Oo :: A :: B :: nil) <= 2) by (solve_hyps_max HOoABeq HOoABM2).
	try assert(HOoABCApBpCpQeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LOoABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApBpCpQmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpQeq HOoABCApBpCpQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpQmtmp;try rewrite HT2 in HOoABCApBpCpQmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: nil) 4 2 2 HOoABCApBpCpQmtmp HABmtmp HOoABMtmp Hincl); apply HT.
}


assert(HABCApBpCpQM : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpQm : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HABCApBpCpQeq HABCApBpCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApBpCpQ : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: B :: Ap :: Bp :: Cp :: Q ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpCpQ requis par la preuve de (?)ABApBpCpQ pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApBpCpQm2 : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C ::   de rang : 1 et 1 *)
assert(HABApBpCpQm3 : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HABCApBpCpQeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApBpCpQmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HABCApBpCpQeq HABCApBpCpQm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpQmtmp;try rewrite HT2 in HABCApBpCpQmtmp.
	assert(HT := rule_4 (C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil) (nil) 4 0 1 HABCApBpCpQmtmp Hmtmp HCMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Q ::  de rang :  4 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : A :: B :: C ::   de rang : 2 et 2 *)
assert(HABApBpCpQm4 : rk(A :: B :: Ap :: Bp :: Cp :: Q :: nil) >= 4).
{
	try assert(HABCeq : rk(A :: B :: C :: nil) = 2) by (apply LABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCMtmp : rk(A :: B :: C :: nil) <= 2) by (solve_hyps_max HABCeq HABCM2).
	try assert(HABCApBpCpQeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) = 4) by (apply LABCApBpCpQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABCApBpCpQmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) >= 4) by (solve_hyps_min HABCApBpCpQeq HABCApBpCpQm4).
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: B :: Ap :: Bp :: Cp :: Q :: nil) ((A :: B :: C :: nil) ++ (A :: B :: Ap :: Bp :: Cp :: Q :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpQmtmp;try rewrite HT2 in HABCApBpCpQmtmp.
	assert(HT := rule_4 (A :: B :: C :: nil) (A :: B :: Ap :: Bp :: Cp :: Q :: nil) (A :: B :: nil) 4 2 2 HABCApBpCpQmtmp HABmtmp HABCMtmp Hincl); apply HT.
}


assert(HABApBpCpQM : rk(A :: B :: Ap :: Bp :: Cp :: Q ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApBpCpQm : rk(A :: B :: Ap :: Bp :: Cp :: Q ::  nil) >= 1) by (solve_hyps_min HABApBpCpQeq HABApBpCpQm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Sp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HSpM : rk(Sp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HSpeq HSpM1).
assert(HSpm : rk(Sp ::  nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoSp *)
(* dans la couche 0 *)
Lemma LOoCApSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: C :: Ap :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HOoCApSpM : rk(Oo :: C :: Ap :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApSpm : rk(Oo :: C :: Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApSpeq HOoCApSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoSp *)
(* dans la couche 0 *)
Lemma LOoSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApSp requis par la preuve de (?)OoSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm2 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm3 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 3).
{
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 3 3 HBCMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm4 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: X :: M :: Sp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap :: X :: M ::   de rang : 3 et 3 *)
assert(HCApSpm2 : rk(C :: Ap :: Sp :: nil) >= 2).
{
	try assert(HBApXMeq : rk(B :: Ap :: X :: M :: nil) = 3) by (apply LBApXM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBApXMMtmp : rk(B :: Ap :: X :: M :: nil) <= 3) by (solve_hyps_max HBApXMeq HBApXMM3).
	assert(HBCApXMSpmtmp : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 4) by (solve_hyps_min HBCApXMSpeq HBCApXMSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: X :: M :: nil) (C :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: X :: M :: Sp :: nil) (B :: Ap :: X :: M :: C :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: M :: C :: Ap :: Sp :: nil) ((B :: Ap :: X :: M :: nil) ++ (C :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApXMSpmtmp;try rewrite HT2 in HBCApXMSpmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: M :: nil) (C :: Ap :: Sp :: nil) (Ap :: nil) 4 1 3 HBCApXMSpmtmp HApmtmp HBApXMMtmp Hincl); apply HT.
}
try clear HBCApXMSpM1. try clear HBCApXMSpM2. try clear HBCApXMSpM3. try clear HBCApXMSpm4. try clear HBCApXMSpm3. try clear HBCApXMSpm2. try clear HBCApXMSpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoSp requis par la preuve de (?)OoSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoSpm2 : rk(Oo :: Sp :: nil) >= 2).
{
	assert(HCApSpMtmp : rk(C :: Ap :: Sp :: nil) <= 3) by (solve_hyps_max HCApSpeq HCApSpM3).
	try assert(HOoCApSpeq : rk(Oo :: C :: Ap :: Sp :: nil) = 4) by (apply LOoCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCApSpmtmp : rk(Oo :: C :: Ap :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApSpeq HOoCApSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Oo :: Sp :: nil) (C :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Sp :: nil) (Oo :: Sp :: C :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Sp :: C :: Ap :: Sp :: nil) ((Oo :: Sp :: nil) ++ (C :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApSpmtmp;try rewrite HT2 in HOoCApSpmtmp.
	assert(HT := rule_2 (Oo :: Sp :: nil) (C :: Ap :: Sp :: nil) (Sp :: nil) 4 1 3 HOoCApSpmtmp HSpmtmp HCApSpMtmp Hincl);apply HT.
}


assert(HOoSpM : rk(Oo :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoSpeq HOoSpM2).
assert(HOoSpm : rk(Oo :: Sp ::  nil) >= 1) by (solve_hyps_min HOoSpeq HOoSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCSp *)
(* dans la couche 0 *)
Lemma LBCQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: Q :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HBCQSpM : rk(B :: C :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCQSpm : rk(B :: C :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HBCQSpeq HBCQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CSp requis par la preuve de (?)CSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Q :: Sp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Q ::   de rang : 2 et 2 *)
assert(HCSpm2 : rk(C :: Sp :: nil) >= 2).
{
	try assert(HBQeq : rk(B :: Q :: nil) = 2) by (apply LBQ with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBQMtmp : rk(B :: Q :: nil) <= 2) by (solve_hyps_max HBQeq HBQM2).
	try assert(HBCQSpeq : rk(B :: C :: Q :: Sp :: nil) = 4) by (apply LBCQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCQSpmtmp : rk(B :: C :: Q :: Sp :: nil) >= 4) by (solve_hyps_min HBCQSpeq HBCQSpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Q :: nil) (C :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Q :: Sp :: nil) (B :: Q :: C :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Q :: C :: Sp :: nil) ((B :: Q :: nil) ++ (C :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCQSpmtmp;try rewrite HT2 in HBCQSpmtmp.
	assert(HT := rule_4 (B :: Q :: nil) (C :: Sp :: nil) (nil) 4 0 2 HBCQSpmtmp Hmtmp HBQMtmp Hincl); apply HT.
}
try clear HBQM1. try clear HBQM2. try clear HBQM3. try clear HBQm4. try clear HBQm3. try clear HBQm2. try clear HBQm1. try clear HBCQSpM1. try clear HBCQSpM2. try clear HBCQSpM3. try clear HBCQSpm4. try clear HBCQSpm3. try clear HBCQSpm2. try clear HBCQSpm1. 

assert(HCSpM : rk(C :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCSpeq HCSpM2).
assert(HCSpm : rk(C :: Sp ::  nil) >= 1) by (solve_hyps_min HCSpeq HCSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCSp *)
(* dans constructLemma(), requis par LApSp *)
(* dans la couche 0 *)
Lemma LCApSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: Ap :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm2 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm3 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 3).
{
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 3 3 HBCMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm4 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApSp requis par la preuve de (?)CApSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: X :: M :: Sp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap :: X :: M ::   de rang : 3 et 3 *)
assert(HCApSpm2 : rk(C :: Ap :: Sp :: nil) >= 2).
{
	try assert(HBApXMeq : rk(B :: Ap :: X :: M :: nil) = 3) by (apply LBApXM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBApXMMtmp : rk(B :: Ap :: X :: M :: nil) <= 3) by (solve_hyps_max HBApXMeq HBApXMM3).
	assert(HBCApXMSpmtmp : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 4) by (solve_hyps_min HBCApXMSpeq HBCApXMSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: X :: M :: nil) (C :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: X :: M :: Sp :: nil) (B :: Ap :: X :: M :: C :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: M :: C :: Ap :: Sp :: nil) ((B :: Ap :: X :: M :: nil) ++ (C :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApXMSpmtmp;try rewrite HT2 in HBCApXMSpmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: M :: nil) (C :: Ap :: Sp :: nil) (Ap :: nil) 4 1 3 HBCApXMSpmtmp HApmtmp HBApXMMtmp Hincl); apply HT.
}
try clear HBCApXMSpM1. try clear HBCApXMSpM2. try clear HBCApXMSpM3. try clear HBCApXMSpm4. try clear HBCApXMSpm3. try clear HBCApXMSpm2. try clear HBCApXMSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Sp ::  de rang :  4 et 4 	 AiB : Sp ::  de rang :  1 et 1 	 A : Oo :: Sp ::   de rang : 2 et 2 *)
assert(HCApSpm3 : rk(C :: Ap :: Sp :: nil) >= 3).
{
	try assert(HOoSpeq : rk(Oo :: Sp :: nil) = 2) by (apply LOoSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoSpMtmp : rk(Oo :: Sp :: nil) <= 2) by (solve_hyps_max HOoSpeq HOoSpM2).
	try assert(HOoCApSpeq : rk(Oo :: C :: Ap :: Sp :: nil) = 4) by (apply LOoCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCApSpmtmp : rk(Oo :: C :: Ap :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApSpeq HOoCApSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Oo :: Sp :: nil) (C :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Sp :: nil) (Oo :: Sp :: C :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Sp :: C :: Ap :: Sp :: nil) ((Oo :: Sp :: nil) ++ (C :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApSpmtmp;try rewrite HT2 in HOoCApSpmtmp.
	assert(HT := rule_4 (Oo :: Sp :: nil) (C :: Ap :: Sp :: nil) (Sp :: nil) 4 1 2 HOoCApSpmtmp HSpmtmp HOoSpMtmp Hincl); apply HT.
}
try clear HOoSpM1. try clear HOoSpM2. try clear HOoSpM3. try clear HOoSpm4. try clear HOoSpm3. try clear HOoSpm2. try clear HOoSpm1. 

assert(HCApSpM : rk(C :: Ap :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCApSpeq HCApSpM3).
assert(HCApSpm : rk(C :: Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HCApSpeq HCApSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApSp requis par la preuve de (?)ApSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: Sp ::  de rang :  3 et 3 	 AiB : Sp ::  de rang :  1 et 1 	 A : C :: Sp ::   de rang : 2 et 2 *)
assert(HApSpm2 : rk(Ap :: Sp :: nil) >= 2).
{
	try assert(HCSpeq : rk(C :: Sp :: nil) = 2) by (apply LCSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCSpMtmp : rk(C :: Sp :: nil) <= 2) by (solve_hyps_max HCSpeq HCSpM2).
	try assert(HCApSpeq : rk(C :: Ap :: Sp :: nil) = 3) by (apply LCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCApSpmtmp : rk(C :: Ap :: Sp :: nil) >= 3) by (solve_hyps_min HCApSpeq HCApSpm3).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (C :: Sp :: nil) (Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Sp :: nil) (C :: Sp :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: Ap :: Sp :: nil) ((C :: Sp :: nil) ++ (Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApSpmtmp;try rewrite HT2 in HCApSpmtmp.
	assert(HT := rule_4 (C :: Sp :: nil) (Ap :: Sp :: nil) (Sp :: nil) 3 1 2 HCApSpmtmp HSpmtmp HCSpMtmp Hincl); apply HT.
}


assert(HApSpM : rk(Ap :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApSpeq HApSpM2).
assert(HApSpm : rk(Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HApSpeq HApSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: C :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCSp requis par la preuve de (?)OoCSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCSp requis par la preuve de (?)OoCSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCSpm2 : rk(Oo :: C :: Sp :: nil) >= 2).
{
	try assert(HCSpeq : rk(C :: Sp :: nil) = 2) by (apply LCSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCSpmtmp : rk(C :: Sp :: nil) >= 2) by (solve_hyps_min HCSpeq HCSpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (C :: Sp :: nil) (Oo :: C :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Sp :: nil) (Oo :: C :: Sp :: nil) 2 2 HCSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCSpm3 : rk(Oo :: C :: Sp :: nil) >= 3).
{
	try assert(HApSpeq : rk(Ap :: Sp :: nil) = 2) by (apply LApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApSpMtmp : rk(Ap :: Sp :: nil) <= 2) by (solve_hyps_max HApSpeq HApSpM2).
	try assert(HOoCApSpeq : rk(Oo :: C :: Ap :: Sp :: nil) = 4) by (apply LOoCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCApSpmtmp : rk(Oo :: C :: Ap :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApSpeq HOoCApSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Oo :: C :: Sp :: nil) (Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Sp :: nil) (Oo :: C :: Sp :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Sp :: Ap :: Sp :: nil) ((Oo :: C :: Sp :: nil) ++ (Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApSpmtmp;try rewrite HT2 in HOoCApSpmtmp.
	assert(HT := rule_2 (Oo :: C :: Sp :: nil) (Ap :: Sp :: nil) (Sp :: nil) 4 1 2 HOoCApSpmtmp HSpmtmp HApSpMtmp Hincl);apply HT.
}
try clear HApSpM1. try clear HApSpM2. try clear HApSpM3. try clear HApSpm4. try clear HApSpm3. try clear HApSpm2. try clear HApSpm1. 

assert(HOoCSpM : rk(Oo :: C :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCSpeq HOoCSpM3).
assert(HOoCSpm : rk(Oo :: C :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCSpeq HOoCSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApSp requis par la preuve de (?)OoApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoApSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoABCApXPSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoABCApXPSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoABCApXPSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXPSpm2 : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXPSpm3 : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXPSpm4 : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 4).
{
	try assert(HOoABApPeq : rk(Oo :: A :: B :: Ap :: P :: nil) = 4) by (apply LOoABApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApPmtmp : rk(Oo :: A :: B :: Ap :: P :: nil) >= 4) by (solve_hyps_min HOoABApPeq HOoABApPm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) 4 4 HOoABApPmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApXPSp requis par la preuve de (?)OoABApXPSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApXPSp requis par la preuve de (?)OoABApXPSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXPSpm2 : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXPSpm3 : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApX requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)AApX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXm3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApX requis par la preuve de (?)AApX pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApXm2 : rk(A :: Ap :: X :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpXmtmp : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Ap :: Bp :: A :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: X :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXmtmp;try rewrite HT2 in HOoAApBpXmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: X :: nil) (Ap :: nil) 3 1 2 HOoAApBpXmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: P :: Sp ::  de rang :  3 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : A :: Ap :: X ::   de rang : 2 et 3 *)
assert(HOoBApXPSpm2 : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 2).
{
	assert(HAApXMtmp : rk(A :: Ap :: X :: nil) <= 3) by (solve_hyps_max HAApXeq HAApXM3).
	assert(HOoABApXPSpmtmp : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApXPSpeq HOoABApXPSpm3).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (A :: Ap :: X :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) (A :: Ap :: X :: Oo :: B :: Ap :: X :: P :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: X :: Oo :: B :: Ap :: X :: P :: Sp :: nil) ((A :: Ap :: X :: nil) ++ (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXPSpmtmp;try rewrite HT2 in HOoABApXPSpmtmp.
	assert(HT := rule_4 (A :: Ap :: X :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil) (Ap :: X :: nil) 3 2 3 HOoABApXPSpmtmp HApXmtmp HAApXMtmp Hincl); apply HT.
}
try clear HAApXM1. try clear HAApXM2. try clear HAApXM3. try clear HAApXm4. try clear HAApXm3. try clear HAApXm2. try clear HAApXm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: P :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: B :: P ::  de rang :  3 et 3 	 A : Oo :: A :: B :: P ::   de rang : 3 et 3 *)
assert(HOoBApXPSpm3 : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 3).
{
	try assert(HOoABPeq : rk(Oo :: A :: B :: P :: nil) = 3) by (apply LOoABP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABPMtmp : rk(Oo :: A :: B :: P :: nil) <= 3) by (solve_hyps_max HOoABPeq HOoABPM3).
	assert(HOoABApXPSpmtmp : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApXPSpeq HOoABApXPSpm3).
	try assert(HOoBPeq : rk(Oo :: B :: P :: nil) = 3) by (apply LOoBP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBPmtmp : rk(Oo :: B :: P :: nil) >= 3) by (solve_hyps_min HOoBPeq HOoBPm3).
	assert(Hincl : incl (Oo :: B :: P :: nil) (list_inter (Oo :: A :: B :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) (Oo :: A :: B :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil) ((Oo :: A :: B :: P :: nil) ++ (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXPSpmtmp;try rewrite HT2 in HOoABApXPSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil) (Oo :: B :: P :: nil) 3 3 3 HOoABApXPSpmtmp HOoBPmtmp HOoABPMtmp Hincl); apply HT.
}
try clear HOoABApXPSpM1. try clear HOoABApXPSpM2. try clear HOoABApXPSpM3. try clear HOoABApXPSpm4. try clear HOoABApXPSpm3. try clear HOoABApXPSpm2. try clear HOoABApXPSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: P :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Ap :: P ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: Ap :: P ::   de rang : 4 et 4 *)
assert(HOoBApXPSpm4 : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 4).
{
	try assert(HOoABCApPeq : rk(Oo :: A :: B :: C :: Ap :: P :: nil) = 4) by (apply LOoABCApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApPMtmp : rk(Oo :: A :: B :: C :: Ap :: P :: nil) <= 4) by (solve_hyps_max HOoABCApPeq HOoABCApPM4).
	assert(HOoABCApXPSpmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApXPSpeq HOoABCApXPSpm4).
	try assert(HOoBApPeq : rk(Oo :: B :: Ap :: P :: nil) = 4) by (apply LOoBApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBApPmtmp : rk(Oo :: B :: Ap :: P :: nil) >= 4) by (solve_hyps_min HOoBApPeq HOoBApPm4).
	assert(Hincl : incl (Oo :: B :: Ap :: P :: nil) (list_inter (Oo :: A :: B :: C :: Ap :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil) ((Oo :: A :: B :: C :: Ap :: P :: nil) ++ (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXPSpmtmp;try rewrite HT2 in HOoABCApXPSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Ap :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil) (Oo :: B :: Ap :: P :: nil) 4 4 4 HOoABCApXPSpmtmp HOoBApPmtmp HOoABCApPMtmp Hincl); apply HT.
}
try clear HOoABCApXPSpM1. try clear HOoABCApXPSpM2. try clear HOoABCApXPSpM3. try clear HOoABCApXPSpm4. try clear HOoABCApXPSpm3. try clear HOoABCApXPSpm2. try clear HOoABCApXPSpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApSp requis par la preuve de (?)OoApSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: X :: P :: Sp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap :: X :: P ::   de rang : 3 et 3 *)
assert(HOoApSpm2 : rk(Oo :: Ap :: Sp :: nil) >= 2).
{
	try assert(HBApXPeq : rk(B :: Ap :: X :: P :: nil) = 3) by (apply LBApXP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBApXPMtmp : rk(B :: Ap :: X :: P :: nil) <= 3) by (solve_hyps_max HBApXPeq HBApXPM3).
	assert(HOoBApXPSpmtmp : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 4) by (solve_hyps_min HOoBApXPSpeq HOoBApXPSpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: X :: P :: nil) (Oo :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: X :: P :: Sp :: nil) (B :: Ap :: X :: P :: Oo :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: X :: P :: Oo :: Ap :: Sp :: nil) ((B :: Ap :: X :: P :: nil) ++ (Oo :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApXPSpmtmp;try rewrite HT2 in HOoBApXPSpmtmp.
	assert(HT := rule_4 (B :: Ap :: X :: P :: nil) (Oo :: Ap :: Sp :: nil) (Ap :: nil) 4 1 3 HOoBApXPSpmtmp HApmtmp HBApXPMtmp Hincl); apply HT.
}
try clear HOoBApXPSpM1. try clear HOoBApXPSpM2. try clear HOoBApXPSpM3. try clear HOoBApXPSpm4. try clear HOoBApXPSpm3. try clear HOoBApXPSpm2. try clear HOoBApXPSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Sp ::  de rang :  4 et 4 	 AiB : Sp ::  de rang :  1 et 1 	 A : C :: Sp ::   de rang : 2 et 2 *)
assert(HOoApSpm3 : rk(Oo :: Ap :: Sp :: nil) >= 3).
{
	try assert(HCSpeq : rk(C :: Sp :: nil) = 2) by (apply LCSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCSpMtmp : rk(C :: Sp :: nil) <= 2) by (solve_hyps_max HCSpeq HCSpM2).
	try assert(HOoCApSpeq : rk(Oo :: C :: Ap :: Sp :: nil) = 4) by (apply LOoCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCApSpmtmp : rk(Oo :: C :: Ap :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApSpeq HOoCApSpm4).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (C :: Sp :: nil) (Oo :: Ap :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Sp :: nil) (C :: Sp :: Oo :: Ap :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Sp :: Oo :: Ap :: Sp :: nil) ((C :: Sp :: nil) ++ (Oo :: Ap :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApSpmtmp;try rewrite HT2 in HOoCApSpmtmp.
	assert(HT := rule_4 (C :: Sp :: nil) (Oo :: Ap :: Sp :: nil) (Sp :: nil) 4 1 2 HOoCApSpmtmp HSpmtmp HCSpMtmp Hincl); apply HT.
}


assert(HOoApSpM : rk(Oo :: Ap :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApSpeq HOoApSpM3).
assert(HOoApSpm : rk(Oo :: Ap :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApSpeq HOoApSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpSp *)
(* dans la couche 0 *)
Lemma LApCpMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: Cp :: M :: Q :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpMQSp requis par la preuve de (?)ApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpMQSp requis par la preuve de (?)ApCpMQSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApMQSp requis par la preuve de (?)ApCpMQSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpMQSp requis par la preuve de (?)ApCpMQSp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HApCpMQSpM3 : rk(Ap :: Cp :: M :: Q :: Sp :: nil) <= 3).
{
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: M :: Q :: Sp :: nil) (Cp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Ap :: M :: Q :: Sp :: nil) ((Cp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (Ap :: M :: Q :: Sp :: nil) (nil) 1 2 0 HCpMtmp HApMQSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpMQSpm2 : rk(Ap :: Cp :: M :: Q :: Sp :: nil) >= 2).
{
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: M :: Q :: Sp :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpMQSpm3 : rk(Ap :: Cp :: M :: Q :: Sp :: nil) >= 3).
{
	try assert(HApCpMeq : rk(Ap :: Cp :: M :: nil) = 3) by (apply LApCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpMmtmp : rk(Ap :: Cp :: M :: nil) >= 3) by (solve_hyps_min HApCpMeq HApCpMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: M :: nil) (Ap :: Cp :: M :: Q :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: M :: nil) (Ap :: Cp :: M :: Q :: Sp :: nil) 3 3 HApCpMmtmp Hcomp Hincl);apply HT.
}


assert(HApCpMQSpM : rk(Ap :: Cp :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpMQSpm : rk(Ap :: Cp :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HApCpMQSpeq HApCpMQSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpSp *)
(* dans la couche 0 *)
Lemma LApMQSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

assert(HApMQSpM : rk(Ap :: M :: Q :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApMQSpm : rk(Ap :: M :: Q :: Sp ::  nil) >= 1) by (solve_hyps_min HApMQSpeq HApMQSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Cp :: Sp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpSp requis par la preuve de (?)CpSp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCpSpm2 : rk(Cp :: Sp :: nil) >= 2).
{
	try assert(HApMQSpeq : rk(Ap :: M :: Q :: Sp :: nil) = 2) by (apply LApMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApMQSpMtmp : rk(Ap :: M :: Q :: Sp :: nil) <= 2) by (solve_hyps_max HApMQSpeq HApMQSpM2).
	try assert(HApCpMQSpeq : rk(Ap :: Cp :: M :: Q :: Sp :: nil) = 3) by (apply LApCpMQSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApCpMQSpmtmp : rk(Ap :: Cp :: M :: Q :: Sp :: nil) >= 3) by (solve_hyps_min HApCpMQSpeq HApCpMQSpm3).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpmtmp : rk(Sp :: nil) >= 1) by (solve_hyps_min HSpeq HSpm1).
	assert(Hincl : incl (Sp :: nil) (list_inter (Cp :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: M :: Q :: Sp :: nil) (Cp :: Sp :: Ap :: M :: Q :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Sp :: Ap :: M :: Q :: Sp :: nil) ((Cp :: Sp :: nil) ++ (Ap :: M :: Q :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApCpMQSpmtmp;try rewrite HT2 in HApCpMQSpmtmp.
	assert(HT := rule_2 (Cp :: Sp :: nil) (Ap :: M :: Q :: Sp :: nil) (Sp :: nil) 3 1 2 HApCpMQSpmtmp HSpmtmp HApMQSpMtmp Hincl);apply HT.
}


assert(HCpSpM : rk(Cp :: Sp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpSpeq HCpSpM2).
assert(HCpSpm : rk(Cp :: Sp ::  nil) >= 1) by (solve_hyps_min HCpSpeq HCpSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCCpSp *)
(* dans la couche 0 *)
Lemma LOoCApCpSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: C :: Ap :: Cp :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpSp requis par la preuve de (?)OoCApCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpSp requis par la preuve de (?)OoCApCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApCpSp requis par la preuve de (?)OoCApCpSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApCpSp requis par la preuve de (?)OoABCApCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpSp requis par la preuve de (?)OoABCApCpSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpSpm2 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpSpm3 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpSp requis par la preuve de (?)OoCApCpSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApCpSpm2 : rk(Oo :: C :: Ap :: Cp :: Sp :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABCApCpSpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HOoABCApCpSpeq HOoABCApCpSpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: Sp :: nil) (Oo :: A :: B :: Cp :: Oo :: C :: Ap :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: C :: Ap :: Cp :: Sp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: C :: Ap :: Cp :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpSpmtmp;try rewrite HT2 in HOoABCApCpSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: nil) (Oo :: Cp :: nil) 3 2 3 HOoABCApCpSpmtmp HOoCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABCApCpSpM1. try clear HOoABCApCpSpM2. try clear HOoABCApCpSpM3. try clear HOoABCApCpSpm4. try clear HOoABCApCpSpm3. try clear HOoABCApCpSpm2. try clear HOoABCApCpSpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpSpm3 : rk(Oo :: C :: Ap :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoCSpeq : rk(Oo :: C :: Sp :: nil) = 3) by (apply LOoCSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCSpmtmp : rk(Oo :: C :: Sp :: nil) >= 3) by (solve_hyps_min HOoCSpeq HOoCSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Sp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Sp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: nil) 3 3 HOoCSpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCApCpSpm4 : rk(Oo :: C :: Ap :: Cp :: Sp :: nil) >= 4).
{
	try assert(HOoCApSpeq : rk(Oo :: C :: Ap :: Sp :: nil) = 4) by (apply LOoCApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCApSpmtmp : rk(Oo :: C :: Ap :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApSpeq HOoCApSpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Ap :: Sp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: Ap :: Sp :: nil) (Oo :: C :: Ap :: Cp :: Sp :: nil) 4 4 HOoCApSpmtmp Hcomp Hincl);apply HT.
}
try clear HOoCApSpM1. try clear HOoCApSpM2. try clear HOoCApSpM3. try clear HOoCApSpm4. try clear HOoCApSpm3. try clear HOoCApSpm2. try clear HOoCApSpm1. 

assert(HOoCApCpSpM : rk(Oo :: C :: Ap :: Cp :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpSpm : rk(Oo :: C :: Ap :: Cp :: Sp ::  nil) >= 1) by (solve_hyps_min HOoCApCpSpeq HOoCApCpSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCCpSp *)
(* dans la couche 0 *)
Lemma LOoApCpSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpSp requis par la preuve de (?)OoApCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpSp requis par la preuve de (?)OoApCpSp pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpSp requis par la preuve de (?)OoApCpSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpSp requis par la preuve de (?)OoABApCpSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpSp requis par la preuve de (?)OoABApCpSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpSpm2 : rk(Oo :: A :: B :: Ap :: Cp :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: Cp :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpSpm3 : rk(Oo :: A :: B :: Ap :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpSp requis par la preuve de (?)OoApCpSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HOoApCpSpm2 : rk(Oo :: Ap :: Cp :: Sp :: nil) >= 2).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 3) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCpMtmp : rk(Oo :: A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HOoABCpeq HOoABCpM3).
	assert(HOoABApCpSpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApCpSpeq HOoABApCpSpm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Cp :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: Sp :: nil) (Oo :: A :: B :: Cp :: Oo :: Ap :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: Ap :: Cp :: Sp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: Ap :: Cp :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpSpmtmp;try rewrite HT2 in HOoABApCpSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Cp :: nil) (Oo :: Ap :: Cp :: Sp :: nil) (Oo :: Cp :: nil) 3 2 3 HOoABApCpSpmtmp HOoCpmtmp HOoABCpMtmp Hincl); apply HT.
}
try clear HOoABApCpSpM1. try clear HOoABApCpSpM2. try clear HOoABApCpSpM3. try clear HOoABApCpSpm4. try clear HOoABApCpSpm3. try clear HOoABApCpSpm2. try clear HOoABApCpSpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApCpSpM3 : rk(Oo :: Ap :: Cp :: Sp :: nil) <= 3).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 2) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 2) by (solve_hyps_max HOoApCpeq HOoApCpM2).
	try assert(HSpeq : rk(Sp :: nil) = 1) by (apply LSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HSpMtmp : rk(Sp :: nil) <= 1) by (solve_hyps_max HSpeq HSpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: Cp :: nil) (Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: Sp :: nil) (Oo :: Ap :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: Sp :: nil) ((Oo :: Ap :: Cp :: nil) ++ (Sp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: Ap :: Cp :: nil) (Sp :: nil) (nil) 2 1 0 HOoApCpMtmp HSpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HSpM1. try clear HSpM2. try clear HSpM3. try clear HSpm4. try clear HSpm3. try clear HSpm2. try clear HSpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpSpm3 : rk(Oo :: Ap :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoApSpeq : rk(Oo :: Ap :: Sp :: nil) = 3) by (apply LOoApSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApSpmtmp : rk(Oo :: Ap :: Sp :: nil) >= 3) by (solve_hyps_min HOoApSpeq HOoApSpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Sp :: nil) (Oo :: Ap :: Cp :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: Sp :: nil) (Oo :: Ap :: Cp :: Sp :: nil) 3 3 HOoApSpmtmp Hcomp Hincl);apply HT.
}


assert(HOoApCpSpM : rk(Oo :: Ap :: Cp :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpSpm : rk(Oo :: Ap :: Cp :: Sp ::  nil) >= 1) by (solve_hyps_min HOoApCpSpeq HOoApCpSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCpSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(C :: Cp :: Sp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CCpSp requis par la preuve de (?)CCpSp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)CCpSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)ACCpYMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)ACCpYMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)ACCpYMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpm2 : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpm3 : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 3).
{
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil) 3 3 HACMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpm4 : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 4).
{
	try assert(HACCpMeq : rk(A :: C :: Cp :: M :: nil) = 4) by (apply LACCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACCpMmtmp : rk(A :: C :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACCpMeq HACCpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil) 4 4 HACCpMmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CCpSp requis par la preuve de (?)CCpSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Cp :: Y :: M :: Sp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: Cp :: Y :: M ::   de rang : 3 et 3 *)
assert(HCCpSpm2 : rk(C :: Cp :: Sp :: nil) >= 2).
{
	try assert(HACpYMeq : rk(A :: Cp :: Y :: M :: nil) = 3) by (apply LACpYM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACpYMMtmp : rk(A :: Cp :: Y :: M :: nil) <= 3) by (solve_hyps_max HACpYMeq HACpYMM3).
	assert(HACCpYMSpmtmp : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 4) by (solve_hyps_min HACCpYMSpeq HACCpYMSpm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: Cp :: Y :: M :: nil) (C :: Cp :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: Y :: M :: Sp :: nil) (A :: Cp :: Y :: M :: C :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Y :: M :: C :: Cp :: Sp :: nil) ((A :: Cp :: Y :: M :: nil) ++ (C :: Cp :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpYMSpmtmp;try rewrite HT2 in HACCpYMSpmtmp.
	assert(HT := rule_4 (A :: Cp :: Y :: M :: nil) (C :: Cp :: Sp :: nil) (Cp :: nil) 4 1 3 HACCpYMSpmtmp HCpmtmp HACpYMMtmp Hincl); apply HT.
}
try clear HACCpYMSpM1. try clear HACCpYMSpM2. try clear HACCpYMSpM3. try clear HACCpYMSpm4. try clear HACCpYMSpm3. try clear HACCpYMSpm2. try clear HACCpYMSpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCCpSpm3 : rk(C :: Cp :: Sp :: nil) >= 3).
{
	try assert(HOoApCpSpeq : rk(Oo :: Ap :: Cp :: Sp :: nil) = 3) by (apply LOoApCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApCpSpMtmp : rk(Oo :: Ap :: Cp :: Sp :: nil) <= 3) by (solve_hyps_max HOoApCpSpeq HOoApCpSpM3).
	try assert(HOoCApCpSpeq : rk(Oo :: C :: Ap :: Cp :: Sp :: nil) = 4) by (apply LOoCApCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoCApCpSpmtmp : rk(Oo :: C :: Ap :: Cp :: Sp :: nil) >= 4) by (solve_hyps_min HOoCApCpSpeq HOoCApCpSpm4).
	try assert(HCpSpeq : rk(Cp :: Sp :: nil) = 2) by (apply LCpSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HCpSpmtmp : rk(Cp :: Sp :: nil) >= 2) by (solve_hyps_min HCpSpeq HCpSpm2).
	assert(Hincl : incl (Cp :: Sp :: nil) (list_inter (C :: Cp :: Sp :: nil) (Oo :: Ap :: Cp :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: Sp :: nil) (C :: Cp :: Sp :: Oo :: Ap :: Cp :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Sp :: Oo :: Ap :: Cp :: Sp :: nil) ((C :: Cp :: Sp :: nil) ++ (Oo :: Ap :: Cp :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpSpmtmp;try rewrite HT2 in HOoCApCpSpmtmp.
	assert(HT := rule_2 (C :: Cp :: Sp :: nil) (Oo :: Ap :: Cp :: Sp :: nil) (Cp :: Sp :: nil) 4 2 3 HOoCApCpSpmtmp HCpSpmtmp HOoApCpSpMtmp Hincl);apply HT.
}
try clear HCpSpM1. try clear HCpSpM2. try clear HCpSpM3. try clear HCpSpm4. try clear HCpSpm3. try clear HCpSpm2. try clear HCpSpm1. 

assert(HCCpSpM : rk(C :: Cp :: Sp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCCpSpeq HCCpSpM3).
assert(HCCpSpm : rk(C :: Cp :: Sp ::  nil) >= 1) by (solve_hyps_min HCCpSpeq HCCpSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApXMSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(B :: C :: Ap :: X :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApXMSp requis par la preuve de (?)BCApXMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm2 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 2).
{
	try assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm3 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 3).
{
	try assert(HBCMeq : rk(B :: C :: M :: nil) = 3) by (apply LBCM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCMmtmp : rk(B :: C :: M :: nil) >= 3) by (solve_hyps_min HBCMeq HBCMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 3 3 HBCMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApXMSpm4 : rk(B :: C :: Ap :: X :: M :: Sp :: nil) >= 4).
{
	try assert(HBCApMeq : rk(B :: C :: Ap :: M :: nil) = 4) by (apply LBCApM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HBCApMmtmp : rk(B :: C :: Ap :: M :: nil) >= 4) by (solve_hyps_min HBCApMeq HBCApMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: M :: nil) (B :: C :: Ap :: X :: M :: Sp :: nil) 4 4 HBCApMmtmp Hcomp Hincl);apply HT.
}


assert(HBCApXMSpM : rk(B :: C :: Ap :: X :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApXMSpm : rk(B :: C :: Ap :: X :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HBCApXMSpeq HBCApXMSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpYMSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Cp :: Y :: M :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)ACCpYMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)ACCpYMSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpYMSp requis par la preuve de (?)ACCpYMSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpm2 : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpm3 : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 3).
{
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil) 3 3 HACMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpm4 : rk(A :: C :: Cp :: Y :: M :: Sp :: nil) >= 4).
{
	try assert(HACCpMeq : rk(A :: C :: Cp :: M :: nil) = 4) by (apply LACCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACCpMmtmp : rk(A :: C :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACCpMeq HACCpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: nil) 4 4 HACCpMmtmp Hcomp Hincl);apply HT.
}


assert(HACCpYMSpM : rk(A :: C :: Cp :: Y :: M :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpYMSpm : rk(A :: C :: Cp :: Y :: M :: Sp ::  nil) >= 1) by (solve_hyps_min HACCpYMSpeq HACCpYMSpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApXPSp *)
(* dans la couche 0 *)
Lemma LOoABCApXPSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoABCApXPSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoABCApXPSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApXPSp requis par la preuve de (?)OoABCApXPSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXPSpm2 : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXPSpm3 : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApXPSpm4 : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 4).
{
	try assert(HOoABApPeq : rk(Oo :: A :: B :: Ap :: P :: nil) = 4) by (apply LOoABApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABApPmtmp : rk(Oo :: A :: B :: Ap :: P :: nil) >= 4) by (solve_hyps_min HOoABApPeq HOoABApPm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Ap :: P :: nil) (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) 4 4 HOoABApPmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApXPSpM : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApXPSpm : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp ::  nil) >= 1) by (solve_hyps_min HOoABCApXPSpeq HOoABCApXPSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApXPSp : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(Oo :: B :: Ap :: X :: P :: Sp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApXPSp requis par la preuve de (?)OoABApXPSp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApXPSp requis par la preuve de (?)OoABApXPSp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXPSpm2 : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 2).
{
	try assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApXPSpm3 : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApX requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)AApX pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpX requis par la preuve de (?)OoAApBpX pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpXm3 : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 3) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 3) by (solve_hyps_min HOoAApeq HOoAApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: X :: nil) 3 3 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApX requis par la preuve de (?)AApX pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: X ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 2 et 2 *)
assert(HAApXm2 : rk(A :: Ap :: X :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 2) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 2) by (solve_hyps_max HOoApBpeq HOoApBpM2).
	assert(HOoAApBpXmtmp : rk(Oo :: A :: Ap :: Bp :: X :: nil) >= 3) by (solve_hyps_min HOoAApBpXeq HOoAApBpXm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (A :: Ap :: X :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: X :: nil) (Oo :: Ap :: Bp :: A :: Ap :: X :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: A :: Ap :: X :: nil) ((Oo :: Ap :: Bp :: nil) ++ (A :: Ap :: X :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpXmtmp;try rewrite HT2 in HOoAApBpXmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (A :: Ap :: X :: nil) (Ap :: nil) 3 1 2 HOoAApBpXmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApXPSp requis par la preuve de (?)OoBApXPSp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: P :: Sp ::  de rang :  3 et 4 	 AiB : Ap :: X ::  de rang :  2 et 2 	 A : A :: Ap :: X ::   de rang : 2 et 3 *)
assert(HOoBApXPSpm2 : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 2).
{
	assert(HAApXMtmp : rk(A :: Ap :: X :: nil) <= 3) by (solve_hyps_max HAApXeq HAApXM3).
	assert(HOoABApXPSpmtmp : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApXPSpeq HOoABApXPSpm3).
	try assert(HApXeq : rk(Ap :: X :: nil) = 2) by (apply LApX with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HApXmtmp : rk(Ap :: X :: nil) >= 2) by (solve_hyps_min HApXeq HApXm2).
	assert(Hincl : incl (Ap :: X :: nil) (list_inter (A :: Ap :: X :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) (A :: Ap :: X :: Oo :: B :: Ap :: X :: P :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: X :: Oo :: B :: Ap :: X :: P :: Sp :: nil) ((A :: Ap :: X :: nil) ++ (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXPSpmtmp;try rewrite HT2 in HOoABApXPSpmtmp.
	assert(HT := rule_4 (A :: Ap :: X :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil) (Ap :: X :: nil) 3 2 3 HOoABApXPSpmtmp HApXmtmp HAApXMtmp Hincl); apply HT.
}
try clear HAApXM1. try clear HAApXM2. try clear HAApXM3. try clear HAApXm4. try clear HAApXm3. try clear HAApXm2. try clear HAApXm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: X :: P :: Sp ::  de rang :  3 et 4 	 AiB : Oo :: B :: P ::  de rang :  3 et 3 	 A : Oo :: A :: B :: P ::   de rang : 3 et 3 *)
assert(HOoBApXPSpm3 : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 3).
{
	try assert(HOoABPeq : rk(Oo :: A :: B :: P :: nil) = 3) by (apply LOoABP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABPMtmp : rk(Oo :: A :: B :: P :: nil) <= 3) by (solve_hyps_max HOoABPeq HOoABPM3).
	assert(HOoABApXPSpmtmp : rk(Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) >= 3) by (solve_hyps_min HOoABApXPSpeq HOoABApXPSpm3).
	try assert(HOoBPeq : rk(Oo :: B :: P :: nil) = 3) by (apply LOoBP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBPmtmp : rk(Oo :: B :: P :: nil) >= 3) by (solve_hyps_min HOoBPeq HOoBPm3).
	assert(Hincl : incl (Oo :: B :: P :: nil) (list_inter (Oo :: A :: B :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: X :: P :: Sp :: nil) (Oo :: A :: B :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil) ((Oo :: A :: B :: P :: nil) ++ (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApXPSpmtmp;try rewrite HT2 in HOoABApXPSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil) (Oo :: B :: P :: nil) 3 3 3 HOoABApXPSpmtmp HOoBPmtmp HOoABPMtmp Hincl); apply HT.
}
try clear HOoABApXPSpM1. try clear HOoABApXPSpM2. try clear HOoABApXPSpM3. try clear HOoABApXPSpm4. try clear HOoABApXPSpm3. try clear HOoABApXPSpm2. try clear HOoABApXPSpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: X :: P :: Sp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Ap :: P ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: Ap :: P ::   de rang : 4 et 4 *)
assert(HOoBApXPSpm4 : rk(Oo :: B :: Ap :: X :: P :: Sp :: nil) >= 4).
{
	try assert(HOoABCApPeq : rk(Oo :: A :: B :: C :: Ap :: P :: nil) = 4) by (apply LOoABCApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApPMtmp : rk(Oo :: A :: B :: C :: Ap :: P :: nil) <= 4) by (solve_hyps_max HOoABCApPeq HOoABCApPM4).
	try assert(HOoABCApXPSpeq : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) = 4) by (apply LOoABCApXPSp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoABCApXPSpmtmp : rk(Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) >= 4) by (solve_hyps_min HOoABCApXPSpeq HOoABCApXPSpm4).
	try assert(HOoBApPeq : rk(Oo :: B :: Ap :: P :: nil) = 4) by (apply LOoBApP with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HOoBApPmtmp : rk(Oo :: B :: Ap :: P :: nil) >= 4) by (solve_hyps_min HOoBApPeq HOoBApPm4).
	assert(Hincl : incl (Oo :: B :: Ap :: P :: nil) (list_inter (Oo :: A :: B :: C :: Ap :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: X :: P :: Sp :: nil) (Oo :: A :: B :: C :: Ap :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Ap :: P :: Oo :: B :: Ap :: X :: P :: Sp :: nil) ((Oo :: A :: B :: C :: Ap :: P :: nil) ++ (Oo :: B :: Ap :: X :: P :: Sp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApXPSpmtmp;try rewrite HT2 in HOoABCApXPSpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Ap :: P :: nil) (Oo :: B :: Ap :: X :: P :: Sp :: nil) (Oo :: B :: Ap :: P :: nil) 4 4 4 HOoABCApXPSpmtmp HOoBApPmtmp HOoABCApPMtmp Hincl); apply HT.
}


assert(HOoBApXPSpM : rk(Oo :: B :: Ap :: X :: P :: Sp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApXPSpm : rk(Oo :: B :: Ap :: X :: P :: Sp ::  nil) >= 1) by (solve_hyps_min HOoBApXPSpeq HOoBApXPSpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACCpYMSpU : forall Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V ,
rk(A :: B ::  nil) = 2 -> rk(A :: C ::  nil) = 2 -> rk(B :: C ::  nil) = 2 ->
rk(Oo :: A :: B :: C ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 3 -> rk(Ap :: Bp ::  nil) = 2 ->
rk(Ap :: Cp ::  nil) = 2 -> rk(Bp :: Cp ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 2 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 3 -> rk(B :: Ap :: X ::  nil) = 2 -> rk(A :: Bp :: X ::  nil) = 2 ->
rk(C :: Ap :: Y ::  nil) = 2 -> rk(A :: Cp :: Y ::  nil) = 2 -> rk(C :: Bp :: Z ::  nil) = 2 ->
rk(B :: Cp :: Z ::  nil) = 2 -> rk(X :: Y :: Z ::  nil) = 2 -> rk(Oo :: A :: Ap :: M ::  nil) = 4 ->
rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: M ::  nil) = 4 -> rk(Oo :: B :: Bp :: N ::  nil) = 4 -> rk(Oo :: A :: Bp :: P ::  nil) = 4 ->
rk(Ap :: Bp :: M :: P ::  nil) = 4 -> rk(Oo :: B :: Ap :: Q ::  nil) = 4 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: Q ::  nil) = 4 ->
rk(A :: B :: M :: Q ::  nil) = 4 -> rk(Ap :: Bp :: N :: Q ::  nil) = 4 -> rk(M :: N :: P :: Q ::  nil) = 4 ->
rk(Oo :: C :: Ap :: Sp ::  nil) = 4 -> rk(B :: C :: Q :: Sp ::  nil) = 4 -> rk(Ap :: M :: Q :: Sp ::  nil) = 2 ->
rk(Oo :: C :: Bp :: T ::  nil) = 4 -> rk(Bp :: N :: P :: T ::  nil) = 2 -> rk(C :: Sp :: T ::  nil) = 2 ->
rk(Oo :: A :: Cp :: U ::  nil) = 4 -> rk(A :: M :: P :: U ::  nil) = 2 -> rk(Oo :: B :: Cp :: V ::  nil) = 4 ->
rk(B :: N :: Q :: V ::  nil) = 2 -> rk(Cp :: U :: V ::  nil) = 2 -> rk(A :: C :: Cp :: Y :: M :: Sp :: U ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp X Y Z M N P Q Sp T U V 
HABeq HACeq HBCeq HOoABCeq HOoAApeq HApBpeq HApCpeq HBpCpeq HOoApBpCpeq HOoABCApBpCpeq
HBApXeq HABpXeq HCApYeq HACpYeq HCBpZeq HBCpZeq HXYZeq HOoAApMeq HOoABCApBpCpMeq HOoBBpNeq
HOoABpPeq HApBpMPeq HOoBApQeq HOoABCApBpCpQeq HABMQeq HApBpNQeq HMNPQeq HOoCApSpeq HBCQSpeq HApMQSpeq
HOoCBpTeq HBpNPTeq HCSpTeq HOoACpUeq HAMPUeq HOoBCpVeq HBNQVeq HCpUVeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpYMSpU requis par la preuve de (?)ACCpYMSpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpYMSpU requis par la preuve de (?)ACCpYMSpU pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpYMSpU requis par la preuve de (?)ACCpYMSpU pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpUm2 : rk(A :: C :: Cp :: Y :: M :: Sp :: U :: nil) >= 2).
{
	try assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: Cp :: Y :: M :: Sp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: Cp :: Y :: M :: Sp :: U :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpUm3 : rk(A :: C :: Cp :: Y :: M :: Sp :: U :: nil) >= 3).
{
	try assert(HACMeq : rk(A :: C :: M :: nil) = 3) by (apply LACM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACMmtmp : rk(A :: C :: M :: nil) >= 3) by (solve_hyps_min HACMeq HACMm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: U :: nil) 3 3 HACMmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACCpYMSpUm4 : rk(A :: C :: Cp :: Y :: M :: Sp :: U :: nil) >= 4).
{
	try assert(HACCpMeq : rk(A :: C :: Cp :: M :: nil) = 4) by (apply LACCpM with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (X := X) (Y := Y) (Z := Z) (M := M) (N := N) (P := P) (Q := Q) (Sp := Sp) (T := T) (U := U) (V := V) ;try assumption).
	assert(HACCpMmtmp : rk(A :: C :: Cp :: M :: nil) >= 4) by (solve_hyps_min HACCpMeq HACCpMm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: U :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Cp :: M :: nil) (A :: C :: Cp :: Y :: M :: Sp :: U :: nil) 4 4 HACCpMmtmp Hcomp Hincl);apply HT.
}


assert(HACCpYMSpUM : rk(A :: C :: Cp :: Y :: M :: Sp :: U ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACCpYMSpUm : rk(A :: C :: Cp :: Y :: M :: Sp :: U ::  nil) >= 1) by (solve_hyps_min HACCpYMSpUeq HACCpYMSpUm1).
intuition.
Qed.

